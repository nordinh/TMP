{"version":3,"file":"slide.js","sources":["slide.js","webpack/bootstrap 872e12b683fadda3582f","./main.es6","./main.es6*","../~/style-loader/addStyle.js","./lib/events.es6","./lib/events.es6*","@traceur/generated/TemplateParser/3*","@traceur/generated/TemplateParser/0*","../~/webpack/~/node-libs-browser/lib/_process.js","./deck.es6","./deck.es6*","./lib/text.es6","./lib/text.es6*","./modules/background.es6","./modules/background.es6*","./modules/editor.es6","./modules/editor.es6*","./modules/editor/emacs.es6","./modules/editor/emacs.es6*","./modules/image.es6","./modules/image.es6*","../~/codemirror/addon/edit/closebrackets.js","../~/codemirror/addon/edit/matchbrackets.js","../~/codemirror/addon/hint/anyword-hint.js","../~/codemirror/addon/hint/javascript-hint.js","../~/codemirror/addon/hint/show-hint.js","../~/codemirror/addon/lint/lint.js","../~/codemirror/addon/search/match-highlighter.js","../~/codemirror/addon/selection/active-line.js","../~/codemirror/lib/codemirror.js","../~/codemirror/mode/javascript/javascript.js","../~/codemirror/addon/hint/show-hint.css","../~/codemirror/addon/lint/lint.css","../~/codemirror/lib/codemirror.css","../~/codemirror/theme/xq-light.css","./css/screen.less ../~/less-loader","./css/fonts/Helvetica/helvetica.css","./css/fonts/Inconsolata/inconsolata.css","../~/spin.js/spin.js","../~/codemirror/addon/hint/show-hint.css*","../~/codemirror/addon/lint/lint.css*","../~/codemirror/lib/codemirror.css*","../~/codemirror/theme/xq-light.css*","./css/screen.less","../~/traceur/bin/traceur-runtime.js","./css/fonts/Helvetica/HelveticaNeueLTStd-Bd.otf","./css/fonts/Helvetica/HelveticaNeueLTStd-BdIt.otf","./css/fonts/Helvetica/HelveticaNeueLTStd-Md.otf","./css/fonts/Helvetica/HelveticaNeueLTStd-MdIt.otf","./css/fonts/Inconsolata/Inconsolata-Bold.ttf","./css/fonts/Inconsolata/Inconsolata-Regular.ttf","../m/doge.svg","../~/webpack/~/node-libs-browser/lib/events.js","../~/webpack/~/node-libs-browser/lib/path.js","../~/webpack/~/node-libs-browser/~/vm-browserify/index.js","../~/webpack/~/node-libs-browser/util/filter.js","../~/webpack/~/node-libs-browser/util/indexOf.js","../~/webpack/~/node-libs-browser/util/isArray.js","./lib/mousetrap.js"],"names":["modules","require","moduleId","installedModules","exports","module","id","loaded","call","cache","p","window","global","Deck","deck","document","getElementById","editor","background","image","cssCode","styleElement","createElement","type","styleSheet","cssText","appendChild","createTextNode","head","getElementsByTagName","removeChild","getPrefix","cachedPrefix","regex","elem","body","$prop","style","undefined","prop","test","match","$traceurRuntime","toProperty","vendorPrefix","cachedEvents","hasOwnProperty","vp","toLowerCase","pp","setProperty","on","emitter","eventName","handler","context","bind","addEventListener","once","wrapper","onceHandler","event","removeEventListener","until","untilHandler","off","events","EventEmitter","nextTick","canSetImmediate","setImmediate","canPost","postMessage","f","queue","ev","source","data","stopPropagation","length","fn","shift","push","setTimeout","platform","arch","execPath","title","pid","browser","env","argv","binding","name","Error","path","cwd","chdir","dir","resolve","exit","kill","umask","dlopen","uptime","memoryUsage","uvCounters","features","toArray","indexable","out","l","$i","i","container","deckModules","slideIndex","slide","slides","indexOf","$__0","this","querySelectorAll","currentSlide","forEach","children","childNodes","classList","add","child","deactivateSlide","contains","remove","activateSlide","cleanupModules","activateModules","location","hash","nextSlide","previousSlide","prevSlide","initModules","mod","slideData","dataset","deckData","mods","arg","_deck_modules","activate","stabiliseModules","stabilise","cleanup","transitionEnd","e","target","callback","mousetrap","exec","parseInt","minIndent","text","split","reduce","min","line","trim","indent","trimLeft","Math","alignIndents","map","slice","trimRight","join","cleanText","Background","url","preload","src","parentNode","backgroundImage","Editor","mode","args","querySelector","initialCode","innerHTML","keymap","console","log","arguments","send","key","emacs","yank","Tab","cm","indentLine","getDoc","getCursor","CodeMirror","showHint","Esc","input","setAttribute","focus","options","value","extraKeys","lineWrapping","matchBrackets","autoCloseBrackets","styleActiveLine","theme","message","targetFrame","contentWindow","JSON","stringify","editorFrame","targetContainer","loaderFrame","factor","clientWidth","clientHeight","spinner","Spinner","color","shadow","hwaccel","radius","width","trail","lines","spin","setSize","display","href","stop","refresh","addToRing","str","killRing","growRingTop","getFromRing","n","posEq","a","b","ch","from","to","mayGrow","getRange","lastKill","pos","isClean","gen","replaceRange","changeGeneration","precise","digits","state","emacsPrefix","clearPrefix","Number","maybeClearPrefix","emacsPrefixMap","prefixPreservingKeys","maybeDuplicateInput","dup","origin","one","txt","replaceSelection","repeated","cmd","typeof","execCommand","prefix","Alt-G","Ctrl-X","Ctrl-Q","Ctrl-U","killKey","start","end","clipPos","Pos","yankKey","setSelection","Image","charsAround","buildKeymap","pairs","Backspace","somethingSelected","getOption","Pass","cur","around","closingBrackets","left","right","surround","selection","getSelection","maybeOverwrite","ahead","getTokenAt","getLine","nextChar","charAt","curChar","isWordChar","SPACE_CHAR_REGEX","anchor","buildExplodeHandler","operation","newPos","DEFAULT_BRACKETS","DEFAULT_EXPLODE_ON_ENTER","defineOption","val","old","Init","removeKeyMap","explode","Enter","addKeyMap","findMatchingBracket","where","strict","scan","lineNo","forward","maxScanLen","d","re","getTokenTypeAt","matching","stack","pop","maxScanLineLength","maxScanLines","getLineHandle","found","lineCount","max","autoclear","maxHighlightLen","maxHighlightLineLength","markText","className","two","ie_lt8","focused","clear","doMatchBrackets","currentlyHighlighted","navigator","userAgent","documentMode","(",")","[","]","{","}","defineExtension","WORD","RANGE","registerHelper","word","range","curLine","curWord","list","seen","RegExp","endLine","firstLine","lastLine","m","lastIndexOf","Object","prototype","arr","arrayContains","item","Array","scriptHint","keywords","getToken","token","tprop","innerMode","getMode","string","getCompletions","javascriptHint","javascriptKeywords","getCoffeeScriptToken","replace","coffeescriptHint","coffeescriptKeywords","maybeAdd","gatherCompletions","obj","stringProps","arrayProps","Function","funcProps","base","additionalContext","jQuery","_","v","localVars","next","globalVars","Completion","getHints","widget","onClose","getText","completion","buildKeyMap","handle","addBinding","bound","baseMap","ourMap","Up","moveFocus","Down","PageUp","menuSize","PageDown","Home","setFocus","End","pick","close","customKeys","getHintElement","hintsElement","el","nodeName","toUpperCase","Widget","hints","selectedHint","getDefaultSelection","completions","elt","HINT_ELEMENT_CLASS","ACTIVE_HINT_ELEMENT_CLASS","render","displayText","hintId","cursorCoords","alignWithWord","top","bottom","below","winW","innerWidth","offsetWidth","documentElement","winH","innerHeight","offsetHeight","box","getBoundingClientRect","overlapY","height","curTop","cursor","overlapX","keyMap","avoidWrap","changeActive","screenAmount","closeOnUnfocus","closingOnBlur","onBlur","onFocus","clearTimeout","startScroll","getScrollInfo","onScroll","curScroll","getWrapperElement","newTop","point","pageYOffset","scrollTop","t","srcElement","completeOnSingleClick","signal","firstChild","async","hint","auto","completionActive","showHints","active","completeSingle","showWidget","done","finished","activity","update","finishUpdate","data_","clearDebounce","debounce","cancelAnimationFrame","startPos","startLen","closeOn","requestAnimationFrame","closeCharacters","node","offsetTop","floor","words","helpers","getHelpers","getHelper","fromList","anyword","commands","autocomplete","showTooltip","content","position","tt","clientY","clientX","cloneNode","opacity","rm","hideTooltip","showTooltipFor","hide","tooltip","poll","setInterval","clearInterval","LintState","hasGutter","marked","timeout","onMouseOver","parseOptions","getAnnotations","clearMarks","lint","clearGutter","GUTTER_ID","makeMarker","labels","severity","multiple","tooltips","marker","inner","getMaxSeverity","groupByLine","annotations","ann","annotationTooltip","SEVERITIES","tip","startLinting","updateLinting","getValue","annotationsNotSorted","anns","maxSeverity","tipLabel","createDocumentFragment","formatAnnotation","__annotation","setGutterMarker","onUpdateLinting","onChange","delay","popupSpanTooltip","nearby","spans","findMarksAt","coordsChar","j","span","optionHandler","gutters","hasLintGutter","State","minChars","showToken","DEFAULT_TOKEN_STYLE","DEFAULT_MIN_CHARS","DEFAULT_DELAY","overlay","cursorActivity","matchHighlighter","highlightMatches","removeOverlay","addOverlay","makeOverlay","boundariesAround","stream","query","hasBoundary","skipTo","skipToEnd","over","clearActiveLine","removeLineClass","activeLine","WRAP_CLASS","BACK_CLASS","updateActiveLine","selectedLine","getLineHandleVisualStart","addLineClass","selectionChange","sel","prev","place","opt","defaults","setGuttersForLineNumbers","docStart","first","makeDisplay","updateGutters","autofocus","mobile","focusInput","keyMaps","overlays","modeGen","overwrite","suppressEdits","pasteIncoming","cutIncoming","draggingText","highlight","Delayed","themeChanged","doc","Doc","attachDoc","old_ie","resetInput","registerEventHandlers","hasFocus","activeElement","optionHandlers","propertyIsEnumerable","initHooks","webkit","ios","border","inputDiv","scrollbarH","scrollbarV","scrollbarFiller","gutterFiller","lineDiv","selectionDiv","otherCursor","measure","lineSpace","mover","sizer","heightForcer","scrollerCutOff","lineGutter","scroller","zIndex","paddingRight","draggable","khtml","minWidth","viewOffset","lastSizeC","showingFrom","showingTo","lineNumWidth","lineNumInnerWidth","lineNumChars","prevInput","alignWidgets","pollingFast","cachedCharWidth","cachedTextHeight","cachedPaddingH","measureLineCache","measureLineCachePos","inaccurateSelection","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","loadMode","modeOption","resetModeState","iter","stateAfter","styles","frontier","startWorker","curOp","regChange","wrappingChanged","computeMaxLength","estimateLineHeights","clearCaches","updateScrollbars","estimateHeight","th","textHeight","wrapping","perLine","charWidth","lineIsHidden","ceil","est","estHeight","updateLineHeight","keyMapChanged","guttersChanged","alignHorizontally","specs","removeChildren","gutterClass","gElt","lineLength","merged","len","collapsedSpanAtStart","find","collapsedSpanAtEnd","lineNumbers","concat","splice","docHeight","totalHeight","paddingVert","minHeight","scrollHeight","needsH","scrollWidth","needsV","scrollbarWidth","coverGutterNextToScrollbar","fixedGutter","mac_geLion","mac_geMountainLion","pointerEvents","visibleLines","viewPort","paddingTop","lineAtHeight","comp","compensateForHScroll","scrollLeft","gutterW","nextSibling","alignable","maybeUpdateLineNumberWidth","last","lineNumberFor","size","innerW","padding","String","lineNumberFormatter","firstLineNumber","getRect","updateDisplay","changes","forced","updated","oldFrom","oldTo","visible","oldWidth","updateDisplayInner","updateSelection","signalLater","marginLeft","positionsChangedFrom","Infinity","diff","viewportMargin","sawCollapsedSpans","visualLine","intact","computeIntact","newTo","intactLines","updateViewOffset","sort","patchDisplay","different","updateHeightsInViewport","prevBottom","lineObj","bot","widgets","heightAtLine","change","intact2","l2","getDimensions","offsetLeft","fixedPos","gutterTotalWidth","gutterLeft","gutterWidth","wrapperWidth","updateNumbersFrom","mac","currentWheelTarget","dims","nextIntact","lineN","previousSibling","w","showIfHidden","wrap","replaceChild","wnode","handleMouseEvents","ignoreEvents","positionLineWidget","lineNumber","setTextContent","reuse","search","lineNode","buildLineElement","insertBefore","built","buildLineContent","lineElement","pre","markers","gutterMarkers","bgClass","wrapClass","isOk","widgetsSeen","above","gutterWrap","k","ws","noHScroll","coverGutter","paddingLeft","collapsed","showCursorWhenSelecting","updateSelectionCursor","updateSelectionRange","moveInputWithCursor","headPos","wrapOff","lineOff","cursorHeight","other","fragment","rightSide","drawForLine","fromArg","toArg","coords","bias","charCoords","lineLen","iterateBidiSections","getOrder","rightPos","leftPos","tmp","leftSide","paddingH","fromLine","toLine","singleVLine","leftEnd","rightStart","removeChildrenAndAdd","restartBlink","blinker","visibility","cursorBlinkRate","time","startState","set","highlightWorker","prevChange","Date","workTime","copyState","getStateBefore","changed","oldStyles","highlightLine","ischange","processLine","workDelay","findStartLine","minindent","minline","lim","indented","countColumn","tabSize","save","getComputedStyle","currentStyle","measureChar","measureLine","crude","r","findCachedMeasurement","memo","markedSpans","classes","textClass","clearCachedMeasurement","exists","cached","measureLineInner","measureRect","rect","outer","maxBot","vranges","rtop","rbot","finishRect","crudeMeasuringFrom","crudelyMeasureLine","emptyArray","chunk","chunks","ie_lt9","getClientRects","nodeType","rects","measureRight","copy","Line","measureLineWidth","hasBadSpan","sp","zeroWidthElement","pageScrollX","pageXOffset","pageScrollY","intoCoordSystem","widgetHeight","yOff","lOff","xOff","fromCoordSystem","localBox","lineSpaceBox","measurement","get","getBidi","partPos","part","order","level","bidiLeft","bidiRight","getBidiPartAt","bidiOther","PosWithInfo","outside","xRel","x","y","coordsCharInner","mergedPos","getX","wrongLine","innerOff","adjust","bidi","dist","lineLeft","lineRight","fromX","fromOutside","toX","toOutside","moveVisually","xDiff","isExtendingChar","step","middle","middleX","measureText","startOperation","forceUpdate","updateInput","userSelChange","textChanged","selectionChanged","updateMaxLine","updateScrollPos","nextOpId","delayedCallbackDepth","delayedCallbacks","endOperation","op","maxScrollLeft","setScrollLeft","newScrollPos","calculateScrollPos","scrollToPos","scrollPosIntoView","margin","scrollCursorIntoView","hidden","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","delayed","cm1","withOp","result","apply","docOperation","runInOp","lendiff","slowPoll","pollInterval","readInput","fastPoll","missed","hasSelection","isReadOnly","disableInput","fakedLastChar","substring","ie","inputHasSelection","same","charCodeAt","inserted","changeEvent","splitLines","makeChange","electricChars","smartIndent","electric","getModeAt","user","minimal","selected","hasCopyEvent","selectInput","readOnly","ensureFocus","cantEdit","reFocus","onResize","resizeTimer","knownScrollbarWidth","unregister","drag_","signalDOMEvent","onDragEvent","addStop","e_stop","prepareCopy","onMouseDown","posFromMouse","clickInGutter","eventInWidget","e_preventDefault","findWordAt","extendSelection","captureMiddleClick","onContextMenu","setScrollTop","onScrollWheel","onKeyUp","onKeyDown","onKeyPress","dragDrop","onDragStart","onDrop","lastMiddleDown","selectionStart","selectionEnd","blur","e_target","liberal","space","doSelect","lastPos","startstart","startend","posLess","extend","curCount","counter","editorSize","move","up","shiftKey","e_button","now","lastDoubleClick","selectLine","lastClick","dragAndDrop","dragEnd","e2","abs","ie_lt10","buttons","gutterEvent","prevent","signalfn","mX","mY","lineBox","hasHandler","e_defaultPrevented","g","gutter","contextMenuInGutter","lastDrop","files","dataTransfer","FileReader","File","read","loadFile","file","reader","onload","readAsText","getData","curFrom","curTo","setData","setDragImage","safari","img","opera","_top","gecko","isScroller","dx","wheelDeltaX","dy","wheelDeltaY","detail","axis","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","scroll","wheelPixelsPerUnit","pixels","wheelSamples","movedX","movedY","sample","doHandleBinding","dropShift","prevShift","allKeyMaps","maps","handleKeyBinding","startMap","getKeyMap","maybeTransition","isModifierKey","keyName","handled","keymaps","lookupKey","motion","oldKeyCode","keyCode","handleCharBinding","onKeyEvent","returnValue","code","lastStoppedKey","metaKey","ctrlKey","charCode","which","fromCharCode","prepareSelectAllHack","extval","rehide","oldCSS","scrollPos","detectingSelectAll","selectAll","reset","resetSelectionOnContextMenu","mouseup","clipPostChange","preLine","clipToLen","lst","inside","computeSelAfterChange","changeEnd","adjustPos","filterChange","canceled","cancel","selUpdate","ignoreReadOnly","sawReadOnlySpans","removeReadOnlyRanges","makeChangeNoReadonly","selAfter","addToHistory","NaN","makeChangeSingleDoc","stretchSpansOverChange","rebased","linkedDocs","sharedHist","history","rebaseHist","makeChangeFromHistory","hist","undone","anti","anchorBefore","anchorAfter","headBefore","headAfter","generation","maxGeneration","filter","historyChangeFromChange","after","mergeOldSpans","shiftDoc","distance","shiftPos","removed","getBetween","makeChangeSingleDocInEditor","updateDoc","recomputeMaxLength","checkWidthStart","changeObj","cmp","copyPos","clipLine","linelen","isLine","posBefore","filterSelectionChange","checkAtomic","filtered","goalColumn","skipAtomic","inv","reCheckSelection","mayClear","flipped","curPos","inclusiveLeft","inclusiveRight","explicitlyCleared","atomic","cursorScrollMargin","doScroll","phantom","scrollNode","scrollIntoView","endCoords","startTop","startLeft","x1","y1","x2","y2","snapMargin","screen","screentop","docBottom","atTop","atBottom","screenw","screenleft","gutterw","atLeft","addToScrollPos","how","aggressive","curSpace","indentation","curSpaceString","indentUnit","indentString","indentWithTabs","spaceStr","changeLine","no","findPosH","unit","visually","findNextLine","possible","moveOnce","boundToLine","moveLogically","origDir","sawType","group","hitSide","findPosV","pageSize","startChar","check","option","deflt","notOnInit","nstate","a1","a2","lookup","nofallthrough","fallthrough","toString","keyNames","noShift","altGraphKey","altKey","flipCtrlCmd","StringStream","lastColumnPos","lastColumnValue","lineStart","TextMarker","shared","markTextShared","copyObj","clearWhenEmpty","replacedWith","conflictingCollapsedRange","addMarkedSpan","clearOnEnter","clearHistory","nextMarkerId","startStyle","endStyle","SharedTextMarker","primary","me","parent","linked","isParent","getMarkedSpanFor","removeMarkedSpan","attachLine","markedSpansBefore","startCh","isInsert","nw","startsBefore","insertLeft","endsAfter","markedSpansAfter","endCh","oldFirst","oldLast","sameLine","offset","clearEmptySpans","newMarkers","gapMarkers","gap","getOldSpans","stretched","oldCur","stretchCur","mark","parts","mk","newParts","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","lineIsHiddenInner","detachMarkedSpans","detachLine","attachMarkedSpans","widgetOperation","addLineWidget","LineWidget","insertAt","aboveVisible","updateLine","cleanUpLine","runMode","forceToEnd","flattenSpans","curStart","curStyle","blankLine","eol","maxHighlightLength","addModeClass","mName","st","o","at","i_end","opaque","getLineStyles","startAt","interpretTokenStyle","builder","lineClass","index","styleToClassCacheWithMode","styleToClassCache","realLine","copyWidgets","empty","col","measuredSomething","addToken","buildTokenMeasure","buildToken","buildTokenSplitSpaces","insertLineContent","defaultSpecialCharPlaceholder","special","specialChars","lastIndex","skipped","tabWidth","specialCharPlaceholder","fullStyle","spanAffectsWrapping","whiteSpace","buildCollapsedSpan","ignoreWidget","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","foundBookmarks","upto","tokenText","spansFor","lastText","lastSpans","nlines","wholeLineUpdateBefore","added","insert","LeafChunk","BranchChunk","chunkSize","sharedHistOnly","propagate","skip","rel","sz","getLines","h","lh","bidiOrdering","makeHistory","startGen","undoDepth","lastTime","lastOp","lastOrigin","attachLocalSpans","existing","histChange","opId","historyEventDelay","removeClearedSpans","copyHistoryArray","newGroup","newChanges","rebaseHistSel","rebaseHistArray","array","sub","ok","copied","readAfter","stopMethod","preventDefault","e_stopPropagation","cancelBubble","defaultPrevented","button","attachEvent","_handlers","detachEvent","bnd","fireDelayed","override","codemirrorIgnore","eventMixin","ctor","startIndex","startValue","spaceStrs","select","_e","collection","createObj","props","Obj","inst","nonASCIISingleCaseWordChar","isEmpty","extendingChars","tag","count","textContent","zwspSupported","visual","lineEnd","compareBidiLevel","linedir","moveInLine","byUnit","ie_gt10","qtwebkit","chrome","vendor","windows","opera_version","constructor","setOption","spec","modeSpec","indentSelection","current","before","mid","help","helperType","_global","pred","getStateAfter","defaultTextHeight","defaultCharWidth","gutterID","cls","removeLineWidget","lineInfo","getViewport","addWidget","vert","horiz","vspace","hspace","triggerOnKeyDown","triggerOnKeyPress","triggerOnKeyUp","amount","moveH","rtlMoveVisually","deleteH","moveV","goal","toggleOverwrite","scrollTo","co","sPos","interpret","oldHeight","swapDoc","getInputField","getScrollerElement","getGutterElement","setValue","integer","disabled","tabIndex","modes","mimeModes","defineMode","dependencies","defineMIME","mime","resolveMode","mfactory","modeObj","modeExtensions","exts","modeProps","extendMode","properties","func","defineDocExtension","defineInitHook","registerGlobalHelper","predicate","info","killLine","deleteLine","delLineLeft","undo","redo","goDocStart","goDocEnd","goLineStart","goLineStartSmart","firstNonWS","inWS","goLineEnd","goLineRight","goLineLeft","goLineUp","goLineDown","goPageUp","goPageDown","goCharLeft","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentMore","indentLess","insertTab","defaultTab","transposeChars","newlineAndIndent","basic","Left","Right","Delete","Shift-Backspace","Shift-Tab","Insert","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-Up","Ctrl-End","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Alt-Backspace","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Ctrl-K","Ctrl-T","fromTextArea","textarea","tabindex","placeholder","getAttribute","form","leaveSubmitMethodAlone","realSubmit","submit","wrappedSubmit","getTextArea","toTextArea","sol","peek","eat","eatWhile","eatSpace","backUp","column","pattern","consume","caseInsensitive","cased","substr","hideFirstChars","bothSides","oldH","removeInner","collapse","insertInner","iterN","spilled","newleaf","maybeSpill","sibling","myIndex","used","nextDocId","cleanGeneration","lineSep","setLine","removeLine","getLineNumber","setCursor","setExtending","historySize","markClean","forceSplit","getHistory","setHistory","histData","setBookmark","realOpts","findMarks","getAllMarks","posFromIndex","indexFromPos","copyHistory","linkedDoc","unlinkDoc","link","splitIds","iterLinkedDocs","getEditor","eachLine","dontDelegate","method","ms","replaceGetRect","div","nl","rt","te","ownerDocument","createRange","parentElement","compareEndPoints","oncopy",3,8,9,13,16,17,18,19,20,27,32,33,34,35,36,37,38,39,40,44,45,46,59,61,91,92,93,107,109,127,173,186,187,188,189,190,191,192,219,220,221,222,63232,63233,63234,63235,63272,63273,63275,63276,63277,63302,"charType","lowTypes","arabicTypes","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","types","nstart","unshift","version","config","parserConfig","readRegexp","escaped","inSet","ret","tp","cont","tokenBase","tokenize","tokenString","tokenComment","lastType","isOperatorChar","tokenQuasi","known","quote","jsonldMode","isJsonldKeyword","maybeEnd","findFatArrow","fatArrowAt","arrow","depth","sawSomething","bracket","brackets","JSLexical","align","inScope","varname","cx","vars","parseJS","cc","lexical","combinator","jsonMode","expression","statement","lex","pass","register","inList","pushcontext","defaultVars","popcontext","pushlex","poplex","expect","wanted","callee","vardef","block","maybeelse","functiondef","forspec","maybelabel","funarg","afterModule","objlit","afterExport","afterImport","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","atomicTypes","maybeexpressionNoComma","maybeexpression","comprehension","arrayLiteral","contCommasep","objprop","expr","quasi","property","continueQuasi","getterSetter","afterprop","what","proceed","maybetype","isTS","typedef","maybeAssign","vardefCont","proppattern","_type","forspec1","forspec2","formaybeinof","forspec3","classNameAfter","maybeFrom","importSpec","maybeArrayComprehension","statementIndent","jsonld","json","typescript","kw","A","B","C","operator","atom","jsKeywords","if","while","with","else","do","try","finally","return","break","continue","new","delete","throw","debugger","var","const","let","function","catch","for","switch","case","default","in","instanceof","true","false","null","class","super","yield","export","import","extends","tsKeywords","interface","public","private","protected","static","number","bool","any","attr","variable","regexp","jsonld-keyword","basecolumn","textAfter","firstChar","c","closing","doubleIndentSwitch","blockCommentStart","blockCommentEnd","lineComment","fold","root","factory","createEl","ins","addAnimation","alpha","z","useCssAnimations","animations","sheet","insertRule","cssRules","s","prefixes","css","merge","def","offsetParent","getColor","idx","opts","initVML","vml","addRule","grp","coordsize","coordorigin","seg","rotation","arcsize","corners","rotate","direction","speed","fps","ep","self","ostep","astep","anim","fill","boxShadow","transformOrigin","transform","borderRadius","animation","probe","behavior","adj","process","nonEnum","configurable","enumerable","writable","newUniqueString","random","isSymbol","symbol","SymbolValue","typeOf","Symbol","description","TypeError","$defineProperty","symbolDataProperty","symbolInternalProperty","symbolDescriptionProperty","$freeze","symbolValues","getOwnPropertyNames","object","rv","names","$getOwnPropertyNames","getOwnPropertyDescriptor","$getOwnPropertyDescriptor","getOwnPropertySymbols","$hasOwnProperty","traceur","sym","desc","defineProperty","descriptor","$create","polyfillObject","is","assign","mixin","exportStar","toObject","$TypeError","$Object","spread","valueToSpread","getPropertyDescriptor","$getPrototypeOf","superDescriptor","homeObject","proto","superCall","superGet","superSet","getDescriptors","descriptors","createClass","staticObject","superClass","__proto__","getProtoParent","$defineProperties","defaultSuperCall","addIterator","iterator","GeneratorContext","GState","ST_NEWBORN","storedException","finallyFallThrough","sent","tryStack_","getNextOrThrow","ctx","moveNext","action","ST_EXECUTING","ST_CLOSED","ST_SUSPENDED","generatorWrap","innerFunction","getMoveNext","AsyncFunctionContext","err","Promise","reject","asyncWrap","createCallback","newState","createErrback","ex","END_STATE","setupGlobals","create","defineProperties","freeze","getPrototypeOf","symbolValue","valueOf","pushTry","catchState","finallyState","popTry","buildFromEncodedParts","opt_scheme","opt_userInfo","opt_domain","opt_port","opt_path","opt_queryData","opt_fragment","uri","splitRe","removeDotSegments","leadingSlash","trailingSlash","segments","segment","joinAndCanonicalizePath","ComponentIndex","PATH","SCHEME","USER_INFO","DOMAIN","PORT","QUERY_DATA","FRAGMENT","canonicalizeUrl","resolveUrl","baseParts","isAbsolute","getUncoatedModuleInstantiator","ModuleStore","normalize","moduleInstantiators","Module","uncoatedModule","isLive","coatedModule","getter","liveModuleSentinel","descr","preventExtensions","baseURL","$__2","UncoatedModuleEntry","value_","UncoatedModuleInstantiator","$UncoatedModuleInstantiator","getUncoatedModule","moduleInstances","refererName","normalizedName","moduleInstance",{"end":{"file":"slide.js","comments_before":[],"nlb":false,"endpos":380689,"pos":380682,"col":9,"line":9627,"value":"baseURL","type":"name","_comments_dumped":true},"start":{"file":"slide.js","comments_before":[],"nlb":false,"endpos":380689,"pos":380682,"col":9,"line":9627,"value":"baseURL","type":"name","_comments_dumped":true},"name":"baseURL"},"registerModule","bundleStore","deps","execute","getAnonymousModule","getForTesting","testingPrefix_","keys","some","System","getModuleImpl","instantiator","toUint32","createArrayIterator","kind","ArrayIterator","iteratorObject_","arrayIteratorNextIndex_","arrayIterationKind_","createIteratorResultObject","entries","ARRAY_ITERATOR_KIND_ENTRIES","ARRAY_ITERATOR_KIND_KEYS","values","ARRAY_ITERATOR_KIND_VALUES","$__4","$__5","itemKind","useNextTick","flush","useMutationObserver","iterations","observer","BrowserMutationObserver","observe","characterData","useSetTimeout","tuple","scheduleFlush","$__default","browserGlobal","MutationObserver","WebKitMutationObserver","isPromise","status_","chain","promise","onResolve","onReject","deferred","getDeferred","onResolve_","onReject_","promiseReact","promiseResolve","promiseDone","promiseReject","status","reactions","promiseCoerce","then","thenableSymbol","resolver","$__6","cast","all","resolutions","race","startsWith","$toString","stringLength","searchString","isNaN","$indexOf","endsWith","searchLength","$lastIndexOf","repeat","RangeError","codePointAt","second","raw","callsite","fromCodePoint","highSurrogate","lowSurrogate","codeUnits","codePoint","isFinite","maybeDefineMethod","maybeAddFunctions","functions","polyfillPromise","polyfillString","polyfillArray","polyfill","$__9","isArray","defaultMaxListeners","setMaxListeners","_events","_maxListeners","emit","error","listeners","addListener","listener","warned","trace","removeListener","removeAllListeners","normalizeArray","allowAboveRoot","splitPathRe","resolvedPath","resolvedAbsolute","paths","dirname","isWindows","basename","ext","extname","relative","fromParts","toParts","samePartsLength","outputParts","sep","Object_keys","res","xs","Script","runInNewContext","iframe","win","eval","execScript","runInThisContext","runInContext","createScript","createContext","_addEvent","_characterFromEvent","character","_MAP","_KEYCODE_MAP","_modifiersMatch","modifiers1","modifiers2","_resetSequences","doNotReset","activeSequences","_sequenceLevels","_nextExpectedAction","_getMatches","modifiers","sequenceName","combination","matches","_callbacks","_isModifier","seq","deleteCombo","combo","deleteSequence","_eventModifiers","_preventDefault","_stopPropagation","_fireCallback","sequence","Mousetrap","stopCallback","_handleKey","callbacks","maxLevel","processedSequenceCallback","ignoreThisKeypress","_ignoreNextKeypress","_handleKeyEvent","_ignoreNextKeyup","handleKey","_resetSequenceTimer","_resetTimer","_getReverseMap","_REVERSE_MAP","_pickBestAction","_bindSequence","_increaseSequence","nextAction","_callbackAndReset","isFinal","wrappedCallback","_getKeyInfo","_bindSingle","_keysFromString","_SPECIAL_ALIASES","_SHIFT_MAP","_directMap","_bindMultiple","combinations",224,106,110,111,"~","!","@","#","$","%","^","&","*","+",":","\"","<",">","?","|","command","escape","unbind","trigger","element","tagName","isContentEditable"],"mappings":"CAAS,SAAUA,GCKnB,QAAAC,GAAAC,GAEA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAtBA,GAAAD,KAqCA,OAVAF,GAAAD,UAGAC,EAAAQ,MAAAN,EAGAF,EAAAS,EAAA,SAIAT,EAAA,KDMM,SAASI,EAAQD,EAASH,GE7ChC,YCAAU,QAAAC,OAAAD,OACAV,EAAA,IACAA,EAAA,GACI,IAAAY,GAAAZ,EAAA,EACJU,QAAAG,KAAA,GAAAD,GAAAE,SAAAC,eAAA,WACEC,OAAAhB,EAAA,GACAiB,WAAAjB,EAAA,GACAkB,MAAAlB,EAAA,MHuDI,SAASI,GI1DfA,EAAAD,QAAA,SAAAgB,GAIA,GAAAC,GAAAN,SAAAO,cAAA,QACAD,GAAAE,KAAA,WACAF,EAAAG,WACAH,EAAAG,WAAAC,QAAAL,EAEAC,EAAAK,YAAAX,SAAAY,eAAAP,GAEA,IAAAQ,GAAAb,SAAAc,qBAAA,UAEA,OADAD,GAAAF,YAAAL,GACA,WACAO,EAAAE,YAAAT,MJsEM,SAAShB,GKxFf,YCGA,SAAA0B,KACE,GAAAC,EAAkB,MAAAA,EDEpB,IAAAC,GAAA,yCACAC,EAAAnB,SAAAoB,IACA,QAAAC,KAAAF,GAAAG,MACA,IACA,KAAAC,QACK,MAAAC,GCHD,GDIJA,EAAAH,ECJIH,EAAAO,KAAAD,GACE,MAAAP,GAAAO,EAAAE,MAAAR,GAAAS,gBAAAC,WAAA,IAGJ,MACEX,GADFU,gBAAAC,WAAA,kBAAAT,GAAAG,MACE,SAEFK,gBAAAC,WAAA,iBAAAT,GAAAG,MACE,QAEF,GAKF,QAAAO,GAAAL,GACE,GAAAM,EAAAC,eAAAP,GAAuC,MAAAM,GAAAH,gBAAAC,WAAAJ,GDMzC,IAAAQ,GAAAhB,IAAAiB,cACAC,EAAA,EAAAF,EAAAR,IAAAS,aCHE,OC5BFN,iBAAAQ,YAAAL,EAAAN,EAAAU,GD4BEA,EAIF,QAAAE,GAAAC,EAAAC,EAAAC,EAAAC,GAGE,MAFAD,GAAAC,EAAAD,EAAAE,KAAAD,GAAAD,EACAF,EAAAK,iBAAAJ,EAAAC,GACAA,EAIF,QAAAI,GAAAN,EAAAC,EAAAC,EAAAC,GACED,EAAAC,EAAAD,EAAAE,KAAAD,GAAAD,CDEF,IAAAK,GAAA,QAAAC,GAAAC,GCAIT,EAAAU,oBAAAT,EAAAO,GACAN,EAAAO,GAGF,OADAT,GAAAK,iBAAAJ,EAAAM,GACAA,EAIF,QAAAI,GAAAX,EAAAC,EAAAC,EAAAC,GACED,EAAAC,EAAAD,EAAAE,KAAAD,GAAAD,CDAF,IAAAK,GAAA,QAAAK,GAAAH,GCEIP,EAAAO,IACET,EAAAU,oBAAAT,EAAAW,GAGJ,OADAZ,GAAAK,iBAAAJ,EAAAM,GACAA,EAIF,QAAAM,GAAAb,EAAAC,EAAAC,GACEF,EAAAU,oBAAAT,EAAAC,GE9DE,GFCAtB,GAAA,KAoBAa,IA4CJxC,GAAAD,SACE+C,KAAQO,OAAYK,QAAcE,MAAUrB,iBNgGxC,SAASvC,EAAQD,EAASH,GSlKhC,GAAAiE,GAAAjE,EAAA,GAEAG,GAAAC,EAAAD,QAAA,GAAA8D,GAAAC,aAEA/D,EAAAgE,SAAA,WACA,GAAAC,GAAA,mBAAA1D,SACAA,OAAA2D,aACAC,EAAA,mBAAA5D,SACAA,OAAA6D,aAAA7D,OAAA8C,gBAGA,IAAAY,EACA,gBAAAI,GAA6B,MAAA9D,QAAA2D,aAAAG,GAG7B,IAAAF,EAAA,CACA,GAAAG,KAWA,OAVA/D,QAAA8C,iBAAA,mBAAAkB,GACA,GAAAA,EAAAC,SAAAjE,QAAA,oBAAAgE,EAAAE,OACAF,EAAAG,kBACAJ,EAAAK,OAAA,IACA,GAAAC,GAAAN,EAAAO,OACAD,QAGS,GAET,SAAAA,GACAN,EAAAQ,KAAAF,GACArE,OAAA6D,YAAA,wBAIA,gBAAAQ,GACAG,WAAAH,EAAA,OAIA5E,EAAAgF,SAAAhF,EAAAiF,KACAjF,EAAAkF,SAAAlF,EAAAmF,MAAA,UACAnF,EAAAoF,IAAA,EACApF,EAAAqF,SAAA,EACArF,EAAAsF,OACAtF,EAAAuF,QAEAvF,EAAAwF,QAAA,SAAAC,GACA,aAAAA,EAAA,YACA,UAAAC,OAAA,8CAGA,WACA,GACAC,GADAC,EAAA,GAEA5F,GAAA4F,IAAA,WAA+B,MAAAA,IAC/B5F,EAAA6F,MAAA,SAAAC,GACAH,MAAA9F,EAAA,KACA+F,EAAAD,EAAAI,QAAAD,EAAAF,OAIA5F,EAAAgG,KAAAhG,EAAAiG,KACAjG,EAAAkG,MAAAlG,EAAAmG,OACAnG,EAAAoG,OAAApG,EAAAqG,YACArG,EAAAsG,WAAA,aACAtG,EAAAuG,aTyKM,SAAStG,EAAQD,EAASH,GUzOhC,YCKA,SAAA2G,GAAAC,GDAA,GAAAC,MCCkBC,EAAAF,EAAA9B,MDElB,KACA,KAAAzC,QACK,MAAA0E,GAEL,IADAA,EAAA,EACYD,EAAAC,ECLUA,IDMtB,IACA,KAAA1E,QACS,MAAA2E,GACTA,EAAAD,CACA,KCTIF,EAAA5B,KAAA2B,EAAAnE,gBAAAC,WAAAsE,KAAmB,QDYvBD,EAAAC,ICVE,MAAAH,GAGF,QAAAjG,GAAAqG,EAAAC,GAgBE,QAAAC,GAAAC,GACE,MAAAC,GAAAC,QAAAF,GDDJ,GAAAG,GAAAC,KACAH,EAAAV,EAAAM,EAAAQ,iBAAA,WCdED,MAAAE,aAAA,KAEAL,EAAAM,QAAA,SAAAP,GDeF,GAAAQ,GAAAjB,EAAAS,EAAAS,YACAZ,EAAAnG,SAAAO,cAAA,MCbI4F,GAAAa,UAAAC,IAAA,kBACAH,EAAAD,QAAA,SAAAK,GACEZ,EAAAvF,YAAAmG,GACAf,EAAAxF,YAAAuG,KAEFZ,EAAA3F,YAAAwF,KAOFO,KAAAS,gBAAA,SAAAb,GACEA,EAAAU,UAAAI,SAAA,aACEd,EAAAU,UAAAC,IAAA,OACAX,EAAAU,UAAAK,OAAA,YDcNZ,EAAAG,aAAA,MCTEF,KAAAY,cAAA,SAAAhB,GACEA,EAAAU,UAAAI,SAAA,SDYJX,EAAAc,eAAAjB,GCVMA,EAAAU,UAAAK,OAAA,QAEF,OAAAZ,EAAAG,cDYJH,EAAAU,gBAAAZ,EAAA5E,gBAAAC,WAAA6E,EAAAG,gBACAH,EAAAG,aAAAP,EAAAC,GACAG,EAAAe,gBAAAlB,GCTIA,EAAAU,UAAAC,IAAA,WACAX,EAAAU,UAAAC,IAAA,MACArH,OAAA6H,SAAAC,KAAA,GAAAjB,EAAAG,cAGFF,KAAAiB,UAAA,WDUF,GAAAA,GAAA,OAAAlB,EAAAG,aAAAH,EAAAG,aAAA,GCRIe,IAAApB,EAAAvC,SAAgC2D,EAAApB,EAAAvC,OAAA,GAChC2D,IAAAlB,EAAAG,cDWJH,EAAAa,cAAAf,EAAA5E,gBAAAC,WAAA+F,MCREjB,KAAAkB,cAAA,WDWF,GAAAC,GAAA,OAAApB,EAAAG,aAAAH,EAAAG,aAAA,GCTI,GAAAiB,IAAmBA,EAAA,GACnBA,IAAApB,EAAAG,cDYJH,EAAAa,cAAAf,EAAA5E,gBAAAC,WAAAiG,MCTEnB,KAAAoB,YAAA,SAAAxB,GDYF,GCTmByB,GDSnBC,EAAA1B,EAAA2B,QCVQC,EAAA/B,EAAA8B,QDYRE,IAEA,KAAAJ,IAAA3B,GCXM,GAAAA,EAAArE,eAAAgG,GDaN,IACA,KAAAxG,QACS,MAAA6G,GACTA,EAAAJ,EAAAjG,eAAAgG,GAAAC,EAAArG,gBAAAC,WAAAmG,IAAAG,EAAAnG,eAAAgG,GAAAG,EAAAvG,gBAAAC,WAAAmG,IAAA,KCbQK,GAASD,EAAAhE,KAAA,IAAAiC,EAAAzE,gBAAAC,WAAAmG,KAAAzB,EAAA8B,IAGb9B,EAAA+B,cAAAF,GAGFzB,KAAAc,gBAAA,SAAAlB,GACEA,EAAA+B,cAAAxB,QAAA,SAAAkB,GDgBJ,MAAAA,GAAAO,UAAAP,EAAAO,cCbE5B,KAAA6B,iBAAA,SAAAjC,GACEA,EAAA+B,cAAAxB,QAAA,SAAAkB,GDiBJ,MAAAA,GAAAS,WAAAT,EAAAS,eCdE9B,KAAAa,eAAA,SAAAjB,GACEA,EAAA+B,cAAAxB,QAAA,SAAAkB,GDkBJ,MAAAA,GAAAU,SAAAV,EAAAU,aCfE/B,KAAAgC,cAAA,SAAAC,GDmBF,GAAArC,GAAAqC,EAAAC,MCjBItC,GAAAU,UAAAI,SAAA,QACEd,EAAAU,UAAAK,OAAA,ODmBNZ,EAAAc,eAAAjB,IClB0BA,EAAAU,UAAAI,SAAA,QAEpBd,EAAAU,UAAAK,OAAA,MDmBNZ,EAAA8B,iBAAAjC,KCdEC,EAAAM,QAAA,SAAAP,GDkBF,MAAAG,GAAAqB,YAAAxB,IClB8C7D,KAAAiE,OAE5CvD,EAAAf,GAAA+D,EAAAhD,EAAAtB,aAAA,iBAAA6E,KAAAgC,cAAAhC,MAEAA,KAAAjE,KAAA,SAAAoC,EAAAgE,GACEC,EAAArG,KAAAoC,EAAAgE,EAAApG,KAAAgE,KAGFC,KAAAjE,MAAA,iBAAAiE,KAAAkB,eACAlB,KAAAjE,MAAA,4BAAAiE,KAAAiB,WAEAvD,WAAA,WDgBF,GAAA1C,GAAA,WAAAqH,KAAAnJ,OAAA6H,SAAAC,KCdIhG,GDgBJ+E,EAAAa,cAAAf,EAAA5E,gBAAAC,WAAAoH,SAAAtH,EAAAC,gBAAAC,WAAA,WAEA6E,EAAAkB,aCfoB,GHzHhB,GGEAxE,GAAAjE,EAAA,GACA4J,EAAA5J,EAAA,GA4HJI,GAAAD,QAAAS,GX6PM,SAASR,GY5Xf,YCAA,SAAA2J,GAAAC,GACE,MAAAA,GAAAC,MAAA,MAAAC,OAAA,SAAAC,EAAAC,GACE,OAAAA,EAAAC,OAAAvF,OAA8B,MAAAqF,EAC1B,IAAAG,GAAAF,EAAAtF,OAAAsF,EAAAG,WAAAzF,MACJ,eAAAqF,EAAAG,EAAAE,KAAAL,MAAAG,IAA6C,MAIjD,QAAAG,GAAAT,GACM,GAAAM,GAAAP,EAAAC,EACJ,OAAAA,GAAAC,MAAA,MAAAS,IAAA,SAAAN,GACE,MAAAA,GAAAO,MAAAL,GAAAM,cAAmCC,KAAA,MAIvC,QAAAC,GAAAd,GAEE,IADAA,EAAAS,EAAAT,GACA,OAAAA,EAAAvH,gBAAAC,WAAA,KAAyBsH,IAAAW,MAAA,EACzB,aAAAX,EAAAvH,gBAAAC,WAAAsH,EAAAlF,OAAA,KAAqCkF,IAAAW,MAAA,EAAAX,EAAAlF,OAAA,EACrC,OAAAkF,GAAA,KAGF5J,EAAAD,SAAmB2K,cbqYb,SAAS1K,EAAQD,EAASH,Gc3ZhC,YCIA,SAAA+K,GAAA3D,EAAA4D,GDAA,GAAAzD,GAAAC,KACAyD,EAAAnK,SAAAO,cAAA,MCEE4J,GAAAC,IAAAF,EAIAxD,KAAA4B,SAAA,WACE7B,EAAAtG,YDHJsG,EAAAtG,WAAAkK,WAAAtJ,YAAA0F,EAAAtG,YACAsG,EAAAtG,WAAAH,SAAAO,cAAA,OACAkG,EAAAtG,WAAA6G,UAAAC,IAAA,cACAR,EAAAtG,WAAAmB,MAAAgJ,gBAAA,OAAAJ,EAAA,ICII5D,EAAA+D,WAAA1J,YAAA8F,EAAAtG,YACAiE,WAAA,WDFJqC,EAAAtG,WAAA6G,UAAAC,IAAA,WCGoCxE,KAAAgE,GAAA,IAMlCC,KAAA+B,QAAA,WACEtF,EAAAR,KAAA8D,EAAAtG,WAAAgD,EAAAtB,aAAA,4BDLJ4E,EAAAtG,WAAAkK,WAAAtJ,YAAA0F,EAAAtG,YACAsG,EAAAtG,WAAA,MCMwBsG,GDJxBA,EAAAtG,WAAA6G,UAAAK,OAAA,WNvBI,GOEAlE,GAAAjE,EAAA,EAgCJI,GAAAD,QAAA4K,Gf0ZM,SAAS3K,EAAQD,EAASH,GgB5bhC,YCuBA,SAAAqL,GAAAjE,EAAAkE,GDDA,GAAA/D,GAAAC,KACA+D,EAAAnE,EAAA2B,QACAW,EAAAtC,EAAAoE,cAAA,mBACAC,EAAA/B,EAAAgC,UACAC,IT1BAlJ,iBAAAQ,YAAA0I,EAAA,wBUgCIC,QAAAC,IAAAC,WACAtE,KAAAuE,MAAWC,IAAA,gBAAKzI,KAAAiE,OVjCpB/E,gBAAAQ,YAAA0I,EAAA,SAAAM,EAAA7F,MAAA3D,gBAAAQ,YAAA0I,EAAA,SAAAM,EAAAC,MUqCEP,EAAAQ,IAAA,SAAAC,GDHF,MAAAA,GAAAC,WAAAD,EAAAE,SAAAC,YAAAnC,OTlCA3H,gBAAAQ,YAAA0I,EAAA,mBAAAS,GSqCA,MAAAI,GAAAC,SAAAL,KCEET,EAAAe,IAAA,WDCF,GAAAC,GAAA7L,SAAAO,cAAA,QCEIsL,GAAAC,aAAA,eACA9L,SAAAoB,KAAAT,YAAAkL,GACAA,EAAAE,QACAF,EAAAxB,WAAAtJ,YAAA8K,GDCJ,IAAAG,ICKIC,MAAA/C,EAAAc,UAAAW,GACAH,OACA0B,UAAArB,EACAsB,cAAA,EACAC,eAAA,EACAC,mBAAA,EACAC,iBAAA,EACAC,MAAA,WAGF7F,MAAAuE,KAAA,SAAAuB,GDJF/F,EAAAgG,YAAAC,cAAAjJ,YAAAkJ,KAAAC,UAAAJ,GAAA,MCUE9F,KAAA4B,SAAA,WACEhC,EAAAU,UAAAC,IAAA,UACA2B,EAAAgC,UAAA,GDPJnE,EAAAoG,YAAA7M,SAAAO,cAAA,OACAkG,EAAAoG,YAAA7F,UAAAC,IAAA,eCUI2B,EAAAjI,YAAA8F,EAAAoG,aDRJpG,EAAAqG,gBAAA9M,SAAAO,cAAA,OACAkG,EAAAqG,gBAAA9F,UAAAC,IAAA,eACAR,EAAAgG,YAAAzM,SAAAO,cAAA,UACAkG,EAAAsG,YAAA/M,SAAAO,cAAA,OACAkG,EAAAsG,YAAA/F,UAAAC,IAAA,eACAR,EAAAqG,gBAAAnM,YAAA8F,EAAAsG,aCaInE,EAAAjI,YAAA8F,EAAAqG,gBDXJ,IAAAE,GAAAtD,KAAAL,IAAA5C,EAAAsG,YAAAE,YAAAxG,EAAAsG,YAAAG,cAAA,KACAzG,GAAA0G,QAAA,GAAAC,ICeMC,MAAA,QACAC,QAAA,EACAC,SAAA,EACAvJ,OAAA,EAAAgJ,EACAQ,OAAA,EAAAR,EACAS,MAAAT,EACAU,MAAA,GACAC,MAAA,KAAOC,KAAAnH,EAAAsG,aDZbtG,EAAA6E,GAAAI,EAAAjF,EAAAoG,YAAAb,GACAvF,EAAA6E,GAAAuC,QAAA,gBCoBEnH,KAAA8B,UAAA,WDjBF/B,EAAAgG,YAAAnL,MAAAwM,QAAA,OACArH,EAAAgG,YAAAX,aAAA,MAAArB,EAAAsD,MACAtH,EAAAqG,gBAAAnM,YAAA8F,EAAAgG,aCmBItJ,EAAAH,MAAAyD,EAAAgG,YAAAC,cAAA,mBAAA/D,GACE,kBAAAA,EAAA7E,MACE4C,KAAAyG,QAAAa,OACAtH,KAAA+F,YAAAnL,MAAAwM,QAAA,GACApH,KAAAoG,gBAAA/L,YAAA2F,KAAAqG,aACArG,KAAAqG,YAAArG,KAAAyG,QAAA,MACA,GALF,QAKS1G,GDffA,EAAA6E,GAAA2C,WCuBEvH,KAAA+B,QAAA,WDpBFhC,EAAA6E,GAAA,KCsBI1C,EAAAgC,UAAAD,EACA/B,EAAA5B,UAAAK,OAAA,WA7HJnI,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IAEAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,IACAA,EAAA,GDEA,IAAAwM,GAAA9L,OAAA8L,WCEIvI,EAAAjE,EAAA,GACAgK,EAAAhK,EAAA,GACAiM,EAAAjM,EAAA,GACAkO,EAAAlO,EAAA,GA6GJI,GAAAD,QAAAkL,GjB4aM,SAASjL,GkB9iBf,YCIA,SAAA4O,GAAAC,GACEC,EAAAjK,KAAAgK,GACAC,EAAApK,OAAA,IAA0BoK,EAAAlK,QAE5B,QAAAmK,GAAAF,GDCA,GAAA1H,ECAE,OAAA2H,GAAApK,QDGFyC,EAAA2H,EAAApK,OAAA,MAAArC,iBAAAQ,YAAAiM,EAAA3H,EAAA2H,EAAAzM,gBAAAC,WAAA6E,IAAA0H,ICHwBD,EAAAC,GAGxB,QAAAG,GAAAC,GAA0B,MAAAH,GAAAzM,gBAAAC,WAAAwM,EAAApK,QAAAuK,EAAA7E,KAAAL,IAAAkF,EAAA,YAK1B,QAAAC,GAAAC,EAAAC,GAAuB,MAAAD,GAAAnF,MAAAoF,EAAApF,MAAAmF,EAAAE,IAAAD,EAAAC,GAEvB,QAAArJ,GAAAgG,EAAAsD,EAAAC,EAAAC,EAAA5F,GACE,MAAAA,IAAkBA,EAAAoC,EAAAyD,SAAAH,EAAAC,IAElBC,GAAAE,KAAA1D,OAAAkD,EAAAI,EAAAI,EAAAC,MAAA3D,EAAA4D,QAAAF,EAAAG,KACEd,EAAAnF,GAEAgF,EAAAhF,GACFoC,EAAA8D,aAAA,GAAAR,EAAAC,EAAA,WAEaG,EAAbF,GAAyBxD,KAAQ2D,IAAAL,EAAWO,IAAA7D,EAAA+D,oBACvC,KAGP,QAAArO,GAAAsK,EAAAgE,GACM,GAAAC,GAAAjE,EAAAkE,MAAAC,WACJ,OAAAF,IACAG,EAAApE,GACA,KAAAiE,EAAA,GAAAI,OAAAJ,IAFaD,EAAA,OAOf,QAAAM,GAAAtE,EAAAlD,GACEkD,EAAAkE,MAAAK,gBAAAC,EAAA/N,eAAAqG,IACEsH,EAAApE,GAGJ,QAAAoE,GAAApE,GACEA,EAAAkE,MAAAC,YAAA,KACAnE,EAAApI,IAAA,aAAA0M,GACAtE,EAAApI,IAAA,YAAA6M,GAGF,QAAAA,GAAAzE,EAAAxI,GACM,GAAAkN,GAAAhP,EAAAsK,EACJ,IAAA0E,EAAA,aAAAlN,EAAAmN,OAAA,CAEE,OADIC,GAAApN,EAAAoG,KAAAa,KAAA,MAA6BoG,EAAA,GACjCjK,EAAA,EAAa8J,EAAA9J,IAAOA,EAAUiK,GAAAD,CAC9B5E,GAAA8E,iBAAAD,EAAA,iBAIJ,QAAAE,GAAAC,GACM,GAAA5M,GAAA,8BAAA4M,GAAA,YAAA3O,gBAAA4O,OAAAD,IAAA,SAAAhF,GAA4CA,EAAAkF,YAAAF,IAAeA,CAC/D,iBAAAhF,GACM,GAAAmF,GAAAzP,EAAAsK,EACJ5H,GAAA4H,EACA,QAAApF,GAAA,EAAauK,EAAAvK,IAAOA,EAAaxC,EAAA4H,IXlEjC,GWGA8C,MAYAY,EAAA,KAwBAc,GAAwBY,SAAA,EAAeC,UAAA,EAAgBC,UAAA,EAAgBC,UAAA,GD+C3EC,EAAAT,EAAA,SAAA/E,GCfM,GAAAyF,GAAAzF,EAAAG,YAAwBuF,EAAA1F,EAAA2F,QAAAvF,WAAAwF,IAAAH,EAAAzH,OACxBJ,EAAAoC,EAAAyD,SAAAgC,EAAAC,EACJ,MAAAvP,KAAAyH,KACEA,GAAA,KACA8H,EAAAtF,WAAAwF,IAAAH,EAAAzH,KAAA,MAEFhE,EAAAgG,EAAAyF,EAAAC,GAAA,EAAA9H,KDmBFiI,EAAA,SAAA7F,GCfM,GAAAyF,GAAAzF,EAAAG,WACJH,GAAA8D,aAAAd,EAAAtN,EAAAsK,IAAAyF,IAAA,SACAzF,EAAA8F,aAAAL,EAAAzF,EAAAG,aAGFnM,GAAAD,SACEiG,KAAAwL,EACA1F,KAAA+F,InBqkBI,SAAS7R,GoB7pBf,YCAA,SAAA+R,GAAA/K,EAAA4D,GAEE5D,EAAAhF,MAAAgJ,gBAAA,OAAAJ,EAAA,IAIF5K,EAAAD,QAAAgS,GrBmqBM,YsBzqBN,WAoBA,QAAAC,GAAAhG,EAAA2D,GACA,GAAAd,GAAA7C,EAAAyD,SAAArD,WAAAwF,IAAAjC,EAAA3F,KAAA2F,EAAAN,GAAA,GACAjD,WAAAwF,IAAAjC,EAAA3F,KAAA2F,EAAAN,GAAA,GACA,WAAAR,EAAAnK,OAAAmK,EAAA,KAGA,QAAAoD,GAAAC,GAaA,OAZA5H,IACA9E,KAAA,oBACA2M,UAAA,SAAAnG,GACA,GAAAA,EAAAoG,qBAAApG,EAAAqG,UAAA,sBAAAjG,YAAAkG,IACA,IAAAC,GAAAvG,EAAAG,YAAAqG,EAAAR,EAAAhG,EAAAuG,EACA,OAAAC,IAAAN,EAAAhL,QAAAsL,GAAA,SACAxG,GAAA8D,aAAA,GAAA1D,WAAAwF,IAAAW,EAAAvI,KAAAuI,EAAAlD,GAAA,GAAAjD,WAAAwF,IAAAW,EAAAvI,KAAAuI,EAAAlD,GAAA,IAEAjD,WAAAkG,OAGAG,EAAA,GACA7L,EAAA,EAAmBA,EAAAsL,EAAAxN,OAAkBkC,GAAA,YAAA8L,EAAAC,GAErC,QAAAC,GAAA5G,GACA,GAAA6G,GAAA7G,EAAA8G,cACA9G,GAAA8E,iBAAA4B,EAAAG,EAAAF,GAEA,QAAAI,GAAA/G,GACA,GAAAuG,GAAAvG,EAAAG,YAAA6G,EAAAhH,EAAAyD,SAAA8C,EAAAnG,WAAAwF,IAAAW,EAAAvI,KAAAuI,EAAAlD,GAAA,GACA,OAAA2D,IAAAL,GAAA3G,EAAAoG,oBAAAhG,WAAAkG,SACAtG,GAAAkF,YAAA,eARAwB,GAAAC,IAAAF,GAAAE,GAUArI,EAAA,IAAAoI,EAAA,cAAA1G,GACA,QAAA0G,GAAA,WAAA1G,EAAAiH,WAAAjH,EAAAG,aAAAjL,MACA8K,EAAAqG,UAAA,gBACA,MAAAjG,YAAAkG,IACA,IAAAtG,EAAAoG,oBAAA,MAAAQ,GAAA5G,EACA,IAAA0G,GAAAC,GAAAI,EAAA/G,IAAAI,WAAAkG,KAAA,CACA,GAAAC,GAAAvG,EAAAG,YAAA6G,EAAA5G,WAAAwF,IAAAW,EAAAvI,KAAAuI,EAAAlD,GAAA,GACArF,EAAAgC,EAAAkH,QAAAX,EAAAvI,MAAAmJ,EAAAnJ,EAAAoJ,OAAAb,EAAAlD,IAAAgE,EAAAd,EAAAlD,GAAA,EAAArF,EAAAoJ,OAAAb,EAAAlD,GAAA,KACA,OAAAqD,IAAAC,GAAAvG,WAAAkH,WAAAD,GACAjH,WAAAkG,KACAtI,EAAAtF,QAAA6N,EAAAlD,IAAAoD,EAAAvL,QAAAiM,IAAA,GAAAI,EAAApR,KAAAgR,OACAnH,GAAA8E,iBAAA4B,EAAAC,GAA6CpR,KAAAyR,EAAAQ,OAAAR,IAE7C5G,WAAAkG,OAEAI,GAAAC,IAAArI,EAAA,IAAAqI,EAAA,KAAAI,KACKb,EAAAkB,OAAAxM,GAAAsL,EAAAkB,OAAAxM,EAAA,GACL,OAAA0D,GAGA,QAAAmJ,GAAAvB,GACA,gBAAAlG,GACA,GAAAuG,GAAAvG,EAAAG,YAAAqG,EAAAR,EAAAhG,EAAAuG,EACA,QAAAC,GAAAN,EAAAhL,QAAAsL,GAAA,MAAAxG,EAAAqG,UAAA,gBACAjG,WAAAkG,SACAtG,GAAA0H,UAAA,WACA,GAAAC,GAAAvH,WAAAwF,IAAAW,EAAAvI,KAAA,IACAgC,GAAA8E,iBAAA,QAAqC0C,OAAAG,EAAApS,KAAAoS,GAA6B,UAClE3H,EAAAC,WAAAsG,EAAAvI,KAAA,WACAgC,EAAAC,WAAAsG,EAAAvI,KAAA,cA9EA,GAAA4J,GAAA,eACAC,EAAA,OACAN,EAAA,IAEAnH,YAAA0H,aAAA,gCAAA9H,EAAA+H,EAAAC,GAGA,GAFAA,GAAA5H,WAAA6H,MAAAD,GACAhI,EAAAkI,aAAA,qBACAH,EAAA,CACA,GAAA7B,GAAA0B,EAAAO,EAAAN,CACA,iBAAAE,GAAA7B,EAAA6B,EACA,gBAAAA,KACA,MAAAA,EAAA7B,UAAA6B,EAAA7B,OACA,MAAA6B,EAAAI,YAAAJ,EAAAI,SAEA,IAAA7J,GAAA2H,EAAAC,EACAiC,KAAA7J,EAAA8J,MAAAX,EAAAU,IACAnI,EAAAqI,UAAA/J,UtBkvBM,YuBnwBN,WAOA,QAAAgK,GAAAtI,EAAAuI,EAAAC,GAaA,QAAAC,GAAAzK,EAAA0K,EAAAjD,GACA,GAAAzH,EAAAJ,KAAA,CACA,GAAA+F,GAAAgF,EAAA,EAAA3K,EAAAJ,KAAAlF,OAAA,EAAAgN,EAAAiD,EAAA3K,EAAAJ,KAAAlF,OAAA,EACA,IAAAsF,EAAAJ,KAAAlF,OAAAkQ,EAAA,WAEA,KADA,MAAAnD,IAAA9B,EAAA8B,EAAAoD,GACYlF,GAAA+B,EAAY/B,GAAAkF,EAAA,CACxB,GAAAxF,GAAArF,EAAAJ,KAAAwJ,OAAAzD,EACA,IAAAmF,EAAA3S,KAAAkN,IAAArD,EAAA+I,eAAAnD,EAAA8C,EAAA/E,EAAA,KAAA3N,EAAA,CACA,GAAAI,GAAA4S,EAAA3F,EACA,SAAAjN,EAAAgR,OAAA,IAAAuB,EAAAM,EAAApQ,KAAAwK,OACA,IAAA4F,EAAAC,OAAA9S,EAAAgR,OAAA,UAA2DzD,MAAAvN,OAAA,EAC3D,KAAA6S,EAAAvQ,OAAA,OAA0CiL,MAAAvN,OAAA,OAvB1C,GAAA8N,GAAAlE,EAAAkE,MAAApD,cACA8H,EAAA1E,KAAAiF,mBAAA,IACAC,EAAAlF,KAAAkF,cAAA,IAEA7C,EAAAgC,GAAAvI,EAAAG,YAAAnC,EAAAgC,EAAAqJ,cAAA9C,EAAAvI,MAAA2F,EAAA4C,EAAAlD,GAAA,EACAjN,EAAAuN,GAAA,GAAAqF,EAAAhL,EAAAJ,KAAAwJ,OAAAzD,KAAAqF,EAAAhL,EAAAJ,KAAAwJ,SAAAzD,GACA,KAAAvN,EAAA,WACA,IAAAuS,GAAA,KAAAvS,EAAAgR,OAAA,GAAAyB,EAAAF,EAAA,IACA,IAAAH,GAAAG,IAAAhF,GAAA4C,EAAAlD,IAAA,WAmBA,QAAAiG,GAlBAtT,EAAAgK,EAAA+I,eAAAnD,EAAAW,EAAAvI,KAAA2F,EAAA,IAEAsF,GAAAjL,EAAAJ,KAAAwJ,OAAAzD,IAAAmF,EAAA,YAgBAlO,EAAA2L,EAAAvI,KAAAX,EAAAsL,EAAAvK,KAAAL,IAAAnD,EAAAwO,EAAApJ,EAAAuJ,aAAAnL,KAAAoL,IAAA,GAAA5O,EAAAwO,GAA4HxO,GAAAyC,KAC5HiM,EAAA1O,GAAA2L,EAAAvI,KAAAyK,EAAAzK,EAAApD,EAAA+I,GACA8E,EAAAzI,EAAAqJ,cAAAzO,OAFoIA,GAAAiO,GAKpI,OAAYvF,KAAAsC,EAAAW,EAAAvI,KAAA2F,GAAAJ,GAAA+F,GAAA1D,EAAAhL,EAAA0O,EAAA3F,KACZvN,MAAAkT,KAAAlT,MAAAuS,WAGA,QAAA7H,GAAAd,EAAAyJ,GAEA,GAAAC,GAAA1J,EAAAkE,MAAApD,cAAA6I,wBAAA,IACAL,EAAAhB,EAAAtI,EACA,OAAAsJ,GAAAtJ,EAAAkH,QAAAoC,EAAAhG,KAAAtF,MAAAtF,OAAAgR,GACAJ,EAAA/F,IAAAvD,EAAAkH,QAAAoC,EAAA/F,GAAAvF,MAAAtF,OAAAgR,GADA,CAIA,GAAA1T,GAAAsT,EAAAlT,MAAA,6DACAwO,EAAA5E,EAAA4J,SAAAN,EAAAhG,KAAAsC,EAAA0D,EAAAhG,KAAAtF,KAAAsL,EAAAhG,KAAAD,GAAA,IAAgFwG,UAAA7T,IAChF8T,EAAAR,EAAA/F,IAAAvD,EAAA4J,SAAAN,EAAA/F,GAAAqC,EAAA0D,EAAA/F,GAAAvF,KAAAsL,EAAA/F,GAAAF,GAAA,IAAsFwG,UAAA7T,GAGtF+T,IAAA/J,EAAAkE,MAAA8F,SAAAhK,EAAAwC,QAAAjC,MAAAE,OACA,IAAAwJ,GAAA,WACAjK,EAAA0H,UAAA,WAA+B9C,EAAAqF,QAAaH,KAAAG,UAE5C,OAAAR,OAAA3Q,YAAAmR,EAAA,KACAA,GAIA,QAAAC,GAAAlK,GACAA,EAAA0H,UAAA,WACAyC,IAAiCA,IAAuBA,EAAA,MACxDnK,EAAAoG,sBAAA+D,EAAArJ,EAAAd,GAAA,MApEA,GAAA+J,GAAA,UAAA5T,KAAAiU,UAAAC,aACA,MAAA3V,SAAA4V,cAAA5V,SAAA4V,aAAA,GAEA1E,EAAAxF,WAAAwF,IAEAoD,GAAkBuB,IAAA,KAAAC,IAAA,KAAAC,IAAA,KAAAC,IAAA,KAAAC,IAA8C,KAAKC,IAAM,MA2D3ET,EAAA,IAQA/J,YAAA0H,aAAA,4BAAA9H,EAAA+H,EAAAC,GACAA,MAAA5H,WAAA6H,MACAjI,EAAApI,IAAA,iBAAAsS,GACAnC,IACA/H,EAAAkE,MAAApD,cAAA,gBAAAiH,QACA/H,EAAAlJ,GAAA,iBAAAoT,MAIA9J,WAAAyK,gBAAA,2BAA0D/J,EAAA1F,MAAA,KAC1DgF,WAAAyK,gBAAA,+BAAAlH,EAAA6E,GACA,MAAAF,GAAAlN,KAAAuI,EAAA6E,SvB4wBM,YwBh2BN,WACA,YAEA,IAAAsC,GAAA,SAAAC,EAAA,GAEA3K,YAAA4K,eAAA,0BAAApW,EAAA8L,GAKA,IAJA,GAAAuK,GAAAvK,KAAAuK,MAAAH,EACAI,EAAAxK,KAAAwK,OAAAH,EACAxE,EAAA3R,EAAAuL,YAAAgL,EAAAvW,EAAAsS,QAAAX,EAAAvI,MACAyH,EAAAc,EAAAlD,GAAAqC,EAAAD,EACAC,EAAAyF,EAAAzS,QAAAuS,EAAA9U,KAAAgV,EAAA/D,OAAA1B,QACA,MAAAD,GAAAwF,EAAA9U,KAAAgV,EAAA/D,OAAA3B,EAAA,OAAAA,CAKA,QAJA2F,GAAA3F,GAAAC,GAAAyF,EAAA5M,MAAAkH,EAAAC,GAEA2F,KAAAC,KACAxC,EAAA,GAAAyC,QAAAN,EAAA1S,OAAA,KACAsB,EAAA,GAAsB,GAAAA,EAAUA,GAAA,EAEhC,IADA,GAAAmE,GAAAuI,EAAAvI,KAAAwN,EAAApN,KAAAL,IAAAK,KAAAoL,IAAAxL,EAAAnE,EAAAqR,EAAAtW,EAAA6W,aAAA7W,EAAA8W,YAAA7R,EACYmE,GAAAwN,EAAiBxN,GAAAnE,EAE7B,IADA,GAAA8R,GAAA/N,EAAAhJ,EAAAsS,QAAAlJ,GACA2N,EAAA7C,EAAArL,KAAAG,KACAI,GAAAuI,EAAAvI,MAAA2N,EAAA,KAAAP,KACAA,GAAA,GAAAO,EAAA,GAAAC,YAAAR,EAAA,IAAAS,OAAAC,UAAArV,eAAAtC,KAAAmX,EAAAK,EAAA,MACAL,EAAAK,EAAA,OACAN,EAAAxS,KAAA8S,EAAA,KAKA,QAAYN,OAAA/H,KAAAlD,WAAAwF,IAAAW,EAAAvI,KAAAyH,GAAAlC,GAAAnD,WAAAwF,IAAAW,EAAAvI,KAAA0H,UxBy2BN,YyBt4BN,WAGA,QAAAnK,GAAAwQ,EAAA3T,GACA,OAAAwC,GAAA,EAAAyC,EAAA0O,EAAArT,OAAmC2E,EAAAzC,IAAOA,EAAAxC,EAAA2T,EAAAnR,IAG1C,QAAAoR,GAAAD,EAAAE,GACA,IAAAC,MAAAJ,UAAA5Q,QAAA,CAEA,IADA,GAAAN,GAAAmR,EAAArT,OACAkC,KACA,GAAAmR,EAAAnR,KAAAqR,EACA,QAGA,UAEA,UAAAF,EAAA7Q,QAAA+Q,GAGA,QAAAE,GAAAvX,EAAAwX,EAAAC,EAAA3L,GAEA,GAAA6F,GAAA3R,EAAAuL,YAAAmM,EAAAD,EAAAzX,EAAA2R,GAAAgG,EAAAD,CACA,8BAAAnW,KAAAmW,EAAApX,MAAA,CASA,IARAoX,EAAApI,MAAA9D,WAAAoM,UAAA5X,EAAA6X,UAAAH,EAAApI,aAGA,YAAA/N,KAAAmW,EAAAI,UACAJ,EAAAC,GAAuB9G,MAAAc,EAAAlD,GAAAqC,IAAAa,EAAAlD,GAAAqJ,OAAA,GAAAxI,MAAAoI,EAAApI,MACvBhP,KAAA,KAAAoX,EAAAI,OAAA,kBAGA,YAAAH,EAAArX,MAAA,CAEA,GADAqX,EAAAF,EAAAzX,EAAAgR,EAAAW,EAAAvI,KAAAuO,EAAA9G,QACA,KAAA8G,EAAAG,OAAA,MAEA,IADAH,EAAAF,EAAAzX,EAAAgR,EAAAW,EAAAvI,KAAAuO,EAAA9G,SACAvO,EAAA,GAAAA,KACAA,GAAA2B,KAAA0T,GAEA,OAAYlB,KAAAsB,EAAAL,EAAApV,EAAAkV,EAAA1L,GACZ4C,KAAAsC,EAAAW,EAAAvI,KAAAsO,EAAA7G,OACAlC,GAAAqC,EAAAW,EAAAvI,KAAAsO,EAAA5G,OAGA,QAAAkH,GAAAhY,EAAA8L,GACA,MAAAyL,GAAAvX,EAAAiY,EACA,SAAAxP,EAAAkJ,GAAyC,MAAAlJ,GAAA4J,WAAAV,IACzC7F,GAKA,QAAAoM,GAAAlY,EAAA2R,GAIA,GAAA+F,GAAA1X,EAAAqS,WAAAV,EAWA,OAVAA,GAAAlD,IAAAiJ,EAAA7G,MAAA,QAAA6G,EAAAI,OAAAtF,OAAA,IACAkF,EAAA5G,IAAA4G,EAAA7G,MACA6G,EAAAI,OAAA,IACAJ,EAAApX,KAAA,YAEA,cAAAiB,KAAAmW,EAAAI,UACAJ,EAAApX,KAAA,WACAoX,EAAA7G,QACA6G,EAAAI,OAAAJ,EAAAI,OAAAK,QAAA,UAEAT,EAGA,QAAAU,GAAApY,EAAA8L,GACA,MAAAyL,GAAAvX,EAAAqY,EAAAH,EAAApM,GAeA,QAAAiM,GAAAL,EAAApV,EAAAkV,EAAA1L,GAEA,QAAAwM,GAAArK,GACA,GAAAA,EAAA+I,YAAAnG,EAAA,IAAAuG,EAAA1C,EAAAzG,IAAAyG,EAAAzQ,KAAAgK,GAEA,QAAAsK,GAAAC,GACA,gBAAAA,GAAA7R,EAAA8R,EAAAH,GACAE,YAAAlB,OAAA3Q,EAAA+R,EAAAJ,GACAE,YAAAG,WAAAhS,EAAAiS,EAAAN,EACA,QAAA1T,KAAA4T,GAAAF,EAAA1T,GARA,GAAA8P,MAAA7D,EAAA6G,EAAAI,MAWA,IAAAxV,KAAAwB,OAAA,CAGA,GAAA+U,GAAAL,EAAAlW,EAAAgS,KAgBA,KAfAkE,EAAAlY,MAAA,IAAAkY,EAAAlY,KAAAgG,QAAA,aACAwF,KAAAgN,oBACAD,EAAA/M,EAAAgN,kBAAAN,EAAAV,SACAe,KAAAnZ,OAAA8Y,EAAAV,SACO,UAAAU,EAAAlY,KACPuY,EAAA,GACO,QAAAL,EAAAlY,KACPuY,EAAA,EACO,YAAAL,EAAAlY,OACP,MAAAZ,OAAAqZ,QAAA,KAAAP,EAAAV,QAAA,UAAAU,EAAAV,QACA,kBAAApY,QAAAqZ,OAEA,MAAArZ,OAAAsZ,GAAA,KAAAR,EAAAV,QAAA,kBAAApY,QAAAsZ,IACAH,EAAAnZ,OAAAsZ,KAFAH,EAAAnZ,OAAAqZ,UAIA,MAAAF,GAAAvW,EAAAwB,QACA+U,IAAAvW,EAAAgS,MAAAwD,OACA,OAAAe,GAAAN,EAAAM,OACK,CAGL,OAAAI,GAAAvB,EAAApI,MAAA4J,UAAyCD,EAAGA,IAAAE,KAAAb,EAAAW,EAAArU,KAC5C,QAAAqU,GAAAvB,EAAApI,MAAA8J,WAA0CH,EAAGA,IAAAE,KAAAb,EAAAW,EAAArU,KAC7C2T,GAAA7Y,QACAiH,EAAA6Q,EAAAc,GAEA,MAAA5D,GA/HA,GAAA1D,GAAAxF,WAAAwF,GAgDAxF,YAAAwM,iBACAxM,WAAA4K,eAAA,oBAAA4B,GAuBAxM,WAAA4M,mBACA5M,WAAA4K,eAAA,sBAAAgC,EAEA,IAAAK,GAAA,iJACAxP,MAAA,KACAyP,EAAA,4IACAzP,MAAA,KACA2P,EAAA,4BAAA3P,MAAA,KACAgP,EAAA,yKACAhP,MAAA,KACAoP,EAAA,gMACApP,MAAA,SzB27BM,Y0B/gCN,WACA,YAuBA,SAAAoQ,GAAAjO,EAAAkO,EAAAxN,GACAtF,KAAA4E,KACA5E,KAAA8S,WACA9S,KAAAsF,UACAtF,KAAA+S,OAAA/S,KAAAgT,QAAA,KA8FA,QAAAC,GAAAC,GACA,sBAAAA,KACAA,EAAA1Q,KAGA,QAAA2Q,GAAA7N,EAAA8N,GAaA,QAAAC,GAAA7O,EAAAmI,GACA,GAAA2G,EAEAA,GADA,gBAAA3G,GACA,SAAA/H,GAA8B,MAAA+H,GAAA/H,EAAAwO,IAE9BG,EAAAlY,eAAAsR,GACA4G,EAAA5G,GAEAA,EACA6G,EAAAhP,GAAA8O,EArBA,GAAAC,IACAE,GAAA,WAAsBL,EAAAM,UAAA,KACtBC,KAAA,WAAwBP,EAAAM,UAAA,IACxBE,OAAA,WAA0BR,EAAAM,WAAAN,EAAAS,WAAA,OAC1BC,SAAA,WAA4BV,EAAAM,UAAAN,EAAAS,WAAA,OAC5BE,KAAA,WAAwBX,EAAAY,SAAA,IACxBC,IAAA,WAAuBb,EAAAY,SAAAZ,EAAA9V,OAAA,IACvB0P,MAAAoG,EAAAc,KACAvP,IAAAyO,EAAAc,KACAhP,IAAAkO,EAAAe,OAEAX,EAAAlO,EAAA8O,cAAwCb,CAYxC,IAAAjO,EAAA8O,WACA,OAAA5P,KAAAc,GAAA8O,WAAA9O,EAAA8O,WAAA/Y,eAAAmJ,IACA6O,EAAA7O,EAAAc,EAAA8O,WAAA5P,GACA,IAAAc,EAAAE,UACA,OAAAhB,KAAAc,GAAAE,UAAAF,EAAAE,UAAAnK,eAAAmJ,IACA6O,EAAA7O,EAAAc,EAAAE,UAAAhB,GACA,OAAAgP,GAGA,QAAAa,GAAAC,EAAAC,GACA,KAAAA,MAAAD,GAAA,CACA,UAAAC,EAAAC,SAAAC,eAAAF,EAAA5Q,YAAA2Q,EAAA,MAAAC,EACAA,KAAA5Q,YAIA,QAAA+Q,GAAAxB,EAAA9V,GACA4C,KAAAkT,aACAlT,KAAA5C,MACA,IAAA2V,GAAA/S,KAAA4E,EAAAsO,EAAAtO,GAAAU,EAAA4N,EAAA5N,QAEAqP,EAAA3U,KAAA2U,MAAArb,SAAAO,cAAA,KACA8a,GAAAlG,UAAA,mBACAzO,KAAA4U,aAAAtP,EAAAuP,oBAAAvP,EAAAuP,oBAAAjQ,EAAAU,EAAAlI,GAAA,CAGA,QADA0X,GAAA1X,EAAA6S,KACAzQ,EAAA,EAAmBA,EAAAsV,EAAAxX,SAAwBkC,EAAA,CAC3C,GAAAuV,GAAAJ,EAAA1a,YAAAX,SAAAO,cAAA,OAAAsR,EAAA2J,EAAAtV,GACAiP,EAAAuG,GAAAxV,GAAAQ,KAAA4U,aAAA,OAAAK,EACA,OAAA9J,EAAAsD,cAAAtD,EAAAsD,UAAA,IAAAA,GACAsG,EAAAtG,YACAtD,EAAA+J,OAAA/J,EAAA+J,OAAAH,EAAA3X,EAAA+N,GACA4J,EAAA9a,YAAAX,SAAAY,eAAAiR,EAAAgK,aAAAlC,EAAA9H,KACA4J,EAAAK,OAAA5V,EAGA,GAAA+I,GAAA3D,EAAAyQ,aAAA/P,EAAAgQ,iBAAA,EAAAlY,EAAA8K,KAAA,MACAoD,EAAA/C,EAAA+C,KAAAiK,EAAAhN,EAAAiN,OAAAC,GAAA,CACAd,GAAA/Z,MAAA0Q,OAAA,KACAqJ,EAAA/Z,MAAA2a,MAAA,IAEA,IAAAG,GAAAxc,OAAAyc,YAAA3S,KAAAoL,IAAA9U,SAAAoB,KAAAkb,YAAAtc,SAAAuc,gBAAAD,aACAE,EAAA5c,OAAA6c,aAAA/S,KAAAoL,IAAA9U,SAAAoB,KAAAsb,aAAA1c,SAAAuc,gBAAAG,eACA1Q,EAAA7F,WAAAnG,SAAAoB,MAAAT,YAAA0a,EACA,IAAAsB,GAAAtB,EAAAuB,wBAAAC,EAAAF,EAAAT,OAAAM,CACA,IAAAK,EAAA,GACA,GAAAC,GAAAH,EAAAT,OAAAS,EAAAV,IAAAc,EAAAJ,EAAAV,KAAAhN,EAAAiN,OAAAjN,EAAAgN,IACA,IAAAc,EAAAD,EAAA,EACAzB,EAAA/Z,MAAA2a,OAAAc,EAAAD,GAAA,KACAX,GAAA,MACO,IAAAW,EAAAN,EAAA,CACPnB,EAAA/Z,MAAAwb,OAAAN,EAAA,OACAnB,EAAA/Z,MAAA2a,OAAAhN,EAAAiN,OAAAS,EAAAV,KAAA,IACA,IAAAe,GAAA1R,EAAAG,WACA3H,GAAA8K,KAAAD,IAAAqO,EAAArO,KACAM,EAAA3D,EAAAyQ,aAAAiB,GACA3B,EAAA/Z,MAAA0Q,QAAA/C,EAAA+C,MAAA,KACA2K,EAAAtB,EAAAuB,0BAIA,GAAAK,GAAAN,EAAA3K,KAAAoK,CAmBA,IAlBAa,EAAA,IACAN,EAAA1K,MAAA0K,EAAA3K,KAAAoK,IACAf,EAAA/Z,MAAAmM,MAAA2O,EAAA,OACAa,GAAAN,EAAA1K,MAAA0K,EAAA3K,KAAAoK,GAEAf,EAAA/Z,MAAA0Q,QAAA/C,EAAA+C,KAAAiL,GAAA,MAGA3R,EAAAqI,UAAAjN,KAAAwW,OAAArD,EAAA7N,GACAoO,UAAA,SAAA7L,EAAA4O,GAAyC1D,EAAA2D,aAAA3D,EAAA6B,aAAA/M,EAAA4O,IACzCzC,SAAA,SAAAnM,GAA6BkL,EAAA2D,aAAA7O,IAC7BgM,SAAA,WAA4B,MAAAd,GAAA4D,gBAC5BrZ,OAAAwX,EAAAxX,OACA6W,MAAA,WAAyBjB,EAAAiB,SACzBD,KAAA,WAAwBnB,EAAAmB,QACxB9W,UAGAkI,EAAAsR,kBAAA,GACA,GAAAC,EACAjS,GAAAlJ,GAAA,OAAAsE,KAAA8W,OAAA,WAA8CD,EAAAnZ,WAAA,WAAwCwV,EAAAiB,SAAsB,OAC5GvP,EAAAlJ,GAAA,QAAAsE,KAAA+W,QAAA,WAAgDC,aAAAH,KAGhD,GAAAI,GAAArS,EAAAsS,eA6BA,OA5BAtS,GAAAlJ,GAAA,SAAAsE,KAAAmX,SAAA,WACA,GAAAC,GAAAxS,EAAAsS,gBAAA1d,EAAAoL,EAAAyS,oBAAAnB,wBACAoB,EAAA/B,EAAA0B,EAAA1B,IAAA6B,EAAA7B,IACAgC,EAAAD,GAAApe,OAAAse,cAAAle,SAAAuc,iBAAAvc,SAAAoB,MAAA+c,UAEA,OADAhC,KAAA8B,GAAA5C,EAAAqB,cACAuB,GAAA/d,EAAA+b,KAAAgC,GAAA/d,EAAAgc,OAAAtC,EAAAiB,SACAQ,EAAA/Z,MAAA2a,IAAA+B,EAAA,UACA3C,EAAA/Z,MAAA0Q,OAAA2L,EAAA3L,KAAA8L,EAAA9L,KAAA,SAGAtG,WAAAtJ,GAAAiZ,EAAA,oBAAA1S,GACA,GAAAyV,GAAArD,EAAAM,EAAA1S,EAAAC,QAAAD,EAAA0V,WACAD,IAAA,MAAAA,EAAAtC,SAAkCrC,EAAA2D,aAAAgB,EAAAtC,QAA8BrC,EAAAmB,UAGhElP,WAAAtJ,GAAAiZ,EAAA,iBAAA1S,GACA,GAAAyV,GAAArD,EAAAM,EAAA1S,EAAAC,QAAAD,EAAA0V,WACAD,IAAA,MAAAA,EAAAtC,SACArC,EAAA2D,aAAAgB,EAAAtC,QACA9P,EAAAsS,uBAAA7E,EAAAmB,UAIAlP,WAAAtJ,GAAAiZ,EAAA,uBACAjX,WAAA,WAA4BkH,EAAAS,SAAY,MAGxCL,WAAA6S,OAAAza,EAAA,SAAA0X,EAAA,GAAAH,EAAAmD,aACA,EAvQA,GAAA9C,GAAA,kBACAC,EAAA,wBAEAjQ,YAAAC,SAAA,SAAAL,EAAAkO,EAAAxN,GAEA,IAAAV,EAAAoG,oBAAA,CACA,SAAA8H,EAAA,CACA,GAAAxN,KAAAyS,MAAA,MACAjF,GAAA9N,WAAAgT,KAAAC,KAGArT,EAAAkE,MAAAoP,kBAAAtT,EAAAkE,MAAAoP,iBAAA/D,OAEA,IAAAjB,GAAAtO,EAAAkE,MAAAoP,iBAAA,GAAArF,GAAAjO,EAAAkO,EAAAxN,MAEA,OADAN,YAAA6S,OAAAjT,EAAA,kBAAAA,GACAsO,EAAA5N,QAAAyS,UACAjF,GAAAlO,EAAA,SAAA+P,GAAoCzB,EAAAiF,UAAAxD,IAA+BzB,EAAA5N,SAEnE4N,EAAAiF,UAAArF,EAAAlO,EAAAsO,EAAA5N,YAUAuN,EAAAnC,WACAyD,MAAA,WACAnU,KAAAoY,WACApY,KAAA4E,GAAAkE,MAAAoP,iBAAA,KAEAlY,KAAA+S,QAAA/S,KAAA+S,OAAAoB,QACAnU,KAAAgT,SAAAhT,KAAAgT,UACAhO,WAAA6S,OAAA7X,KAAA4E,GAAA,gBAAA5E,KAAA4E,MAGAwT,OAAA,WACA,MAAApY,MAAA4E,GAAAkE,MAAAoP,kBAAAlY,MAGAkU,KAAA,SAAA9W,EAAAoC,GACA,GAAA0T,GAAA9V,EAAA6S,KAAAzQ,EACA0T,GAAA8E,KAAA9E,EAAA8E,KAAAhY,KAAA4E,GAAAxH,EAAA8V,GACAlT,KAAA4E,GAAA8D,aAAAuK,EAAAC,KAAAhL,MAAA9K,EAAA8K,KAAAgL,EAAA/K,IAAA/K,EAAA+K,IACAnD,WAAA6S,OAAAza,EAAA,OAAA8V,GACAlT,KAAAmU,SAGAgE,UAAA,SAAA/a,GACA,MAAAA,MAAA6S,KAAA3S,QAAA0C,KAAAoY,cAEA,GAAApY,KAAAsF,QAAA+S,gBAAA,GAAAjb,EAAA6S,KAAA3S,OACA0C,KAAAkU,KAAA9W,EAAA,GAEA4C,KAAAsY,WAAAlb,IALA4C,KAAAmU,SAQAmE,WAAA,SAAAlb,GAaA,QAAAmb,KACAC,IACAA,GAAA,EACAtF,EAAAiB,QACAjB,EAAAtO,GAAApI,IAAA,iBAAAic,GACArb,GAAA4H,WAAA6S,OAAAza,EAAA,UAGA,QAAAsb,KACAF,IACAxT,WAAA6S,OAAAza,EAAA,UACA8V,EAAA5N,QAAAyS,MACA7E,EAAAJ,SAAAI,EAAAtO,GAAA+T,EAAAzF,EAAA5N,SAEAqT,EAAAzF,EAAAJ,SAAAI,EAAAtO,GAAAsO,EAAA5N,WAEA,QAAAqT,GAAAC,GAEA,MADAxb,GAAAwb,EACAJ,EAAA,OACApb,KAAA6S,KAAA3S,YACA4V,EAAAH,OAAA,GAAA2B,GAAAxB,EAAA9V,IADAmb,IAIA,QAAAM,KACAC,IACAC,EAAAD,GACAA,EAAA,GAIA,QAAAL,KACAI,GACA,IAAAtQ,GAAA2K,EAAAtO,GAAAG,YAAAnC,EAAAsQ,EAAAtO,GAAAkH,QAAAvD,EAAA3F,KACA2F,GAAA3F,MAAAoW,EAAApW,QAAAtF,OAAAiL,EAAAN,IAAAgR,EAAAD,EAAA/Q,IACAM,EAAAN,GAAA+Q,EAAA/Q,IAAAiL,EAAAtO,GAAAoG,qBACAzC,EAAAN,IAAAiR,EAAAne,KAAA6H,EAAAoJ,OAAAzD,EAAAN,GAAA,IACAiL,EAAAiB,SAEA2E,EAAAK,EAAAT,GACAxF,EAAAH,QAAAG,EAAAH,OAAAoB,SAnDAnU,KAAA+S,OAAA,GAAA2B,GAAA1U,KAAA5C,GACA4H,WAAA6S,OAAAza,EAAA,QAEA,IAAAob,GAAAM,EAAA,EAAA5F,EAAAlT,KACAkZ,EAAAlZ,KAAAsF,QAAA8T,iBAAA,mBACAJ,EAAAhZ,KAAA4E,GAAAG,YAAAkU,EAAAjZ,KAAA4E,GAAAkH,QAAAkN,EAAApW,MAAAtF,OAEA6b,EAAAjgB,OAAAigB,uBAAA,SAAA5b,GACA,MAAAG,YAAAH,EAAA,SAEAwb,EAAA7f,OAAA6f,sBAAA/B,YA4CAhX,MAAA4E,GAAAlJ,GAAA,iBAAA+c,GACAzY,KAAAgT,QAAAuF,IAuJA7D,EAAAhE,WACAyD,MAAA,WACA,GAAAnU,KAAAkT,WAAAH,QAAA/S,KAAA,CACAA,KAAAkT,WAAAH,OAAA,KACA/S,KAAA2U,MAAAhR,WAAAtJ,YAAA2F,KAAA2U,OACA3U,KAAAkT,WAAAtO,GAAAkI,aAAA9M,KAAAwW,OAEA,IAAA5R,GAAA5E,KAAAkT,WAAAtO,EACA5E,MAAAkT,WAAA5N,QAAAsR,kBAAA,IACAhS,EAAApI,IAAA,OAAAwD,KAAA8W,QACAlS,EAAApI,IAAA,QAAAwD,KAAA+W,UAEAnS,EAAApI,IAAA,SAAAwD,KAAAmX,YAGAjD,KAAA,WACAlU,KAAAkT,WAAAgB,KAAAlU,KAAA5C,KAAA4C,KAAA4U,eAGA8B,aAAA,SAAAlX,EAAAiX,GAKA,GAJAjX,GAAAQ,KAAA5C,KAAA6S,KAAA3S,OACAkC,EAAAiX,EAAAzW,KAAA5C,KAAA6S,KAAA3S,OAAA,IACA,EAAAkC,IACAA,EAAAiX,EAAA,EAAAzW,KAAA5C,KAAA6S,KAAA3S,OAAA,GACA0C,KAAA4U,cAAApV,EAAA,CACA,GAAA6Z,GAAArZ,KAAA2U,MAAAtU,WAAAL,KAAA4U,aACAyE,GAAA5K,UAAA4K,EAAA5K,UAAAkD,QAAA,IAAAsD,EAAA,IACAoE,EAAArZ,KAAA2U,MAAAtU,WAAAL,KAAA4U,aAAApV,GACA6Z,EAAA5K,WAAA,IAAAwG,EACAoE,EAAAC,UAAAtZ,KAAA2U,MAAA8C,UACAzX,KAAA2U,MAAA8C,UAAA4B,EAAAC,UAAA,EACAD,EAAAC,UAAAD,EAAArD,aAAAhW,KAAA2U,MAAA8C,UAAAzX,KAAA2U,MAAAnO,eACAxG,KAAA2U,MAAA8C,UAAA4B,EAAAC,UAAAD,EAAArD,aAAAhW,KAAA2U,MAAAnO,aAAA,GACAxB,WAAA6S,OAAA7X,KAAA5C,KAAA,SAAA4C,KAAA5C,KAAA6S,KAAAjQ,KAAA4U,cAAAyE,KAGA1C,aAAA,WACA,MAAA3T,MAAAuW,MAAAvZ,KAAA2U,MAAAnO,aAAAxG,KAAA2U,MAAAmD,WAAA9B,eAAA,IAIAhR,WAAA4K,eAAA,uBAAAhL,EAAAU,GACA,GAAAkU,GAAAC,EAAA7U,EAAA8U,WAAA9U,EAAAG,YAAA,OACA,IAAA0U,EAAAnc,OACA,OAAAkC,GAAA,EAAqBA,EAAAia,EAAAnc,OAAoBkC,IAAA,CACzC,GAAA2L,GAAAsO,EAAAja,GAAAoF,EAAAU,EACA,IAAA6F,KAAA8E,KAAA3S,OAAA,MAAA6N,OAEK,IAAAqO,EAAA5U,EAAA+U,UAAA/U,EAAAG,YAAA,cACL,GAAAyU,EAAA,MAAAxU,YAAAgT,KAAA4B,SAAAhV,GAAsD4U,cACjD,IAAAxU,WAAAgT,KAAA6B,QACL,MAAA7U,YAAAgT,KAAA6B,QAAAjV,EAAAU,KAIAN,WAAA4K,eAAA,2BAAAhL,EAAAU,GAGA,OAFA6F,GAAAvG,EAAAG,YAAAmM,EAAAtM,EAAAiH,WAAAV,GACA+C,KACA1O,EAAA,EAAmBA,EAAA8F,EAAAkU,MAAAlc,OAA0BkC,IAAA,CAC7C,GAAAqQ,GAAAvK,EAAAkU,MAAAha,EACAqQ,GAAA1M,MAAA,EAAA+N,EAAAI,OAAAhU,SAAA4T,EAAAI,QACApD,EAAAzQ,KAAAoS,GAGA,MAAA3B,GAAA5Q,QACA2S,KAAA/B,EACAhG,KAAAlD,WAAAwF,IAAAW,EAAAvI,KAAAsO,EAAA7G,OACAlC,GAAAnD,WAAAwF,IAAAW,EAAAvI,KAAAsO,EAAA5G,MAHA,SAOAtF,WAAA8U,SAAAC,aAAA/U,WAAAC,a1BuhCM,Y2B32CN,WACA,YAIA,SAAA+U,GAAA/X,EAAAgY,GAMA,QAAAC,GAAAjY,GACA,MAAAkY,GAAAxW,YACAwW,EAAAvf,MAAA2a,IAAAvS,KAAAoL,IAAA,EAAAnM,EAAAmY,QAAAD,EAAAnE,aAAA,aACAmE,EAAAvf,MAAA0Q,KAAArJ,EAAAoY,QAAA,SAFArV,WAAAxI,IAAAlD,SAAA,YAAA4gB,GANA,GAAAC,GAAA7gB,SAAAO,cAAA,MAaA,OAZAsgB,GAAA1L,UAAA,0BACA0L,EAAAlgB,YAAAggB,EAAAK,WAAA,IACAhhB,SAAAoB,KAAAT,YAAAkgB,GAOAnV,WAAAtJ,GAAApC,SAAA,YAAA4gB,GACAA,EAAAjY,GACA,MAAAkY,EAAAvf,MAAA2f,UAAAJ,EAAAvf,MAAA2f,QAAA,GACAJ,EAEA,QAAAK,GAAAzF,GACAA,EAAApR,YAAAoR,EAAApR,WAAAtJ,YAAA0a,GAEA,QAAA0F,GAAAN,GACAA,EAAAxW,aACA,MAAAwW,EAAAvf,MAAA2f,SAAAC,EAAAL,GACAA,EAAAvf,MAAA2f,QAAA,EACA7c,WAAA,WAA2B8c,EAAAL,IAAU,MAGrC,QAAAO,GAAAzY,EAAAgY,EAAAZ,GAEA,QAAAsB,KACA3V,WAAAxI,IAAA6c,EAAA,WAAAsB,GACAC,IAAoBH,EAAAG,GAAsBA,EAAA,MAH1C,GAAAA,GAAAZ,EAAA/X,EAAAgY,GAKAY,EAAAC,YAAA,WACA,GAAAF,EAAA,OAAA/S,GAAAwR,GAAsCxR,IAAAlE,WAAA,CACtC,GAAAkE,GAAAvO,SAAAoB,KAAA,MACA,KAAAmN,EAAA,CAAiB8S,GAAQ,QAEzB,MAAAC,GAAA,OAAAG,cAAAF,IACK,IACL7V,YAAAtJ,GAAA2d,EAAA,WAAAsB,GAGA,QAAAK,GAAApW,EAAAU,EAAA2V,GACAjb,KAAAkb,UACAlb,KAAAsF,UACAtF,KAAAmb,QAAA,KACAnb,KAAAib,YACAjb,KAAAob,YAAA,SAAAnZ,GAAoCmZ,EAAAxW,EAAA3C,IAGpC,QAAAoZ,GAAAzW,EAAAU,GACA,GAAAA,YAAA6M,UAAA,OAA6CmJ,eAAAhW,EAG7C,IAFAA,QAAA,IAAAA,MACAA,EAAAgW,iBAAAhW,EAAAgW,eAAA1W,EAAA+U,UAAA3U,WAAAwF,IAAA,eACAlF,EAAAgW,eAAA,SAAAjd,OAAA,wDACA,OAAAiH,GAGA,QAAAiW,GAAA3W,GACA,GAAAkE,GAAAlE,EAAAkE,MAAA0S,IACA1S,GAAAmS,WAAArW,EAAA6W,YAAAC,EACA,QAAAlc,GAAA,EAAmBA,EAAAsJ,EAAAoS,OAAA5d,SAAyBkC,EAC5CsJ,EAAAoS,OAAA1b,GAAAqP,OACA/F,GAAAoS,OAAA5d,OAAA,EAGA,QAAAqe,GAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAA1iB,SAAAO,cAAA,OAAAoiB,EAAAD,CAWA,OAVAA,GAAAvN,UAAA,0BAAAoN,EACAC,IACAG,EAAAD,EAAA/hB,YAAAX,SAAAO,cAAA,QACAoiB,EAAAxN,UAAA,mCAGA,GAAAsN,GAAA/W,WAAAtJ,GAAAugB,EAAA,qBAAAha,GACAyY,EAAAzY,EAAA2Z,EAAAK,KAGAD,EAGA,QAAAE,GAAAnU,EAAAC,GACA,eAAAD,IACAC,EAGA,QAAAmU,GAAAC,GAEA,OADAnV,MACAzH,EAAA,EAAmBA,EAAA4c,EAAA9e,SAAwBkC,EAAA,CAC3C,GAAA6c,GAAAD,EAAA5c,GAAAoD,EAAAyZ,EAAAnU,KAAAtF,MACAqE,EAAArE,KAAAqE,EAAArE,QAAAnF,KAAA4e,GAEA,MAAApV,GAGA,QAAAqV,GAAAD,GACA,GAAAR,GAAAQ,EAAAR,QACAU,GAAAxhB,KAAA8gB,OAAA,QACA,IAAAW,GAAAljB,SAAAO,cAAA,MAGA,OAFA2iB,GAAA/N,UAAA,2BAAAoN,EACAW,EAAAviB,YAAAX,SAAAY,eAAAmiB,EAAAvW,UACA0W,EAGA,QAAAC,GAAA7X,GACA,GAAAkE,GAAAlE,EAAAkE,MAAA0S,KAAAlW,EAAAwD,EAAAxD,OACAA,GAAAyS,MACAzS,EAAAgW,eAAA1W,EAAA8X,EAAApX,GAEAoX,EAAA9X,EAAAU,EAAAgW,eAAA1W,EAAA+X,WAAArX,YAGA,QAAAoX,GAAA9X,EAAAgY,GACArB,EAAA3W,EAKA,QAJAkE,GAAAlE,EAAAkE,MAAA0S,KAAAlW,EAAAwD,EAAAxD,QAEA8W,EAAAD,EAAAS,GAEAha,EAAA,EAAsBA,EAAAwZ,EAAA9e,SAA2BsF,EAAA,CACjD,GAAAia,GAAAT,EAAAxZ,EACA,IAAAia,EAAA,CAKA,OAHAC,GAAA,KACAC,EAAAjU,EAAAmS,WAAA3hB,SAAA0jB,yBAEAxd,EAAA,EAAqBA,EAAAqd,EAAAvf,SAAiBkC,EAAA,CACtC,GAAA6c,GAAAQ,EAAArd,GACAqc,EAAAQ,EAAAR,QACAU,GAAAxhB,KAAA8gB,OAAA,SACAiB,EAAAZ,EAAAY,EAAAjB,GAEAvW,EAAA2X,mBAAAZ,EAAA/W,EAAA2X,iBAAAZ,IACAvT,EAAAmS,WAAA8B,EAAA9iB,YAAAqiB,EAAAD,IAEAA,EAAAlU,IAAAW,EAAAoS,OAAAzd,KAAAmH,EAAA4J,SAAA6N,EAAAnU,KAAAmU,EAAAlU,IACAsG,UAAA,wBAAAoN,EACAqB,aAAAb,KAIAvT,EAAAmS,WACArW,EAAAuY,gBAAAva,EAAA8Y,EAAAC,EAAAoB,EAAAD,EAAAD,EAAAvf,OAAA,EACAwL,EAAAxD,QAAAyW,YAEAzW,EAAA8X,iBAAA9X,EAAA8X,gBAAAR,EAAAR,EAAAxX,GAGA,QAAAyY,GAAAzY,GACA,GAAAkE,GAAAlE,EAAAkE,MAAA0S,IACAxE,cAAAlO,EAAAqS,SACArS,EAAAqS,QAAAzd,WAAA,WAA0C+e,EAAA7X,IAAkBkE,EAAAxD,QAAAgY,OAAA,KAG5D,QAAAC,GAAAlB,EAAApa,GACA,GAAAC,GAAAD,EAAAC,QAAAD,EAAA0V,UACA+C,GAAAzY,EAAAqa,EAAAD,GAAAna,GAQA,QAAAkZ,GAAAxW,EAAA3C,GACA,6BAAAlH,MAAAkH,EAAAC,QAAAD,EAAA0V,YAAAlJ,WACA,OAAAjP,GAAA,EAAmBA,EAAAge,EAAAlgB,OAAmBkC,GAAA,EAGtC,OAFAie,GAAA7Y,EAAA8Y,YAAA9Y,EAAA+Y,YAAgDrS,KAAArJ,EAAAoY,QAAAmD,EAAAhe,GAChD+V,IAAAtT,EAAAmY,QAAAoD,EAAAhe,EAAA,MACAoe,EAAA,EAAqBA,EAAAH,EAAAngB,SAAkBsgB,EAAA,CACvC,GAAAC,GAAAJ,EAAAG,GAAAvB,EAAAwB,EAAAX,YACA,IAAAb,EAAA,MAAAkB,GAAAlB,EAAApa,IAKA,QAAA6b,GAAAlZ,EAAA+H,EAAAC,GAQA,GAPAA,MAAA5H,WAAA6H,OACA0O,EAAA3W,GACAA,EAAApI,IAAA,SAAA6gB,GACArY,WAAAxI,IAAAoI,EAAAyS,oBAAA,YAAAzS,EAAAkE,MAAA0S,KAAAJ,mBACAxW,GAAAkE,MAAA0S,MAGA7O,EAAA,CAEA,OADAoR,GAAAnZ,EAAAqG,UAAA,WAAA+S,GAAA,EACAxe,EAAA,EAAqBA,EAAAue,EAAAzgB,SAAoBkC,EAAAue,EAAAve,IAAAkc,IAAAsC,GAAA,EACzC,IAAAlV,GAAAlE,EAAAkE,MAAA0S,KAAA,GAAAR,GAAApW,EAAAyW,EAAAzW,EAAA+H,GAAAqR,EACApZ,GAAAlJ,GAAA,SAAA2hB,GACA,GAAAvU,EAAAxD,QAAAyW,UACA/W,WAAAtJ,GAAAkJ,EAAAyS,oBAAA,YAAAvO,EAAAsS,aAEAqB,EAAA7X,IAlMA,GAAA8W,GAAA,0BACAa,EAAA,sBAmKAiB,GAAA,sBAkCAxY,YAAA0H,aAAA,cAAAoR,GACA9Y,WAAA0H,aAAA,UAAAoR,O3Bm3CM,Y4B9iDN,WAKA,QAAAG,GAAA3Y,GACA,gBAAAA,KACAtF,KAAAke,SAAA5Y,EAAA4Y,SACAle,KAAApF,MAAA0K,EAAA1K,MACAoF,KAAAme,UAAA7Y,EAAA6Y,UACAne,KAAAsd,MAAAhY,EAAAgY,OAEA,MAAAtd,KAAApF,QAAAoF,KAAApF,MAAAwjB,GACA,MAAApe,KAAAke,WAAAle,KAAAke,SAAAG,GACA,MAAAre,KAAAsd,QAAAtd,KAAAsd,MAAAgB,GACAte,KAAAue,QAAAve,KAAAmb,QAAA,KAkBA,QAAAqD,GAAA5Z,GACA,GAAAkE,GAAAlE,EAAAkE,MAAA2V,gBACAzH,cAAAlO,EAAAqS,SACArS,EAAAqS,QAAAzd,WAAA,WAA2CghB,EAAA9Z,IAAsBkE,EAAAwU,OAGjE,QAAAoB,GAAA9Z,GACAA,EAAA0H,UAAA,WACA,GAAAxD,GAAAlE,EAAAkE,MAAA2V,gBAKA,IAJA3V,EAAAyV,UACA3Z,EAAA+Z,cAAA7V,EAAAyV,SACAzV,EAAAyV,QAAA,OAEA3Z,EAAAoG,qBAAAlC,EAAAqV,UAAA,CAGA,IAFA,GAAAzQ,GAAA5E,EAAAqV,aAAA,UAAArV,EAAAqV,UACAhT,EAAAvG,EAAAG,YAAAnC,EAAAgC,EAAAkH,QAAAX,EAAAvI,MAAAyH,EAAAc,EAAAlD,GAAAqC,EAAAD,EACAA,GAAAqD,EAAA3S,KAAA6H,EAAAoJ,OAAA3B,EAAA,OAAAA,CACA,MAAAC,EAAA1H,EAAAtF,QAAAoQ,EAAA3S,KAAA6H,EAAAoJ,OAAA1B,QAGA,aAFAA,EAAAD,GACAzF,EAAAga,WAAA9V,EAAAyV,QAAAM,EAAAjc,EAAAO,MAAAkH,EAAAC,GAAAoD,EAAA5E,EAAAlO,SAGA,GAAAgK,EAAAG,UAAA,QAAAnC,MAAAgC,EAAAG,UAAA,UAAAnC,KAAA,CACA,GAAA6I,GAAA7G,EAAA8G,eAAAiG,QAAA,gBACAlG,GAAAnO,QAAAwL,EAAAoV,UACAtZ,EAAAga,WAAA9V,EAAAyV,QAAAM,EAAApT,GAAA,EAAA3C,EAAAlO,WAIA,QAAAkkB,GAAAC,EAAArR,GACA,QAAAqR,EAAA1U,OAAAqD,EAAA3S,KAAAgkB,EAAAzN,OAAAtF,OAAA+S,EAAA1U,MAAA,KACA0U,EAAAxW,KAAAwW,EAAAzN,OAAAhU,QAAAoQ,EAAA3S,KAAAgkB,EAAAzN,OAAAtF,OAAA+S,EAAAxW,OAGA,QAAAsW,GAAAG,EAAAC,EAAArkB,GACA,OAAYsW,MAAA,SAAA6N,GACZ,OAAAA,EAAA/jB,MAAAgkB,IACAC,IAAAH,EAAAC,EAAAE,IAEAF,EAAApM,YACAoM,EAAAG,OAAAF,EAAAhT,OAAA,KAAA+S,EAAAI,cAFAvkB,IAtEA,GAAAyjB,GAAA,EACAD,EAAA,iBACAE,EAAA,GAeAtZ,YAAA0H,aAAA,wCAAA9H,EAAA+H,EAAAC,GACA,GAAAA,MAAA5H,WAAA6H,KAAA,CACA,GAAAuS,GAAAxa,EAAAkE,MAAA2V,iBAAAF,OACAa,IAAAxa,EAAA+Z,cAAAS,GACApI,aAAApS,EAAAkE,MAAA2V,iBAAAtD,SACAvW,EAAAkE,MAAA2V,iBAAA,KACA7Z,EAAApI,IAAA,iBAAAgiB,GAEA7R,IACA/H,EAAAkE,MAAA2V,iBAAA,GAAAR,GAAAtR,GACA+R,EAAA9Z,GACAA,EAAAlJ,GAAA,iBAAA8iB,U5BknDM,Y6BvpDN,WACA,YAgBA,SAAAa,GAAAza,GACA,cAAAA,GAAAkE,QACAlE,EAAA0a,gBAAA1a,EAAAkE,MAAAyW,WAAA,OAAAC,GACA5a,EAAA0a,gBAAA1a,EAAAkE,MAAAyW,WAAA,aAAAE,IAIA,QAAAC,GAAA9a,EAAA+a,GACA,GAAA/c,GAAAgC,EAAAgb,yBAAAD,EACA/a,GAAAkE,MAAAyW,YAAA3c,GACAgC,EAAA0H,UAAA,WACA+S,EAAAza,GACAA,EAAAib,aAAAjd,EAAA,OAAA4c,GACA5a,EAAAib,aAAAjd,EAAA,aAAA6c,GACA7a,EAAAkE,MAAAyW,WAAA3c,IAIA,QAAAkd,GAAAlb,EAAAmb,GACAL,EAAA9a,EAAAmb,EAAA5lB,KAAAyI,MAlCA,GAAA4c,GAAA,wBACAC,EAAA,kCAEAza,YAAA0H,aAAA,8BAAA9H,EAAA+H,EAAAC,GACA,GAAAoT,GAAApT,MAAA5H,WAAA6H,IACAF,KAAAqT,GACAN,EAAA9a,IAAAG,YAAAnC,MACAgC,EAAAlJ,GAAA,wBAAAokB,KACKnT,GAAAqT,IACLpb,EAAApI,IAAA,wBAAAsjB,GACAT,EAAAza,SACAA,GAAAkE,MAAAyW,kB7B6rDM,W8B/sDNrmB,OAAA8L,WAAA,WACA,YA4CA,SAAAA,GAAAib,EAAA3a,GACA,KAAAtF,eAAAgF,IAAA,UAAAA,GAAAib,EAAA3a,EAEAtF,MAAAsF,eAEA,QAAA4a,KAAAC,KAAA7a,EAAAjK,eAAA6kB,IAAAC,GAAA9kB,eAAA6kB,KACA5a,EAAA4a,GAAAC,GAAAD,GACAE,GAAA9a,EAEA,IAAA+a,GAAA,gBAAA/a,GAAAC,MAAA,EAAAD,EAAAC,MAAA+a,MACAlZ,EAAApH,KAAAoH,QAAAmZ,EAAAN,EAAAI,EACAjZ,GAAAlL,QAAA8I,WAAAhF,KACAwgB,EAAAxgB,MACAsF,EAAAmb,YAAAC,IAAAC,GAAA3gB,MAEAA,KAAA8I,OAAkB8X,WAClBC,YACAC,QAAA,EACAC,WAAA,EAAAnS,SAAA,EACAoS,eAAA,EACAC,eAAA,EAAAC,aAAA,EACAC,cAAA,EACAC,UAAA,GAAAC,KAEAC,EAAAthB,MACAsF,EAAAG,eACAzF,KAAAoH,QAAAlL,QAAAuS,WAAA,mBAEA,IAAA8S,GAAAjc,EAAAC,KACA,iBAAAgc,OAAA,GAAAC,IAAAlc,EAAAC,MAAAD,EAAAxB,OACAwI,GAAAtM,KAAAyhB,IAAAzhB,KAAAuhB,GAIAG,IAAAhkB,WAAA3B,GAAA4lB,GAAA3hB,MAAA,OAEA4hB,GAAA5hB,KAGA,IAAA6hB,EAAiB,KAAMA,EAAAvoB,SAAAwoB,eAAA1a,EAAAjC,MAAwD,MAAAlD,IAC/E4f,GAAAvc,EAAAmb,YAAAC,GAAAhjB,WAAA3B,GAAAgb,GAAA/W,MAAA,IACA8W,GAAA9W,MAEAsM,GAAAtM,KAAA,WACA,OAAAkgB,KAAA6B,IACAA,GAAAC,qBAAA9B,IACA6B,GAAA7B,GAAAlgB,KAAAsF,EAAA4a,GAAArT,GACA,QAAArN,GAAA,EAAqBA,EAAAyiB,GAAA3kB,SAAsBkC,EAAAyiB,GAAAziB,GAAAQ,UAM3C,QAAAugB,GAAAN,EAAAI,GACA,GAAA5S,MAEAtI,EAAAsI,EAAAtI,MAAA4P,GAAA,8FAyFA,OAxFAmN,IAAA/c,EAAAvK,MAAAmM,MAAA,SACA5B,EAAAC,aAAA,cAEA+c,KAAAhd,EAAAvK,MAAAwnB,OAAA,mBACAjd,EAAAC,aAAA,qBAA6CD,EAAAC,aAAA,wBAA6CD,EAAAC,aAAA,sBAG1FqI,EAAA4U,SAAAtN,GAAA,OAAA5P,GAAA,uEAEAsI,EAAA6U,WAAAvN,GAAA,OAAAA,GAAA,yDACAtH,EAAA8U,WAAAxN,GAAA,OAAAA,GAAA,wDACAtH,EAAA+U,gBAAAzN,GAAA,0CACAtH,EAAAgV,aAAA1N,GAAA,uCAEAtH,EAAAiV,QAAA3N,GAAA,8BACAtH,EAAAkV,aAAA5N,GAAA,kDAEAtH,EAAA6I,OAAAvB,GAAA,+BAEAtH,EAAAmV,YAAA7N,GAAA,0DAEAtH,EAAAoV,QAAA9N,GAAA,iCAEAtH,EAAAqV,UAAA/N,GAAA,OAAAtH,EAAAoV,QAAApV,EAAAkV,aAAAlV,EAAAiV,QAAAjV,EAAA6I,OAAA7I,EAAAmV,aACA,0CAEAnV,EAAAsV,MAAAhO,GAAA,OAAAA,GAAA,OAAAtH,EAAAqV,WAAA,gDAEArV,EAAAuV,MAAAjO,GAAA,OAAAtH,EAAAsV,OAAA,oBAEAtV,EAAAwV,aAAAlO,GAAA,+CAAgEmO,GAAA,mBAEhEzV,EAAAsQ,QAAAhJ,GAAA,iCACAtH,EAAA0V,WAAA,KAEA1V,EAAA2V,SAAArO,GAAA,OAAAtH,EAAAuV,MAAAvV,EAAAwV,aAAAxV,EAAAsQ,SAAA,qBACAtQ,EAAA2V,SAAAhe,aAAA,iBAEAqI,EAAAvR,QAAA6Y,GAAA,OAAAtH,EAAA4U,SAAA5U,EAAA6U,WAAA7U,EAAA8U,WACA9U,EAAA+U,gBAAA/U,EAAAgV,aAAAhV,EAAA2V,UAAA,cAEAzU,KAAiBlB,EAAAsQ,QAAAnjB,MAAAyoB,OAAA,GAA6B5V,EAAA2V,SAAAxoB,MAAA0oB,aAAA,GAC9CrD,EAAAhmB,YAAAgmB,EAAAhmB,YAAAwT,EAAAvR,SAAwD+jB,EAAAxS,EAAAvR,SAGxDimB,KAAAhd,EAAAvK,MAAAmM,MAAA,OACAmb,KAAAzU,EAAA2V,SAAAG,WAAA,GAEAC,IAAgB/V,EAAA4U,SAAAznB,MAAAwb,OAAA,MAAiC3I,EAAA4U,SAAAznB,MAAAsf,SAAA,YAEjDvL,KAAAlB,EAAA6U,WAAA1nB,MAAA6oB,SAAAhW,EAAA8U,WAAA3nB,MAAA6oB,SAAA,QAGAhW,EAAAiW,WAAAjW,EAAAkW,UAAA,EACAlW,EAAAmW,YAAAnW,EAAAoW,UAAAxD,EAIA5S,EAAAqW,aAAArW,EAAAsW,kBAAAtW,EAAAuW,aAAA,KAEAvW,EAAAwW,UAAA,GAGAxW,EAAAyW,cAAA,EAIAzW,EAAA0W,aAAA,EAEA1W,EAAAoN,KAAA,GAAAwG,IAEA5T,EAAA2W,gBAAA3W,EAAA4W,iBAAA5W,EAAA6W,eAAA,KACA7W,EAAA8W,oBACA9W,EAAA+W,oBAAA,EAIA/W,EAAAgX,qBAAA,EAIAhX,EAAAiX,QAAA,KACAjX,EAAAkX,cAAA,EACAlX,EAAAmX,gBAAA,EAGAnX,EAAAoX,QAAApX,EAAAqX,QAAArX,EAAAsX,YAAAtX,EAAAuX,YAAA,KAEAvX;CAOA,QAAAwX,GAAArgB,GACAA,EAAA2c,IAAAzd,KAAAkB,EAAAqM,QAAAzM,EAAAU,QAAAV,EAAA2c,IAAA2D,YACAC,EAAAvgB,GAGA,QAAAugB,GAAAvgB,GACAA,EAAA2c,IAAA6D,KAAA,SAAAxiB,GACAA,EAAAyiB,aAAAziB,EAAAyiB,WAAA,MACAziB,EAAA0iB,SAAA1iB,EAAA0iB,OAAA,QAEA1gB,EAAA2c,IAAAgE,SAAA3gB,EAAA2c,IAAAjB,MACAkF,EAAA5gB,EAAA,KACAA,EAAAkE,MAAAgY,UACAlc,EAAA6gB,OAAAC,GAAA9gB,GAGA,QAAA+gB,GAAA/gB,GACAA,EAAAU,QAAAG,cACAb,EAAAwC,QAAAlL,QAAAuS,WAAA,mBACA7J,EAAAwC,QAAA4b,MAAApoB,MAAA6oB,SAAA,KAEA7e,EAAAwC,QAAAlL,QAAAuS,UAAA7J,EAAAwC,QAAAlL,QAAAuS,UAAAkD,QAAA,uBACAiU,EAAAhhB,IAEAihB,EAAAjhB,GACA8gB,GAAA9gB,GACAkhB,EAAAlhB,GACAlH,WAAA,WAA0BqoB,EAAAnhB,IAAsB,KAGhD,QAAAohB,GAAAphB,GACA,GAAAqhB,GAAAC,GAAAthB,EAAAwC,SAAA+e,EAAAvhB,EAAAU,QAAAG,aACA2gB,EAAAD,GAAAnjB,KAAAoL,IAAA,EAAAxJ,EAAAwC,QAAAgc,SAAA7c,YAAA8f,GAAAzhB,EAAAwC,SAAA,EACA,iBAAAxE,GACA,MAAA0jB,IAAA1hB,EAAA2c,IAAA3e,GACA,EACAujB,GACAnjB,KAAAujB,KAAA3jB,EAAAJ,KAAAlF,OAAA8oB,IAAA,GAAAH,EAEAA,GAIA,QAAAJ,GAAAjhB,GACA,GAAA2c,GAAA3c,EAAA2c,IAAAiF,EAAAR,EAAAphB,EACA2c,GAAA6D,KAAA,SAAAxiB,GACA,GAAA6jB,GAAAD,EAAA5jB,EACA6jB,IAAA7jB,EAAAwT,QAAAsQ,GAAA9jB,EAAA6jB,KAIA,QAAAE,GAAA/hB,GACA,GAAA1B,GAAAsT,GAAA5R,EAAAU,QAAAkR,QAAA5b,EAAAsI,EAAAtI,KACAgK,GAAAwC,QAAAlL,QAAAuS,UAAA7J,EAAAwC,QAAAlL,QAAAuS,UAAAkD,QAAA,yBACA/W,EAAA,cAAAA,EAAA,IAGA,QAAA0mB,GAAA1c,GACAA,EAAAwC,QAAAlL,QAAAuS,UAAA7J,EAAAwC,QAAAlL,QAAAuS,UAAAkD,QAAA,mBACA/M,EAAAU,QAAAO,MAAA8L,QAAA,uBACAmU,EAAAlhB,GAGA,QAAAgiB,GAAAhiB,GACA4b,EAAA5b,GACA8gB,GAAA9gB,GACAlH,WAAA,WAA0BmpB,EAAAjiB,IAAuB,IAGjD,QAAA4b,GAAA5b,GACA,GAAAmZ,GAAAnZ,EAAAwC,QAAA2W,QAAA+I,EAAAliB,EAAAU,QAAAyY,OACAgJ,IAAAhJ,EACA,QAAAve,GAAA,EAAmBA,EAAAsnB,EAAAxpB,SAAkBkC,EAAA,CACrC,GAAAwnB,GAAAF,EAAAtnB,GACAynB,EAAAlJ,EAAA9jB,YAAA8a,GAAA,gCAAAiS,GACA,2BAAAA,IACApiB,EAAAwC,QAAA+b,WAAA8D,EACAA,EAAArsB,MAAAmM,OAAAnC,EAAAwC,QAAA0c,cAAA,SAGA/F,EAAAnjB,MAAAwM,QAAA5H,EAAA,UAGA,QAAA0nB,GAAA3F,EAAA3e,GACA,MAAAA,EAAAwT,OAAA,QAEA,KADA,GAAA+Q,GAAAC,EAAAxkB,EAAAJ,KAAAlF,OAAA6N,EAAAvI,EACAukB,EAAAE,GAAAlc,IAAA,CACA,GAAA+C,GAAAiZ,EAAAG,MACAnc,GAAAW,GAAAyV,EAAArT,EAAAhG,KAAAtF,MACAwkB,GAAAlZ,EAAAhG,KAAAD,GAAAiG,EAAA/F,GAAAF,GAGA,IADAkD,EAAAvI,EACAukB,EAAAI,GAAApc,IAAA,CACA,GAAA+C,GAAAiZ,EAAAG,MACAF,IAAAjc,EAAA3I,KAAAlF,OAAA4Q,EAAAhG,KAAAD,GACAkD,EAAAW,GAAAyV,EAAArT,EAAA/F,GAAAvF,MACAwkB,GAAAjc,EAAA3I,KAAAlF,OAAA4Q,EAAA/F,GAAAF,GAEA,MAAAmf,GAGA,QAAAxB,GAAAhhB,GACA,GAAA6I,GAAA7I,EAAAwC,QAAAma,EAAA3c,EAAA2c,GACA9T,GAAAiX,QAAA5Y,GAAAyV,IAAAjB,OACA7S,EAAAkX,cAAAuC,EAAA3F,EAAA9T,EAAAiX,SACAjX,EAAAmX,gBAAA,EACArD,EAAA6D,KAAA,SAAAxiB,GACA,GAAAwkB,GAAAF,EAAA3F,EAAA3e,EACAwkB,GAAA3Z,EAAAkX,gBACAlX,EAAAkX,cAAAyC,EACA3Z,EAAAiX,QAAA9hB,KAOA,QAAAwd,GAAA9a,GACA,GAAA4I,GAAApO,GAAAwF,EAAAyY,QAAA,yBACA,KAAA7P,GAAA5I,EAAAkiB,YACAliB,EAAAyY,QAAAzY,EAAAyY,QAAA0J,QAAA,2BACKvZ,EAAA,KAAA5I,EAAAkiB,cACLliB,EAAAyY,QAAAzY,EAAAyY,QAAA5a,MAAA,GACAmC,EAAAyY,QAAA2J,OAAAxZ,EAAA,IAQA,QAAA6X,GAAAnhB,GACA,GAAA6I,GAAA7I,EAAAwC,QAAAugB,EAAA/iB,EAAA2c,IAAAnL,OACAwR,EAAAD,EAAAE,EAAApa,EACAA,GAAAuV,MAAApoB,MAAAktB,UAAAra,EAAAwV,aAAAroB,MAAA2a,IAAAqS,EAAA,KACAna,EAAAsQ,QAAAnjB,MAAAwb,OAAApT,KAAAoL,IAAAwZ,EAAAna,EAAA2V,SAAA5c,aAAA0c,IAAA,IACA,IAAA6E,GAAA/kB,KAAAoL,IAAAwZ,EAAAna,EAAA2V,SAAA2E,cACAC,EAAAva,EAAA2V,SAAA6E,YAAAxa,EAAA2V,SAAA7c,YAAA,EACA2hB,EAAAH,EAAAta,EAAA2V,SAAA5c,aAAA,CACA0hB,IACAza,EAAA8U,WAAA3nB,MAAAwM,QAAA,QACAqG,EAAA8U,WAAA3nB,MAAA4a,OAAAwS,EAAAG,GAAA1a,EAAAoV,SAAA,SAEApV,EAAA8U,WAAAzK,WAAAld,MAAAwb,OACApT,KAAAoL,IAAA,EAAA2Z,EAAAta,EAAA2V,SAAA5c,aAAAiH,EAAA8U,WAAA/b,cAAA,OAEAiH,EAAA8U,WAAA3nB,MAAAwM,QAAA,GACAqG,EAAA8U,WAAAzK,WAAAld,MAAAwb,OAAA,KAEA4R,GACAva,EAAA6U,WAAA1nB,MAAAwM,QAAA,QACAqG,EAAA6U,WAAA1nB,MAAA2Q,MAAA2c,EAAAC,GAAA1a,EAAAoV,SAAA,SACApV,EAAA6U,WAAAxK,WAAAld,MAAAmM,MACA0G,EAAA2V,SAAA6E,YAAAxa,EAAA2V,SAAA7c,YAAAkH,EAAA6U,WAAA/b,YAAA,OAEAkH,EAAA6U,WAAA1nB,MAAAwM,QAAA,GACAqG,EAAA6U,WAAAxK,WAAAld,MAAAmM,MAAA,KAEAihB,GAAAE,GACAza,EAAA+U,gBAAA5nB,MAAAwM,QAAA,QACAqG,EAAA+U,gBAAA5nB,MAAAwb,OAAA3I,EAAA+U,gBAAA5nB,MAAAmM,MAAAohB,GAAA1a,EAAAoV,SAAA,MACKpV,EAAA+U,gBAAA5nB,MAAAwM,QAAA,GACL4gB,GAAApjB,EAAAU,QAAA8iB,4BAAAxjB,EAAAU,QAAA+iB,aACA5a,EAAAgV,aAAA7nB,MAAAwM,QAAA,QACAqG,EAAAgV,aAAA7nB,MAAAwb,OAAA+R,GAAA1a,EAAAoV,SAAA,KACApV,EAAAgV,aAAA7nB,MAAAmM,MAAA0G,EAAAsQ,QAAAnI,YAAA,MACKnI,EAAAgV,aAAA7nB,MAAAwM,QAAA,GAELkhB,IAAA,IAAAH,GAAA1a,EAAAoV,WACApV,EAAA8U,WAAA3nB,MAAA6oB,SAAAhW,EAAA6U,WAAA1nB,MAAAktB,UAAAS,GAAA,cACA9a,EAAA8U,WAAA3nB,MAAA4tB,cAAA/a,EAAA6U,WAAA1nB,MAAA4tB,cAAA,QAIA,QAAAC,GAAArhB,EAAAma,EAAAmH,GACA,GAAAnT,GAAAnO,EAAAgc,SAAA3L,UAAArB,EAAAhP,EAAAlL,QAAAsK,YACA,iBAAAkiB,GAAAnT,EAAAmT,EACAA,IAAwBnT,EAAAmT,EAAAnT,IAAmBa,EAAAsS,EAAAlT,OAAAkT,EAAAnT,KAC3CA,EAAAvS,KAAAuW,MAAAhE,EAAAoT,EAAAvhB,GACA,IAAAoO,GAAAxS,KAAAujB,KAAAhR,EAAAa,EACA,QAAYlO,KAAA0gB,GAAArH,EAAAhM,GAAApN,GAAAygB,GAAArH,EAAA/L,IAKZ,QAAAqR,GAAAjiB,GACA,GAAAwC,GAAAxC,EAAAwC,OACA,IAAAA,EAAA8c,cAAA9c,EAAA2W,QAAAjG,YAAAlT,EAAAU,QAAA+iB,YAAA,CAGA,OAFAQ,GAAAC,EAAA1hB,KAAAgc,SAAA2F,WAAAnkB,EAAA2c,IAAAwH,WACAC,EAAA5hB,EAAA2W,QAAAnI,YAAAtW,EAAAupB,EAAA,KACAhhB,EAAAT,EAAAsb,QAAA5K,WAA4CjQ,EAAGA,IAAAohB,YAAA,GAAAphB,EAAAqhB,UAC/C,OAAA1pB,GAAA,EAAAuI,EAAAF,EAAAqhB,UAAsC1pB,EAAAuI,EAAAzK,SAAckC,EAAAuI,EAAAvI,GAAA5E,MAAA0Q,KAAAhM,CAEpDsF,GAAAU,QAAA+iB,cACAjhB,EAAA2W,QAAAnjB,MAAA0Q,KAAAud,EAAAG,EAAA,OAGA,QAAAG,GAAAvkB,GACA,IAAAA,EAAAU,QAAAkiB,YAAA,QACA,IAAAjG,GAAA3c,EAAA2c,IAAA6H,EAAAC,EAAAzkB,EAAAU,QAAAic,EAAAjB,MAAAiB,EAAA+H,KAAA,GAAAliB,EAAAxC,EAAAwC,OACA,IAAAgiB,EAAA9rB,QAAA8J,EAAA4c,aAAA,CACA,GAAAjpB,GAAAqM,EAAAyb,QAAA5oB,YAAA8a,GAAA,OAAAA,GAAA,MAAAqU,IACA,gDACAG,EAAAxuB,EAAA+c,WAAAlC,YAAA4T,EAAAzuB,EAAA6a,YAAA2T,CAMA,OALAniB,GAAA+b,WAAAvoB,MAAAmM,MAAA,GACAK,EAAA2c,kBAAA/gB,KAAAoL,IAAAmb,EAAAniB,EAAA+b,WAAAvN,YAAA4T,GACApiB,EAAA0c,aAAA1c,EAAA2c,kBAAAyF,EACApiB,EAAA4c,aAAA5c,EAAA2c,kBAAAqF,EAAA9rB,OAAA,GACA8J,EAAA+b,WAAAvoB,MAAAmM,MAAAK,EAAA0c,aAAA,MACA,EAEA,SAGA,QAAAuF,GAAA/jB,EAAA9F,GACA,MAAAiqB,QAAAnkB,EAAAokB,oBAAAlqB,EAAA8F,EAAAqkB,kBAEA,QAAAb,GAAA1hB,GACA,MAAAwiB,IAAAxiB,EAAAgc,UAAA9X,KAAAse,GAAAxiB,EAAA4b,OAAA1X,KAKA,QAAAue,GAAAjlB,EAAAklB,EAAApB,EAAAqB,GAGA,OAFAC,GAAAC,EAAArlB,EAAAwC,QAAAwc,YAAAsG,EAAAtlB,EAAAwC,QAAAyc,UACAsG,EAAA1B,EAAA7jB,EAAAwC,QAAAxC,EAAA2c,IAAAmH,GACApI,GAAA,GAA2BA,GAAA,GAC3B,GAAA8J,GAAAxlB,EAAAwC,QAAAgc,SAAA7c,WACA,KAAA8jB,EAAAzlB,EAAAklB,EAAAK,EAAAJ,GAAA,KAKA,IAJAC,GAAA,EACAF,KACAQ,EAAA1lB,GACAmhB,EAAAnhB,GACA0b,GAAA1b,EAAAU,QAAAG,cAAA2kB,GAAAxlB,EAAAwC,QAAAgc,SAAA7c,YACAwjB,GAAA,MAUA,IAPAA,GAAA,EAGArB,IACAA,EAAA1lB,KAAAL,IAAAiC,EAAAwC,QAAAgc,SAAA2E,aAAAnjB,EAAAwC,QAAAgc,SAAA5c,aACA,gBAAAkiB,OAAAnT,MACA4U,EAAA1B,EAAA7jB,EAAAwC,QAAAxC,EAAA2c,IAAAmH,GACAyB,EAAAjiB,MAAAtD,EAAAwC,QAAAwc,aAAAuG,EAAAhiB,IAAAvD,EAAAwC,QAAAyc,UACA,MAQA,MALAmG,KACAO,GAAA3lB,EAAA,SAAAA,IACAA,EAAAwC,QAAAwc,aAAAqG,GAAArlB,EAAAwC,QAAAyc,WAAAqG,IACAK,GAAA3lB,EAAA,iBAAAA,IAAAwC,QAAAwc,YAAAhf,EAAAwC,QAAAyc,YAEAmG,EAMA,QAAAK,GAAAzlB,EAAAklB,EAAAK,EAAAJ,GACA,GAAA3iB,GAAAxC,EAAAwC,QAAAma,EAAA3c,EAAA2c,GACA,KAAAna,EAAAlL,QAAA0Z,YAGA,MAFAxO,GAAAwc,YAAAxc,EAAAyc,UAAAtC,EAAAjB,WACAlZ,EAAAsc,WAAA,EAKA,OAAAqG,GAAA,GAAAD,EAAAxsB,QACA6sB,EAAAjiB,KAAAd,EAAAwc,aAAAuG,EAAAhiB,GAAAf,EAAAyc,WADA,CAIAsF,EAAAvkB,KACAklB,IAAkB5hB,KAAAqZ,EAAAjB,MAAAnY,GAAAoZ,EAAAjB,MAAAiB,EAAA+H,OAClB,IAAAN,GAAA5hB,EAAA4b,MAAApoB,MAAA4vB,WAAApjB,EAAA2W,QAAAnI,YAAA,IACAxO,GAAAkb,WAAA1nB,MAAA0Q,KAAA1G,EAAAU,QAAA+iB,YAAAW,EAAA,GAGA,IAAAyB,GAAAC,GACA,IAAA9lB,EAAAU,QAAAkiB,YACA,OAAAhoB,GAAA,EAAqBA,EAAAsqB,EAAAxsB,SAAoBkC,EACzCsqB,EAAAtqB,GAAAmrB,MAAAb,EAAAtqB,GAAA0I,KAAAuiB,IAAwEA,EAAAX,EAAAtqB,GAAA0I,KAExE,IAAAoC,GAAAiX,EAAAjB,MAAAiB,EAAA+H,KACAphB,EAAAlF,KAAAoL,IAAA+b,EAAAjiB,KAAAtD,EAAAU,QAAAslB,eAAArJ,EAAAjB,OACAnY,EAAAnF,KAAAL,IAAA2H,EAAA6f,EAAAhiB,GAAAvD,EAAAU,QAAAslB,eAGA,IAFAxjB,EAAAwc,YAAA1b,KAAAd,EAAAwc,YAAA,KAAA1b,EAAAlF,KAAAoL,IAAAmT,EAAAjB,MAAAlZ,EAAAwc,cACAxc,EAAAyc,UAAA1b,GAAAf,EAAAyc,UAAA1b,EAAA,KAAAA,EAAAnF,KAAAL,IAAA2H,EAAAlD,EAAAyc,YACAgH,GAEA,IADA3iB,EAAAoF,GAAAwd,GAAAvJ,EAAAzV,GAAAyV,EAAArZ,KACAoC,EAAAnC,GAAAme,GAAA/E,EAAAzV,GAAAyV,EAAApZ,QAKA,IAAA4iB,KAAmB7iB,KAAAlF,KAAAoL,IAAAhH,EAAAwc,YAAArC,EAAAjB,OACnBnY,GAAAnF,KAAAL,IAAAyE,EAAAyc,UAAAvZ,IAMA,IALAygB,IAAA,GAAA7iB,MAAA6iB,EAAA,GAAA5iB,MACA6iB,EAAAD,EAAAjB,GAIAe,GACA,OAAArrB,GAAA,EAAqBA,EAAAurB,EAAAztB,SAAmBkC,EAExC,IADA,GAAA2nB,GAAArX,EAAAib,EAAAvrB,GACA2nB,EAAAI,GAAAzb,GAAAyV,EAAAzR,EAAA3H,GAAA,MACA,GAAA8iB,GAAA9D,EAAAG,OAAApf,KAAAtF,IACA,MAAAqoB,EAAAnb,EAAA5H,MACA,CAAgB6iB,EAAArD,OAAAloB,IAAA,EAAuB,OADvCsQ,EAAA3H,GAAA8iB,EAOA,OADAC,GAAA,EACA1rB,EAAA,EAAmBA,EAAAurB,EAAAztB,SAAmBkC,EAAA,CACtC,GAAAsQ,GAAAib,EAAAvrB,EACAsQ,GAAA5H,SAAA4H,EAAA5H,QACA4H,EAAA3H,OAAA2H,EAAA3H,MACA2H,EAAA5H,MAAA4H,EAAA3H,GAAA4iB,EAAArD,OAAAloB,IAAA,GACA0rB,GAAApb,EAAA3H,GAAA2H,EAAA5H,KAEA,IAAA6hB,GAAAmB,GAAA/iB,EAAAD,MAAAd,EAAAwc,aAAAzb,GAAAf,EAAAyc,UAEA,WADAsH,GAAAvmB,EAGAmmB,GAAAK,KAAA,SAAArjB,EAAAC,GAAgC,MAAAD,GAAAG,KAAAF,EAAAE,MAGhC,KACA,GAAA0G,GAAAtV,SAAAwoB,cACK,MAAA7f,IACL,IAAAkG,EAAAD,GAAAgjB,IAAA9jB,EAAAsb,QAAA9nB,MAAAwM,QAAA,QACAikB,EAAAzmB,EAAAsD,EAAAC,EAAA4iB,EAAAN,GACArjB,EAAAsb,QAAA9nB,MAAAwM,QAAA,GACAwH,GAAAtV,SAAAwoB,eAAAlT,KAAAoH,cAAApH,EAAAvJ,OAEA,IAAAimB,GAAApjB,GAAAd,EAAAwc,aAAAzb,GAAAf,EAAAyc,WACAzc,EAAAuc,WAAAvc,EAAAlL,QAAAsK,YAaA,OAVA8kB,KACAlkB,EAAAuc,UAAAvc,EAAAlL,QAAAsK,aACAgf,EAAA5gB,EAAA,MAEAwC,EAAAwc,YAAA1b,EAA+Bd,EAAAyc,UAAA1b,EAE/Bf,EAAA2W,QAAAnjB,MAAAwb,OAAA,GACAmV,EAAA3mB,GACAumB,EAAAvmB,IAEA,GAGA,QAAA2mB,GAAA3mB,GAGA,OAAAwR,GAFAhP,EAAAxC,EAAAwC,QACAokB,EAAApkB,EAAAsb,QAAApJ,UACAD,EAAAjS,EAAAsb,QAAA5K,WAAuDuB,EAAMA,IAAA4P,YAAA,GAAA5P,EAAAoS,QAAA,CAC7D,GAAA9c,GAAA,CACA,GAAA+c,GAAArS,EAAAC,UAAAD,EAAArD,YACAI,GAAAsV,EAAAF,EACAA,EAAAE,MACO,CACP,GAAAzV,GAAA2T,GAAAvQ,EACAjD,GAAAH,EAAAT,OAAAS,EAAAV,IAEA,GAAAoV,GAAAtR,EAAAoS,QAAArV,QAEA,IADA,EAAAA,MAAA8P,GAAA9e,IACAujB,EAAA,YAAAA,EAAA,CACAjE,GAAArN,EAAAoS,QAAArV,EACA,IAAAuV,GAAAtS,EAAAoS,QAAAE,OACA,IAAAA,EAAA,OAAAnsB,GAAA,EAAoCA,EAAAmsB,EAAAruB,SAAoBkC,EACxDmsB,EAAAnsB,GAAA4W,OAAAuV,EAAAnsB,GAAA6Z,KAAArD,eAKA,QAAAmV,GAAAvmB,GACA,GAAApI,GAAAoI,EAAAwC,QAAAsc,WAAAkI,GAAAhnB,EAAAkH,GAAAlH,EAAA2c,IAAA3c,EAAAwC,QAAAwc,aAEAhf,GAAAwC,QAAA2b,MAAAnoB,MAAA2a,IAAA/Y,EAAA,KAGA,QAAAwuB,GAAAD,EAAAjB,GACA,OAAAtqB,GAAA,EAAAF,EAAAwqB,EAAAxsB,QAAA,EAA4CgC,EAAAE,IAAOA,EAAA,CAEnD,OADAqsB,GAAA/B,EAAAtqB,GAAAssB,KAAAnB,EAAAkB,EAAAlB,MAAA,EACA/M,EAAA,EAAAmO,EAAAhB,EAAAztB,OAAyCyuB,EAAAnO,IAAQA,EAAA,CACjD,GAAA9N,GAAAib,EAAAnN,EACAiO,GAAA1jB,IAAA2H,EAAA5H,MAAA2jB,EAAAlB,KACAmB,EAAAruB,MAAwByK,KAAA4H,EAAA5H,KAAAyiB,EAAAxiB,GAAA2H,EAAA3H,GAAAwiB,IACfkB,EAAA1jB,IAAA2H,EAAA5H,MAAA2jB,EAAA3jB,MAAA4H,EAAA3H,GACT2jB,EAAAruB,KAAAqS,IAEA+b,EAAA3jB,KAAA4H,EAAA5H,MACA4jB,EAAAruB,MAA0ByK,KAAA4H,EAAA5H,KAAAC,GAAA0jB,EAAA3jB,OAC1B2jB,EAAA1jB,GAAA2H,EAAA3H,IACA2jB,EAAAruB,MAA0ByK,KAAA2jB,EAAA1jB,GAAAwiB,EAAAxiB,GAAA2H,EAAA3H,GAAAwiB,KAG1BI,EAAAe,EAEA,MAAAf,GAGA,QAAAiB,GAAApnB,GAEA,OADA6I,GAAA7I,EAAAwC,QAAAkE,KAAiCvE,KACjCc,EAAA4F,EAAAsQ,QAAAjG,WAAAtY,EAAA,EAA6CqI,EAAGA,IAAAohB,cAAAzpB,EAChD8L,EAAA1G,EAAAU,QAAAyY,QAAAve,IAAAqI,EAAAokB,WACAllB,EAAAnC,EAAAU,QAAAyY,QAAAve,IAAAqI,EAAA+N,WAEA,QAAYsW,SAAApD,EAAArb,GACZ0e,iBAAA1e,EAAAsQ,QAAAnI,YACAwW,WAAA9gB,EACA+gB,YAAAtlB,EACAulB,aAAA7e,EAAAvR,QAAAqK,aAGA,QAAA8kB,GAAAzmB,EAAAsD,EAAAC,EAAA4iB,EAAAwB,GAOA,QAAA/R,GAAAnB,GACA,GAAA1G,GAAA0G,EAAA4P,WAOA,OANA/G,KAAAsK,IAAA5nB,EAAAwC,QAAAqlB,oBAAApT,GACAA,EAAAze,MAAAwM,QAAA,OACAiS,EAAAoS,QAAA,MAEApS,EAAA1V,WAAAtJ,YAAAgf,GAEA1G,EAdA,GAAA+Z,GAAAV,EAAApnB,GACAwC,EAAAxC,EAAAwC,QAAAogB,EAAA5iB,EAAAU,QAAAkiB,WACAuD,GAAAztB,QAAA4kB,IAAAtd,EAAAwC,QAAAqlB,oBACA1F,GAAA3f,EAAAsb,QACA,IAAAjjB,GAAA2H,EAAAsb,QAAAvX,EAAA1L,EAAAqY,WAaA6U,EAAA5B,EAAAvtB,QAAAovB,EAAA1kB,CA8CA,KA7CAtD,EAAA2c,IAAA6D,KAAAld,EAAAC,EAAA,SAAAvF,GAEA,GADA+pB,KAAAxkB,IAAAykB,IAAAD,EAAA5B,EAAAvtB,SACA8oB,GAAA1hB,EAAA2c,IAAA3e,IAEA,GADA,GAAAA,EAAAwT,QAAAsQ,GAAA9jB,EAAA,GACAA,EAAA+oB,SAAAxgB,KAAA0hB,gBAAA,OAAArtB,GAAA,EAAuEA,EAAAoD,EAAA+oB,QAAAruB,SAAyBkC,EAAA,CAChG,GAAAstB,GAAAlqB,EAAA+oB,QAAAnsB,EACA,IAAAstB,EAAAC,aAAA,CACA,GAAA/M,GAAA7U,EAAA0hB,eACA,WAAA9xB,KAAAilB,EAAAxL,UAAA,CACA,GAAAwY,GAAAjY,GAAA,qCACAiL,GAAArc,WAAAspB,aAAAD,EAAAhN,GACAgN,EAAA/yB,YAAA+lB,GACAA,EAAAgN,EAEA,GAAAE,GAAAlN,EAAA/lB,YAAA8a,GAAA,OAAA+X,EAAAzT,MAAA,yBACAyT,GAAAK,oBAAAD,EAAAE,cAAA,GACAC,EAAAP,EAAAI,EAAAlN,EAAA0M,SAGO,IAAAC,KAAAzkB,MAAA0kB,GAAAD,EAAAxkB,GAAAykB,EAAA,CAGP,KAAAzhB,EAAAsgB,SAAA7oB,GAAAuI,EAAAqP,EAAArP,EACAqc,IAAAoF,GAAAL,GAAAphB,EAAAmiB,YACAC,GAAApiB,EAAAmiB,WAAAjE,EAAAzkB,EAAAU,QAAAsnB,IACAzhB,IAAA8d,gBACO,CAIP,GAAArmB,EAAA+oB,QAAA,OAAA6B,GAAA5P,EAAA,EAAA6P,EAAAtiB,EAA8DsiB,GAAA,GAAA7P,IAAkBA,EAAA6P,IAAAxE,YAChF,GAAAwE,EAAAhC,SAAA7oB,GAAA,OAAA7H,KAAA0yB,EAAAjZ,UAAA,CAAuEgZ,EAAAC,CAAgB,OAEvF,GAAAC,GAAAC,EAAA/oB,EAAAhC,EAAAgqB,EAAAF,EAAAc,EACA,IAAAE,GAAAF,EACA/tB,EAAAmuB,aAAAF,EAAAviB,OACS,CACT,KAAAA,GAAAqiB,GAAAriB,EAAAqP,EAAArP,EACAA,KAAA8d,YAGAyE,EAAAjC,QAAA7oB,IAEAgqB,IAEAzhB,KAAAqP,EAAArP,GAGA,QAAAwiB,GAAA/oB,EAAAhC,EAAA0K,EAAAof,EAAAc,GACA,GACAR,GADAa,EAAAC,GAAAlpB,EAAAhC,GAAAmrB,EAAAF,EAAAG,IACAC,EAAArrB,EAAAsrB,cAAA9mB,EAAAxC,EAAAwC,QAEA+mB,EAAAN,EAAAM,QAAAN,EAAAM,QAAA,KAAAvrB,EAAAurB,SAAA,IAAAvrB,EAAAurB,OACA,MAAAvpB,EAAAU,QAAAkiB,aAAAyG,GAAAE,GAAAvrB,EAAAwrB,WAAAxrB,EAAA+oB,SACA,MAAAoC,EAMA,IAAAP,EAAA,CACAA,EAAAtE,UAAA,IAEA,QAAAvW,GADA0b,GAAA,EAAAC,EAAA,EAAAV,EAAA,KACA/lB,EAAA2lB,EAAA1V,WAA0CjQ,EAAGA,EAAA8K,EAE7C,GADAA,EAAA9K,EAAAohB,YACA,4BAAAluB,KAAA8M,EAAA4G,WAES,CACT,OAAAjP,GAAA,EAAyBA,EAAAoD,EAAA+oB,QAAAruB,SAAyBkC,EAAA,CAClD,GAAAuT,GAAAnQ,EAAA+oB,QAAAnsB,EACA,IAAAuT,EAAAsG,MAAAxR,EAAAiQ,WAAA,CACA/E,EAAAwb,OAAAX,MAAA/lB,GACAwlB,EAAAta,EAAAlL,EAAA2lB,EAAAd,KACA4B,CACA,QAGA,GAAA9uB,GAAAoD,EAAA+oB,QAAAruB,OAAA,CAAyC+wB,GAAA,CAAc,YAXvDb,GAAAnzB,YAAAwN,EAcA2lB,GAAAI,aAAAG,EAAAH,GACAS,GAAAC,GAAA1rB,EAAA+oB,QAAAruB,SACA0vB,EAAAQ,EACAA,EAAA/e,UAAA7L,EAAAwrB,WAAA,IAUA,GAPApB,IACAA,EAAAjY,GAAA,WAAAnS,EAAAwrB,UAAA,sBACApB,EAAA/yB,YAAA8zB,IAGAI,GACAnB,EAAAY,aAAA7Y,GAAA,WAAAoZ,EAAA,8BAAAnB,EAAAlV,YACAlT,EAAAU,QAAAkiB,aAAAyG,EAAA,CACA,GAAAO,GAAAxB,EAAAY,aAAA7Y,GAAA,qEACAnQ,EAAAU,QAAA+iB,YAAAqE,EAAAR,UAAAQ,EAAAP,kBAAA,MACA4B,EAQA,IAPAnpB,EAAAU,QAAA+iB,cAAA2E,EAAA9D,YAAA8D,EAAA9D,eAAAzrB,KAAA+wB,IACA5pB,EAAAU,QAAAkiB,aAAAyG,KAAA,4BACAjB,EAAAM,WAAAkB,EAAAv0B,YACA8a,GAAA,MAAAsU,EAAAzkB,EAAAU,QAAAgI,GACA,8CACA,SAAAof,EAAAN,WAAA,wCACAhlB,EAAA2c,kBAAA,QACAkK,EACA,OAAAQ,GAAA,EAAuBA,EAAA7pB,EAAAU,QAAAyY,QAAAzgB,SAA+BmxB,EAAA,CACtD,GAAA51B,GAAA+L,EAAAU,QAAAyY,QAAA0Q,GAAAvgB,EAAA+f,EAAA5yB,eAAAxC,IAAAo1B,EAAAp1B,EACAqV,IACAsgB,EAAAv0B,YAAA8a,GAAA,OAAA7G,GAAA,iCACAwe,EAAAN,WAAAvzB,GAAA,cAAiE6zB,EAAAL,YAAAxzB,GAAA,QAIjE,GADA8V,KAAAqe,EAAApyB,MAAAyoB,OAAA,GACAzgB,EAAA+oB,SAAAqB,GAAAQ,EAAA,OAAAhuB,GAAA,EAAAkvB,EAAA9rB,EAAA+oB,QAAyEnsB,EAAAkvB,EAAApxB,SAAekC,EAAA,CACxF,GAAAuT,GAAA2b,EAAAlvB,GAAA6Z,EAAAtE,GAAA,OAAAhC,EAAAsG,MAAA,wBACAtG,GAAAoa,oBAAA9T,EAAA+T,cAAA,GACAC,EAAAta,EAAAsG,EAAA2T,EAAAN,GACA3Z,EAAAwb,MACAvB,EAAAY,aAAAvU,EAAAzU,EAAAU,QAAAkiB,aAAA,GAAA5kB,EAAAwT,OAAAoY,EAAAT,GAEAf,EAAA/yB,YAAAof,GACAkR,GAAAxX,EAAA,UAEA,MAAAia,GAGA,QAAAK,GAAAta,EAAAsG,EAAA2T,EAAAN,GACA,GAAA3Z,EAAA4b,UAAA,EACA3B,EAAA9D,YAAA8D,EAAA9D,eAAAzrB,KAAA4b,EACA,IAAAtS,GAAA2lB,EAAAJ,YACAjT,GAAAze,MAAA0Q,KAAAohB,EAAAR,SAAA,KACAnZ,EAAA6b,cACA7nB,GAAA2lB,EAAAP,iBACA9S,EAAAze,MAAAi0B,YAAAnC,EAAAP,iBAAA,MAEA9S,EAAAze,MAAAmM,QAAA,KAEAgM,EAAA6b,cACAvV,EAAAze,MAAAyoB,OAAA,EACAhK,EAAAze,MAAAsf,SAAA,WACAnH,EAAA4b,YAAAtV,EAAAze,MAAA4vB,YAAAkC,EAAAP,iBAAA,OAMA,QAAA7B,GAAA1lB,GACA,GAAAwC,GAAAxC,EAAAwC,QACA0nB,EAAAhnB,GAAAlD,EAAA2c,IAAAxB,IAAA7X,KAAAtD,EAAA2c,IAAAxB,IAAA5X,GAWA,IAVA2mB,GAAAlqB,EAAAU,QAAAypB,wBACAC,EAAApqB,GAEAwC,EAAAkP,OAAA1b,MAAAwM,UAAAwb,YAAAhoB,MAAAwM,QAAA,OACA0nB,EAGA1nB,EAAAub,aAAA/nB,MAAAwM,QAAA,OAFA6nB,EAAArqB,GAKAA,EAAAU,QAAA4pB,oBAAA,CACA,GAAAC,GAAA9Z,EAAAzQ,IAAA2c,IAAAxB,IAAA5lB,KAAA,OACAi1B,EAAAxF,GAAAxiB,EAAAlL,SAAAmzB,EAAAzF,GAAAxiB,EAAAsb,QACAtb,GAAAib,SAAAznB,MAAA2a,IAAAvS,KAAAoL,IAAA,EAAApL,KAAAL,IAAAyE,EAAAlL,QAAAsK,aAAA,GACA2oB,EAAA5Z,IAAA8Z,EAAA9Z,IAAA6Z,EAAA7Z,MAAA,KACAnO,EAAAib,SAAAznB,MAAA0Q,KAAAtI,KAAAoL,IAAA,EAAApL,KAAAL,IAAAyE,EAAAlL,QAAAqK,YAAA,GACA4oB,EAAA7jB,KAAA+jB,EAAA/jB,KAAA8jB,EAAA9jB,OAAA,MAKA,QAAA0jB,GAAApqB,GACA,GAAAwC,GAAAxC,EAAAwC,QAAAmB,EAAA8M,EAAAzQ,IAAA2c,IAAAxB,IAAA5lB,KAAA,MACAiN,GAAAkP,OAAA1b,MAAA0Q,KAAA/C,EAAA+C,KAAA,KACAlE,EAAAkP,OAAA1b,MAAA2a,IAAAhN,EAAAgN,IAAA,KACAnO,EAAAkP,OAAA1b,MAAAwb,OAAApT,KAAAoL,IAAA,EAAA7F,EAAAiN,OAAAjN,EAAAgN,KAAA3Q,EAAAU,QAAAgqB,aAAA,KACAloB,EAAAkP,OAAA1b,MAAAwM,QAAA,GAEAmB,EAAAgnB,OACAnoB,EAAAwb,YAAAhoB,MAAAwM,QAAA,GACAA,EAAAwb,YAAAhoB,MAAA0Q,KAAA/C,EAAAgnB,MAAAjkB,KAAA,KACAlE,EAAAwb,YAAAhoB,MAAA2a,IAAAhN,EAAAgnB,MAAAha,IAAA,KACAnO,EAAAwb,YAAAhoB,MAAAwb,OAAA,KAAA7N,EAAAgnB,MAAA/Z,OAAAjN,EAAAgnB,MAAAha,KAAA,MACYnO,EAAAwb,YAAAhoB,MAAAwM,QAAA,OAIZ,QAAA6nB,GAAArqB,GAKA,QAAArE,GAAA+K,EAAAiK,EAAAxO,EAAAyO,GACA,EAAAD,MAAA,GACAia,EAAAv1B,YAAA8a,GAAA,8DAAuFzJ,EACvF,YAAmCiK,EAAA,eAAoB,MAAAxO,EAAA0oB,EAAAnkB,EAAAvE,GACvD,gBAAmCyO,EAAAD,GAAA,OAGnC,QAAAma,GAAA9sB,EAAA+sB,EAAAC,GAIA,QAAAC,GAAA5nB,EAAA6nB,GACA,MAAAC,GAAAnrB,EAAA4F,GAAA5H,EAAAqF,GAAA,MAAAwjB,EAAAqE,GAJA,GAEAzlB,GAAAC,EAFAmhB,EAAA3f,GAAAyV,EAAA3e,GACAotB,EAAAvE,EAAAjpB,KAAAlF,MA+BA,OAzBA2yB,IAAAC,GAAAzE,GAAAkE,GAAA,QAAAC,EAAAI,EAAAJ,EAAA,SAAA1nB,EAAAC,EAAA1J,GACA,GAAA0xB,GAAA7kB,EAAAC,EAAA6kB,EAAAP,EAAA3nB,EAAA,OACA,IAAAA,GAAAC,EACAgoB,EAAAC,EACA9kB,EAAAC,EAAA6kB,EAAA9kB,SACS,CAET,GADA6kB,EAAAN,EAAA1nB,EAAA,WACA,OAAA1J,EAAA,CAA6B,GAAA4xB,GAAAD,CAAmBA,GAAAD,EAAoBA,EAAAE,EACpE/kB,EAAA8kB,EAAA9kB,KACAC,EAAA4kB,EAAA5kB,MAEA,MAAAokB,GAAA,GAAAznB,IAAAoD,EAAAglB,GACAH,EAAA5a,IAAA6a,EAAA7a,IAAA,IACAhV,EAAA+K,EAAA8kB,EAAA7a,IAAA,KAAA6a,EAAA5a,QACAlK,EAAAglB,EACAF,EAAA5a,OAAA2a,EAAA5a,KAAAhV,EAAA+K,EAAA8kB,EAAA5a,OAAA,KAAA2a,EAAA5a,MAEA,MAAAqa,GAAAznB,GAAA6nB,IAAAzkB,EAAAkkB,KACAplB,GAAA+lB,EAAA7a,IAAAlL,EAAAkL,KAAA6a,EAAA7a,KAAAlL,EAAAkL,KAAA6a,EAAA9kB,KAAAjB,EAAAiB,QACAjB,EAAA+lB,KACA9lB,GAAA6lB,EAAA3a,OAAAlL,EAAAkL,QAAA2a,EAAA3a,QAAAlL,EAAAkL,QAAA2a,EAAA5kB,MAAAjB,EAAAiB,SACAjB,EAAA6lB,GACAG,EAAA,EAAAhlB,MAAAglB,GACA/vB,EAAA+K,EAAA6kB,EAAA5a,IAAAhK,EAAAD,EAAA6kB,EAAA3a,WAEcnL,QAAAC,OA5Cd,GAAAlD,GAAAxC,EAAAwC,QAAAma,EAAA3c,EAAA2c,IAAAxB,EAAAnb,EAAA2c,IAAAxB,IACAyP,EAAAl2B,SAAA0jB,yBACAwM,EAAA+G,EAAA3rB,EAAAwC,SAAAkpB,EAAA9G,EAAAle,KAAAmkB,EAAAroB,EAAA0b,UAAAlN,YAAA4T,EAAAje,KA6CA,IAAAwU,EAAA7X,KAAAtF,MAAAmd,EAAA5X,GAAAvF,KACA8sB,EAAA3P,EAAA7X,KAAAtF,KAAAmd,EAAA7X,KAAAD,GAAA8X,EAAA5X,GAAAF,QACK,CACL,GAAAuoB,GAAA1kB,GAAAyV,EAAAxB,EAAA7X,KAAAtF,MAAA6tB,EAAA3kB,GAAAyV,EAAAxB,EAAA5X,GAAAvF,MACA8tB,EAAA5F,GAAAvJ,EAAAiP,IAAA1F,GAAAvJ,EAAAkP,GACAE,EAAAjB,EAAA3P,EAAA7X,KAAAtF,KAAAmd,EAAA7X,KAAAD,GAAAyoB,EAAAF,EAAAhuB,KAAAlF,OAAA,MAAAgN,IACAsmB,EAAAlB,EAAA3P,EAAA5X,GAAAvF,KAAA8tB,EAAA,OAAA3Q,EAAA5X,GAAAF,IAAAoC,KACAqmB,KACAC,EAAApb,IAAAqb,EAAArb,IAAA,GACAhV,EAAAowB,EAAAplB,MAAAolB,EAAApb,IAAA,KAAAob,EAAAnb,QACAjV,EAAA+vB,EAAAM,EAAArb,IAAAqb,EAAAtlB,KAAAslB,EAAApb,SAEAjV,EAAAowB,EAAAplB,MAAAolB,EAAApb,IAAAqb,EAAAtlB,KAAAqlB,EAAAplB,MAAAolB,EAAAnb,SAGAmb,EAAAnb,OAAAob,EAAArb,KACAhV,EAAA+vB,EAAAK,EAAAnb,OAAA,KAAAob,EAAArb,KAGAsb,GAAAzpB,EAAAub,aAAA6M,GACApoB,EAAAub,aAAA/nB,MAAAwM,QAAA,GAIA,QAAA0pB,GAAAlsB,GACA,GAAAA,EAAAkE,MAAA8F,QAAA,CACA,GAAAxH,GAAAxC,EAAAwC,OACA2T,eAAA3T,EAAA2pB,QACA,IAAAr1B,IAAA,CACA0L,GAAAkP,OAAA1b,MAAAo2B,WAAA5pB,EAAAwb,YAAAhoB,MAAAo2B,WAAA,GACApsB,EAAAU,QAAA2rB,gBAAA,IACA7pB,EAAA2pB,QAAAjW,YAAA,WACA1T,EAAAkP,OAAA1b,MAAAo2B,WAAA5pB,EAAAwb,YAAAhoB,MAAAo2B,YAAAt1B,MAAA,aACOkJ,EAAAU,QAAA2rB,mBAKP,QAAAzL,GAAA5gB,EAAAssB,GACAtsB,EAAA2c,IAAAzd,KAAAqtB,YAAAvsB,EAAA2c,IAAAgE,SAAA3gB,EAAAwC,QAAAyc,WACAjf,EAAAkE,MAAAsY,UAAAgQ,IAAAF,EAAAn1B,GAAAs1B,EAAAzsB,IAGA,QAAAysB,GAAAzsB,GACA,GAAA2c,GAAA3c,EAAA2c,GAEA,IADAA,EAAAgE,SAAAhE,EAAAjB,QAAAiB,EAAAgE,SAAAhE,EAAAjB,SACAiB,EAAAgE,UAAA3gB,EAAAwC,QAAAyc,WAAA,CACA,GAEAyN,GAFAhnB,GAAA,GAAAinB,MAAA3sB,EAAAU,QAAAksB,SACA1oB,EAAA2oB,GAAAlQ,EAAAzd,KAAA4tB,EAAA9sB,EAAA2c,EAAAgE,WACAoM,IACApQ,GAAA6D,KAAA7D,EAAAgE,SAAAviB,KAAAL,IAAA4e,EAAAjB,MAAAiB,EAAA+H,KAAA1kB,EAAAwC,QAAAyc,UAAA,cAAAjhB,GACA,GAAA2e,EAAAgE,UAAA3gB,EAAAwC,QAAAwc,YAAA,CACA,GAAAgO,GAAAhvB,EAAA0iB,MACA1iB,GAAA0iB,OAAAuM,GAAAjtB,EAAAhC,EAAAkG,GAAA,EAEA,QADAgpB,IAAAF,KAAAt0B,QAAAsF,EAAA0iB,OAAAhoB,OACAkC,EAAA,GAAuBsyB,GAAAtyB,EAAAoyB,EAAAt0B,SAAmCkC,EAAAsyB,EAAAF,EAAApyB,IAAAoD,EAAA0iB,OAAA9lB,EAC1DsyB,KACAR,KAAAhnB,KAAAiX,EAAAgE,SAAA+L,EAAAhnB,MACAqnB,EAAAl0B,KAAA6zB,GAA0CjnB,MAAAkX,EAAAgE,SAAAjb,IAAAiX,EAAAgE,SAAA,KAE1C3iB,EAAAyiB,WAAAoM,GAAAlQ,EAAAzd,KAAAgF,OAEAipB,IAAAntB,EAAAhC,EAAAJ,KAAAsG,GACAlG,EAAAyiB,WAAA9D,EAAAgE,SAAA,KAAAkM,GAAAlQ,EAAAzd,KAAAgF,GAAA,IAGA,SADAyY,EAAAgE,UACA,GAAAgM,MAAAjnB,GACAkb,EAAA5gB,IAAAU,QAAA0sB,YACA,GAFA,SAKAL,EAAAr0B,QACAgP,GAAA1H,EAAA,WACA,OAAApF,GAAA,EAAuBA,EAAAmyB,EAAAr0B,SAAoBkC,EAC3CkmB,GAAA1lB,KAAA2xB,EAAAnyB,GAAA6K,MAAAsnB,EAAAnyB,GAAA8K,UASA,QAAA2nB,GAAArtB,EAAAiD,EAAAe,GAGA,OAFAspB,GAAAC,EAAA5Q,EAAA3c,EAAA2c,IACA6Q,EAAAxpB,EAAA,GAAAf,GAAAjD,EAAA2c,IAAAzd,KAAAsN,UAAA,SACAqc,EAAA5lB,EAAwB4lB,EAAA2E,IAAc3E,EAAA,CACtC,GAAAA,GAAAlM,EAAAjB,MAAA,MAAAiB,GAAAjB,KACA,IAAA1d,GAAAkJ,GAAAyV,EAAAkM,EAAA,EACA,IAAA7qB,EAAAyiB,cAAAzc,GAAA6kB,GAAAlM,EAAAgE,UAAA,MAAAkI,EACA,IAAA4E,GAAAC,GAAA1vB,EAAAJ,KAAA,KAAAoC,EAAAU,QAAAitB,UACA,MAAAJ,GAAAD,EAAAG,KACAF,EAAA1E,EAAA,EACAyE,EAAAG,GAGA,MAAAF,GAGA,QAAAT,GAAA9sB,EAAAiD,EAAAe,GACA,GAAA2Y,GAAA3c,EAAA2c,IAAAna,EAAAxC,EAAAwC,OACA,KAAAma,EAAAzd,KAAAqtB,WAAA,QACA,IAAA5oB,GAAA0pB,EAAArtB,EAAAiD,EAAAe,GAAAE,EAAAP,EAAAgZ,EAAAjB,OAAAxU,GAAAyV,EAAAhZ,EAAA,GAAA8c,UAUA,OARAvc,GADAA,EACA2oB,GAAAlQ,EAAAzd,KAAAgF,GADAqoB,GAAA5P,EAAAzd,MAEAyd,EAAA6D,KAAA7c,EAAAV,EAAA,SAAAjF,GACAmvB,GAAAntB,EAAAhC,EAAAJ,KAAAsG,EACA,IAAA0pB,GAAAjqB,GAAAV,EAAA,GAAAU,EAAA,MAAAA,GAAAnB,EAAAwc,aAAArb,EAAAnB,EAAAyc,SACAjhB,GAAAyiB,WAAAmN,EAAAf,GAAAlQ,EAAAzd,KAAAgF,GAAA,OACAP,IAEAK,IAAA2Y,EAAAgE,SAAAhd,GACAO,EAKA,QAAA6f,GAAAvhB,GAAgC,MAAAA,GAAA0b,UAAAxJ,UAChC,QAAAuO,GAAAzgB,GAAiC,MAAAA,GAAA2b,MAAA/M,aAAA5O,EAAA0b,UAAA9M,aACjC,QAAAua,GAAAnpB,GACA,GAAAA,EAAAkd,eAAA,MAAAld,GAAAkd,cACA,IAAAriB,GAAA4uB,GAAAzpB,EAAAyb,QAAA9N,GAAA,YACAna,EAAA1B,OAAAu5B,iBAAAv5B,OAAAu5B,iBAAAxwB,KAAAywB,YACA,OAAAtrB,GAAAkd,gBAAqChZ,KAAAhJ,SAAA1H,EAAAi0B,aACrCtjB,MAAAjJ,SAAA1H,EAAA0oB,eAGA,QAAAqP,GAAA/tB,EAAAhC,EAAAqF,EAAA7K,EAAA0yB,GACA,GAAArxB,GAAA,EAEA,IADArB,KAAAw1B,EAAAhuB,EAAAhC,GACAxF,EAAAy1B,MAAA,CACA,GAAAvnB,GAAAlO,EAAAkO,KAAArD,EAAA7K,EAAA2J,KACA,QAAcuE,OAAAC,MAAAD,EAAAlO,EAAA2J,MAAAwO,IAAAnY,EAAAmY,IAAAC,OAAApY,EAAAoY,QAGd,OAAAjN,GAAAN,GAAuBM,GAAA9J,EAAA,CACvB,GAAAq0B,GAAA11B,EAAAmL,EACA,IAAAuqB,EAAA,KACA,GAAAr0B,GAAA,GAAA8J,IAAA9J,EAAA,GAKA,MAHAqxB,GAAAvnB,EAAAN,EAAA,OAAAA,EAAAM,EAAA,QAAAunB,EACA,QAAAA,GAAAgD,EAAAxC,SAAAwC,IAAAxC,SACA,SAAAR,GAAAgD,EAAArD,YAAAqD,IAAArD,YACYnkB,KAAArD,EAAAM,EAAAuqB,EAAAvnB,MAAAunB,EAAAxnB,KACZC,MAAAhD,EAAAN,EAAA6qB,EAAAxnB,KAAAwnB,EAAAvnB,MACAgK,IAAAud,EAAAvd,IACAC,OAAAsd,EAAAtd,QAGA,QAAAud,GAAAnuB,EAAAhC,GAEA,OADA5J,GAAA4L,EAAAwC,QAAAmd,iBACA/kB,EAAA,EAAmBA,EAAAxG,EAAAsE,SAAkBkC,EAAA,CACrC,GAAAwzB,GAAAh6B,EAAAwG,EACA,IAAAwzB,EAAAxwB,MAAAI,EAAAJ,MAAAwwB,EAAAC,aAAArwB,EAAAqwB,aACAruB,EAAAwC,QAAAgc,SAAA7c,aAAAysB,EAAAjsB,OACAisB,EAAAE,SAAAtwB,EAAAuwB,UAAA,IAAAvwB,EAAAwrB,UACA,MAAA4E,IAIA,QAAAI,GAAAxuB,EAAAhC,GACA,GAAAywB,GAAAN,EAAAnuB,EAAAhC,EACAywB,OAAA7wB,KAAA6wB,EAAAxQ,QAAAwQ,EAAAJ,YAAA,MAGA,QAAAL,GAAAhuB,EAAAhC,GAEA,GAAA0wB,GAAAP,EAAAnuB,EAAAhC,EACA,IAAA0wB,EAAA,MAAAA,GAAAzQ,OAGA,IAAAA,GAAA0Q,EAAA3uB,EAAAhC,GACA5J,EAAA4L,EAAAwC,QAAAmd,iBACAyO,GAAgBxwB,KAAAI,EAAAJ,KAAAuE,MAAAnC,EAAAwC,QAAAgc,SAAA7c,YAChB0sB,YAAArwB,EAAAqwB,YAAApQ,UACAqQ,QAAAtwB,EAAAuwB,UAAA,IAAAvwB,EAAAwrB,UAGA,OAFA,KAAAp1B,EAAAsE,OAAAtE,IAAA4L,EAAAwC,QAAAod,oBAAA,IAAAwO,EACAh6B,EAAAyE,KAAAu1B,GACAnQ,EAGA,QAAA0Q,GAAA3uB,EAAAhC,GAyCA,QAAA4wB,GAAAC,GACA,GAAAle,GAAAke,EAAAle,IAAAme,EAAAne,IAAAmW,EAAA+H,EAAAje,OAAAke,EAAAne,GACAmW,GAAAiI,IAAAjI,EAAAiI,GACA,EAAApe,MAAA,EACA,QAAA/V,GAAAo0B,EAAAt2B,OAAA,EAAsCkC,GAAA,EAAQA,GAAA,GAC9C,GAAAq0B,GAAAD,EAAAp0B,GAAAs0B,EAAAF,EAAAp0B,EAAA,EACA,MAAAq0B,EAAAnI,GAAAnW,EAAAue,KACAve,GAAAse,GAAAC,GAAApI,GACAmI,GAAAte,GAAAmW,GAAAoI,GACA9wB,KAAAL,IAAA+oB,EAAAoI,GAAA9wB,KAAAoL,IAAAmH,EAAAse,IAAAnI,EAAAnW,GAAA,IACAqe,EAAAp0B,GAAAwD,KAAAL,IAAA4S,EAAAse,GACAD,EAAAp0B,EAAA,GAAAwD,KAAAoL,IAAAsd,EAAAoI,EACA,QAIA,MADA,GAAAt0B,IAAkBA,EAAAo0B,EAAAt2B,OAAoBs2B,EAAAn2B,KAAA8X,EAAAmW,KACxBpgB,KAAAmoB,EAAAnoB,KAAAooB,EAAApoB,KACdC,MAAAkoB,EAAAloB,MAAAmoB,EAAApoB,KACAiK,IAAA/V,EAAAgW,OAAA,MAEA,QAAAue,GAAAN,GACAA,EAAAje,OAAAoe,EAAAH,EAAAle,IAAA,GACAke,EAAAle,IAAAqe,EAAAH,EAAAle,KA9DA,IAAA3Q,EAAAU,QAAAG,cAAA7C,EAAAJ,KAAAlF,QAAAsH,EAAAU,QAAA0uB,mBACA,MAAAC,GAAArvB,EAAAhC,EAEA,IAAAwE,GAAAxC,EAAAwC,QAAAyb,EAAAqR,GAAAtxB,EAAAJ,KAAAlF,QACA0wB,EAAAF,GAAAlpB,EAAAhC,EAAAigB,GAAA,GAAAmL,GAaA,IAAAtM,KAAA/S,KAAA/J,EAAAU,QAAAG,cAAAuoB,EAAA3tB,WAAA/C,OAAA,KAGA,OAFAkyB,GAAAl2B,SAAA0jB,yBACAmX,EAAA,GAAAtsB,EAAAmmB,EAAA3tB,WAAA/C,OACAkC,EAAA,EAAA40B,EAAApxB,KAAAujB,KAAA1e,EAAAssB,GAAoDC,EAAA50B,IAAYA,EAAA,CAEhE,OADAwtB,GAAAjY,GAAA,yCACA6I,EAAA,EAAuBuW,EAAAvW,GAAA/V,IAAgB+V,EACvCoP,EAAA/yB,YAAA+zB,EAAAlW,cACAjQ,CAEA2nB,GAAAv1B,YAAA+yB,GAEAgB,EAAA/zB,YAAAu1B,GAGAqB,GAAAzpB,EAAAyb,QAAAmL,EAEA,IAAA0F,GAAA9J,GAAAxiB,EAAAsb,SACAkR,KAAAx2B,EAAA82B,GAAAtxB,EAAAJ,KAAAlF,QAAAq2B,EAAA3F,EAAAhY,YAGAqe,KAAAjtB,EAAAyb,QAAAvC,OAAA0N,GACA6C,GAAAzpB,EAAAyb,QAAAmL,EA2BA,QAAA7iB,GAAA3L,EAAA,EAAwBA,EAAAqjB,EAAAvlB,SAAoBkC,EAAA,GAAA2L,EAAA0X,EAAArjB,GAAA,CAC5C,GAAA6Z,GAAAlO,EAAAsoB,EAAA,IAEA,4BAAA14B,KAAAoQ,EAAAsD,YAAAtD,EAAAmpB,eAAA,CACA,GAAAnpB,EAAA2M,WAAAyc,WAAAlb,EAAAlO,EAAA2M,WACA,IAAA0c,GAAAnb,EAAAib,gBACAE,GAAAl3B,OAAA,IACAm2B,EAAAr2B,EAAAoC,GAAAg0B,EAAAgB,EAAA,IACAf,EAAAhE,UAAA+D,EAAAgB,IAAAl3B,OAAA,KAGAm2B,MAAAr2B,EAAAoC,GAAAg0B,EAAA5J,GAAAvQ,KACAlO,EAAAspB,eAAAhB,EAAAloB,MAAAqe,GAAAze,EAAAspB,cAAAnpB,KAAAooB,EAAApoB,MACAH,EAAAmlB,WAAAmD,EAAAnD,SAAAkD,EAAA5J,GAAAze,EAAAmlB,YAEAvJ,GAAAniB,EAAAwC,QAAAyb,QACA,QAAA1X,GAAA3L,EAAA,EAAwBA,EAAApC,EAAAE,SAAiBkC,GAAA2L,EAAA/N,EAAAoC,MACzCu0B,EAAA5oB,GACAA,EAAAmlB,UAAAyD,EAAA5oB,EAAAmlB,UACAnlB,EAAAskB,WAAAsE,EAAA5oB,EAAAskB,WAEA,OAAAryB,GAGA,QAAA62B,GAAArvB,EAAAhC,GACA,GAAA8xB,GAAA,GAAAC,IAAA/xB,EAAAJ,KAAAW,MAAA,YACAP,GAAAuwB,YAAAuB,EAAAvB,UAAAvwB,EAAAuwB,UACA,IAAAtQ,GAAA0Q,EAAA3uB,EAAA8vB,GACAppB,EAAAqnB,EAAA/tB,EAAA8vB,EAAA,EAAA7R,EAAA,QACAtX,EAAAonB,EAAA/tB,EAAA8vB,EAAA,GAAA7R,EAAA,QACA,QAAYgQ,OAAA,EAAAtd,IAAAjK,EAAAiK,IAAAjK,YAAAkK,OAAAlK,EAAAkK,OAAAzO,OAAAwE,QAAAD,QAAA,KAGZ,QAAAspB,GAAAhwB,EAAAhC,GACA,GAAAiyB,IAAA,CACA,IAAAjyB,EAAAqwB,YAAA,OAAAzzB,GAAA,EAAyCA,EAAAoD,EAAAqwB,cAAsBzzB,EAAA,CAC/D,GAAAs1B,GAAAlyB,EAAAqwB,YAAAzzB,IACAs1B,EAAAhG,WAAA,MAAAgG,EAAA3sB,IAAA2sB,EAAA3sB,IAAAvF,EAAAJ,KAAAlF,SAAAu3B,GAAA,GAEA,GAAAvB,IAAAuB,GAAA9B,EAAAnuB,EAAAhC,EACA,IAAA0wB,GAAA1wB,EAAAJ,KAAAlF,QAAAsH,EAAAU,QAAA0uB,mBACA,MAAArB,GAAA/tB,EAAAhC,IAAAJ,KAAAlF,OAAAg2B,KAAAzQ,QAAA,SAAAtX,KAEA,IAAAyiB,GAAAF,GAAAlpB,EAAAhC,EAAA,SAAAorB,IACA1jB,EAAA0jB,EAAA/zB,YAAA86B,GAAAnwB,EAAAwC,QAAAyb,SAEA,OADAgO,IAAAjsB,EAAAwC,QAAAyb,QAAAmL,GACApE,GAAAtf,GAAAiB,MAAAqe,GAAAhlB,EAAAwC,QAAAsb,SAAApX,KAGA,QAAAwa,GAAAlhB,GACAA,EAAAwC,QAAAmd,iBAAAjnB,OAAAsH,EAAAwC,QAAAod,oBAAA,EACA5f,EAAAwC,QAAAgd,gBAAAxf,EAAAwC,QAAAid,iBAAAzf,EAAAwC,QAAAkd,eAAA,KACA1f,EAAAU,QAAAG,eAAAb,EAAAwC,QAAAwd,gBAAA,GACAhgB,EAAAwC,QAAA4c,aAAA,KAGA,QAAAgR,KAA0B,MAAA97B,QAAA+7B,cAAA37B,SAAAuc,iBAAAvc,SAAAoB,MAAAquB,WAC1B,QAAAmM,KAA0B,MAAAh8B,QAAAse,cAAAle,SAAAuc,iBAAAvc,SAAAoB,MAAA+c,UAG1B,QAAA0d,GAAAvwB,EAAA6mB,EAAAgI,EAAA33B,GACA,GAAA2vB,EAAAE,QAAA,OAAAnsB,GAAA,EAAwCA,EAAAisB,EAAAE,QAAAruB,SAA4BkC,EAAA,GAAAisB,EAAAE,QAAAnsB,GAAA+uB,MAAA,CACpE,GAAAjF,GAAA8L,GAAA3J,EAAAE,QAAAnsB,GACAi0B,GAAAle,KAAA+T,EAAuBmK,EAAAje,QAAA8T,EAEvB,WAAAxtB,EAAA,MAAA23B,EACA33B,OAAA,QACA,IAAAu5B,GAAAzJ,GAAAhnB,EAAA6mB,EAGA,IAFA,SAAA3vB,EAAAu5B,GAAA1M,EAAA/jB,EAAAwC,SACAiuB,GAAAzwB,EAAAwC,QAAAsc,WACA,QAAA5nB,GAAA,UAAAA,EAAA,CACA,GAAAw5B,GAAA1L,GAAAhlB,EAAAwC,QAAA0b,UACAuS,IAAAC,EAAA/f,KAAA,UAAAzZ,EAAA,EAAAo5B,IACA,IAAAK,GAAAD,EAAAhqB,MAAA,UAAAxP,EAAA,EAAAk5B,IACAvB,GAAAnoB,MAAAiqB,EAAwB9B,EAAAloB,OAAAgqB,EAGxB,MADA9B,GAAAle,KAAA8f,EAAqB5B,EAAAje,QAAA6f,EACrB5B,EAKA,QAAA+B,GAAA5wB,EAAAirB,EAAA/zB,GACA,UAAAA,EAAA,MAAA+zB,EACA,IAAAvkB,GAAAukB,EAAAvkB,KAAAiK,EAAAsa,EAAAta,GAEA,YAAAzZ,EACAwP,GAAA0pB,IACAzf,GAAA2f,QACK,aAAAp5B,MAAA,CACL,GAAA25B,GAAA7L,GAAAhlB,EAAAwC,QAAA4b,MACA1X,IAAAmqB,EAAAnqB,KACAiK,GAAAkgB,EAAAlgB,IAGA,GAAAmgB,GAAA9L,GAAAhlB,EAAAwC,QAAA0b,UACA,QAAYxX,OAAAoqB,EAAApqB,KAAAiK,MAAAmgB,EAAAngB,KAGZ,QAAAwa,GAAAnrB,EAAA2D,EAAAzM,EAAA2vB,EAAAqE,GAEA,MADArE,OAAA3f,GAAAlH,EAAA2c,IAAAhZ,EAAA3F,OACAuyB,EAAAvwB,EAAA6mB,EAAAkH,EAAA/tB,EAAA6mB,EAAAljB,EAAAN,GAAA,KAAA6nB,GAAAh0B,GAGA,QAAAuZ,GAAAzQ,EAAA2D,EAAAzM,EAAA2vB,EAAAkK,GAGA,QAAAC,GAAA3tB,EAAAsD,GACA,GAAAgF,GAAAoiB,EAAA/tB,EAAA6mB,EAAAxjB,EAAA0tB,EAAApqB,EAAA,eAEA,OADAA,GAAAgF,EAAAjF,KAAAiF,EAAAhF,MAAkCgF,EAAAhF,MAAAgF,EAAAjF,KAClC6pB,EAAAvwB,EAAA6mB,EAAAlb,EAAAzU,GAEA,QAAA+5B,GAAA5tB,EAAA6tB,GACA,GAAAC,GAAAC,EAAAF,GAAAvqB,EAAAwqB,EAAAE,MAAA,CAUA,OATAhuB,IAAAiuB,GAAAH,IAAAD,GAAAC,EAAAE,MAAAD,EAAAF,EAAA,GAAAG,OACAF,EAAAC,IAAAF,GACA7tB,EAAAkuB,GAAAJ,MAAAE,MAAA,OACA1qB,GAAA,GACOtD,GAAAkuB,GAAAJ,IAAAD,EAAAE,EAAA14B,OAAA,GAAAy4B,EAAAE,MAAAD,EAAAF,EAAA,GAAAG,QACPF,EAAAC,IAAAF,GACA7tB,EAAAiuB,GAAAH,KAAAE,MAAA,EACA1qB,GAAA,GAEAA,GAAAtD,GAAA8tB,EAAA5tB,IAAAF,EAAA8tB,EAAA7tB,KAAA0tB,EAAA3tB,EAAA,GACA2tB,EAAA3tB,EAAAsD,GAnBAkgB,KAAA3f,GAAAlH,EAAA2c,IAAAhZ,EAAA3F,MACA+yB,MAAA/C,EAAAhuB,EAAA6mB,GAoBA,IAAAuK,GAAA9F,GAAAzE,GAAAxjB,EAAAM,EAAAN,EACA,KAAA+tB,EAAA,MAAAJ,GAAA3tB,EACA,IAAA6tB,GAAAM,GAAAJ,EAAA/tB,GACA0E,EAAAkpB,EAAA5tB,EAAA6tB,EAEA,OADA,OAAAO,KAAA1pB,EAAA4iB,MAAAsG,EAAA5tB,EAAAouB,KACA1pB,EAGA,QAAA2pB,IAAA1zB,EAAAqF,EAAAsuB,EAAAC,GACA,GAAAjuB,GAAA,GAAAiC,IAAA5H,EAAAqF,EAGA,OAFAM,GAAAiuB,OACAD,IAAAhuB,EAAAguB,SAAA,GACAhuB,EAIA,QAAAoV,IAAA/Y,EAAA6xB,EAAAC,GACA,GAAAnV,GAAA3c,EAAA2c,GAEA,IADAmV,GAAA9xB,EAAAwC,QAAAsc,WACA,EAAAgT,EAAA,MAAAJ,IAAA/U,EAAAjB,MAAA,QACA,IAAAhT,GAAAsb,GAAArH,EAAAmV,GAAAtN,EAAA7H,EAAAjB,MAAAiB,EAAA+H,KAAA,CACA,IAAAhc,EAAA8b,EACA,MAAAkN,IAAA/U,EAAAjB,MAAAiB,EAAA+H,KAAA,EAAAxd,GAAAyV,EAAA6H,GAAA5mB,KAAAlF,QAAA,IAGA,KAFA,EAAAm5B,MAAA,KAEW,CACX,GAAAhL,GAAA3f,GAAAyV,EAAAjU,GACAY,EAAAyoB,GAAA/xB,EAAA6mB,EAAAne,EAAAmpB,EAAAC,GACAvP,EAAAI,GAAAkE,GACAmL,EAAAzP,KAAAG,MACA,KAAAH,KAAAjZ,EAAAjG,GAAA2uB,EAAA1uB,KAAAD,IAAAiG,EAAAjG,IAAA2uB,EAAA1uB,KAAAD,IAAAiG,EAAAsoB,KAAA,GAGA,MAAAtoB,EAFAZ,GAAAspB,EAAAzuB,GAAAvF,MAMA,QAAA+zB,IAAA/xB,EAAA6mB,EAAAne,EAAAmpB,EAAAC,GAKA,QAAAG,GAAA5uB,GACA,GAAA6sB,GAAAzf,EAAAzQ,EAAA4F,GAAA8C,EAAArF,GAAA,OACAwjB,EAAAkK,EAEA,OADAmB,IAAA,EACAC,EAAAjC,EAAAtf,OAAAsf,EAAAxpB,KAAA0rB,EACAD,EAAAjC,EAAAvf,IAAAuf,EAAAxpB,KAAA0rB,GACAF,GAAA,EACAhC,EAAAxpB,MAXA,GAAAyrB,GAAAL,EAAA9K,GAAAhnB,EAAA6mB,GACAqL,GAAA,EAAAE,EAAA,EAAApyB,EAAAwC,QAAAlL,QAAAqK,YACAovB,EAAA/C,EAAAhuB,EAAA6mB,GAYAwL,EAAA/G,GAAAzE,GAAAyL,EAAAzL,EAAAjpB,KAAAlF,OACA4K,EAAAivB,GAAA1L,GAAAtjB,EAAAivB,GAAA3L,GACA4L,EAAAR,EAAA3uB,GAAAovB,EAAAR,EAAAS,EAAAV,EAAA1uB,GAAAqvB,EAAAV,CAEA,IAAAL,EAAAc,EAAA,MAAAjB,IAAAhpB,EAAAnF,EAAAqvB,EAAA,EAEA,QAAW,CACX,GAAAP,EAAA9uB,GAAAD,GAAAC,GAAAsvB,GAAAhM,EAAAvjB,EAAA,MAAAC,EAAAD,EAAA,CAGA,IAFA,GAAAD,GAAAovB,EAAAZ,GAAAc,EAAAd,KAAAY,EAAAnvB,EAAAC,EACAuvB,EAAAjB,GAAAxuB,GAAAC,EAAAmvB,EAAAE,GACAI,GAAAlM,EAAAjpB,KAAAwJ,OAAA/D,QACA,IAAAM,GAAA+tB,GAAAhpB,EAAArF,KAAAC,EAAAovB,EAAAE,EACA,EAAAE,EAAA,GAAAA,EAAA,IACA,OAAAnvB,GAEA,GAAAqvB,GAAA50B,KAAAujB,KAAA2Q,EAAA,GAAAW,EAAA3vB,EAAA0vB,CACA,IAAAX,EAAA,CACAY,EAAA3vB,CACA,QAAA1I,GAAA,EAAuBo4B,EAAAp4B,IAAUA,EAAAq4B,EAAAJ,GAAAhM,EAAAoM,EAAA,GAEjC,GAAAC,GAAAjB,EAAAgB,EACAC,GAAArB,GAAwBtuB,EAAA0vB,EAAYN,EAAAO,GAAeN,EAAAV,KAAAS,GAAA,KAAwCL,EAAAU,IAC/E1vB,EAAA2vB,EAAcR,EAAAS,EAAiBR,EAAAR,EAAyBI,GAAAU,IAKpE,QAAA1R,IAAA9e,GACA,SAAAA,EAAAid,iBAAA,MAAAjd,GAAAid,gBACA,UAAA0T,GAAA,CACAA,GAAAhjB,GAAA,MAGA,QAAAvV,GAAA,EAAqB,GAAAA,IAAQA,EAC7Bu4B,GAAA99B,YAAAX,SAAAY,eAAA,MACA69B,GAAA99B,YAAA8a,GAAA,MAEAgjB,IAAA99B,YAAAX,SAAAY,eAAA,MAEA22B,GAAAzpB,EAAAyb,QAAAkV,GACA,IAAA3hB,GAAA2hB,GAAA/hB,aAAA,EAGA,OAFAI,GAAA,IAAAhP,EAAAid,iBAAAjO,GACA2Q,GAAA3f,EAAAyb,SACAzM,GAAA,EAGA,QAAAiQ,IAAAjf,GACA,SAAAA,EAAAgd,gBAAA,MAAAhd,GAAAgd,eACA,IAAAhY,GAAA2I,GAAA,YACAiZ,EAAAjZ,GAAA,OAAA3I,GACAykB,IAAAzpB,EAAAyb,QAAAmL,EACA,IAAAjnB,GAAAqF,EAAAwJ,WAEA,OADA7O,GAAA,IAAAK,EAAAgd,gBAAArd,GACAA,GAAA,GAWA,QAAAixB,IAAApzB,GACAA,EAAA6gB,OAGAqE,WACAmO,aAAA,EACAC,YAAA,KACAC,cAAA,KACAC,YAAA,KACAC,kBAAA,EACA7Z,gBAAA,EACA8Z,eAAA,EACAC,iBAAA,EACA1/B,KAAA2/B,IAEAC,OAAAC,OAGA,QAAAC,IAAA/zB,GACA,GAAAg0B,GAAAh0B,EAAA6gB,MAAAlE,EAAA3c,EAAA2c,IAAAna,EAAAxC,EAAAwC,OAIA,IAHAxC,EAAA6gB,MAAA,KAEAmT,EAAAN,eAAA1S,EAAAhhB,GACAwC,EAAAwd,iBAAAhgB,EAAAU,QAAAG,cAAA2B,EAAAsd,QAAA,CACA,GAAA3d,GAAA6tB,EAAAhwB,EAAAwC,EAAAsd,QACAtd,GAAA4b,MAAApoB,MAAA6oB,SAAAzgB,KAAAoL,IAAA,EAAArH,EAAA,QACAK,EAAAwd,gBAAA,CACA,IAAAiU,GAAA71B,KAAAoL,IAAA,EAAAhH,EAAA4b,MAAAiJ,WAAA7kB,EAAA4b,MAAApN,YAAAxO,EAAAgc,SAAA7c,YACAsyB,GAAAtX,EAAAwH,aAAA6P,EAAAL,iBACAO,GAAAl0B,EAAA5B,KAAAL,IAAAyE,EAAAgc,SAAA2F,WAAA8P,IAAA,GAEA,GAAAE,GAAA/O,CACA,IAAA4O,EAAAL,gBACAQ,EAAAH,EAAAL,oBACK,IAAAK,EAAAP,kBAAAjxB,EAAAgc,SAAA5c,aAAA,CACL,GAAAqpB,GAAAxa,EAAAzQ,EAAA2c,EAAAxB,IAAA5lB,KACA4+B,GAAAC,GAAAp0B,EAAAirB,EAAAvkB,KAAAukB,EAAAta,IAAAsa,EAAAvkB,KAAAukB,EAAAra,QAOA,IALAojB,EAAA9O,QAAAxsB,QAAAs7B,EAAAX,aAAAc,GAAA,MAAAA,EAAAthB,aACAuS,EAAAH,EAAAjlB,EAAAg0B,EAAA9O,QAAAiP,KAAAthB,UAAAmhB,EAAAX,aACArzB,EAAAwC,QAAAgc,SAAApN,eAAApR,EAAA2c,IAAA9J,UAAA7S,EAAAwC,QAAAgc,SAAA3L,aAEAuS,GAAA4O,EAAAP,kBAAA/N,EAAA1lB,GACAg0B,EAAAL,gBAAA,CACA,GAAAhjB,GAAAvS,KAAAoL,IAAA,EAAApL,KAAAL,IAAAyE,EAAAgc,SAAA2E,aAAA3gB,EAAAgc,SAAA5c,aAAAuyB,EAAAthB,YACAnM,EAAAtI,KAAAoL,IAAA,EAAApL,KAAAL,IAAAyE,EAAAgc,SAAA6E,YAAA7gB,EAAAgc,SAAA7c,YAAAwyB,EAAAhQ,YACA3hB,GAAAgc,SAAA3L,UAAArQ,EAAAmb,WAAA9K,UAAA8J,EAAA9J,UAAAlC,EACAnO,EAAAgc,SAAA2F,WAAA3hB,EAAAkb,WAAAyG,WAAAxH,EAAAwH,WAAAzd,EACAub,EAAAjiB,GACAg0B,EAAAK,aACAC,GAAAt0B,EAAA2F,GAAA3F,EAAA2c,IAAAqX,EAAAK,YAAA/wB,MACAqC,GAAA3F,EAAA2c,IAAAqX,EAAAK,YAAA9wB,IAAAywB,EAAAK,YAAAE,YACKJ,IACLK,GAAAx0B,EAEAg0B,GAAAP,kBAAAvH,EAAAlsB,GAEAA,EAAAkE,MAAA8F,SAAAgqB,EAAAV,aACAvW,GAAA/c,EAAAg0B,EAAAT,cAEA,IAAAkB,GAAAT,EAAAU,mBAAAC,EAAAX,EAAAY,oBACA,IAAAH,EAAA,OAAA75B,GAAA,EAA+BA,EAAA65B,EAAA/7B,SAAmBkC,EAClD65B,EAAA75B,GAAAyH,MAAA3J,QAAAua,GAAAwhB,EAAA75B,GAAA,OACA,IAAA+5B,EAAA,OAAA/5B,GAAA,EAAiCA,EAAA+5B,EAAAj8B,SAAqBkC,EACtD+5B,EAAA/5B,GAAAyH,MAAA3J,QAAAua,GAAA0hB,EAAA/5B,GAAA,SAEA,IAAAi6B,EAQA,MAPAhB,KACAgB,EAAAf,GACAA,GAAA,MAEAE,EAAAR,aACAvgB,GAAAjT,EAAA,SAAAA,EAAAg0B,EAAAR,aACAQ,EAAApa,gBAAA3G,GAAAjT,EAAA,iBAAAA,GACA60B,EAAA,OAAAj6B,GAAA,EAAgCA,EAAAi6B,EAAAn8B,SAAoBkC,EAAAi6B,EAAAj6B,KAIpD,QAAA8M,IAAAotB,EAAA18B,GACA,kBACA,GAAA4H,GAAA80B,GAAA15B,KAAA25B,GAAA/0B,EAAA6gB,KACAkU,IAAA3B,GAAApzB,EACA,KAAW,GAAAg1B,GAAA58B,EAAA68B,MAAAj1B,EAAAN,WACX,QAAeq1B,GAAAhB,GAAA/zB,GACf,MAAAg1B,IAGA,QAAAE,IAAA98B,GACA,kBACA,GAAA48B,GAAAD,EAAA35B,KAAA4E,KAAA5E,KAAA4E,GAAA6gB,KACAkU,IAAA3B,GAAAh4B,KAAA4E,GACA,KAAWg1B,EAAA58B,EAAA68B,MAAA75B,KAAAsE,WACX,QAAeq1B,GAAAhB,GAAA34B,KAAA4E,IACf,MAAAg1B,IAGA,QAAAG,IAAAn1B,EAAA5H,GACA,GAAA48B,GAAAD,GAAA/0B,EAAA6gB,KACAkU,IAAA3B,GAAApzB,EACA,KAASg1B,EAAA58B,IACT,QAAa28B,GAAAhB,GAAA/zB,GACb,MAAAg1B,GAGA,QAAAlU,IAAA9gB,EAAAsD,EAAAC,EAAA6xB,GACA,MAAA9xB,MAAAtD,EAAA2c,IAAAjB,OACA,MAAAnY,MAAAvD,EAAA2c,IAAAjB,MAAA1b,EAAA2c,IAAA+H,MACA1kB,EAAA6gB,MAAAqE,QAAArsB,MAA2ByK,OAAAC,KAAAwiB,KAAAqP,IAK3B,QAAAC,IAAAr1B,GACAA,EAAAwC,QAAA+c,aACAvf,EAAAwC,QAAAyT,KAAAuW,IAAAxsB,EAAAU,QAAA40B,aAAA,WACAC,GAAAv1B,GACAA,EAAAkE,MAAA8F,SAAAqrB,GAAAr1B,KAIA,QAAAw1B,IAAAx1B,GAGA,QAAA3L,KACA,GAAA04B,GAAAwI,GAAAv1B,EACA+sB,IAAA0I,GACYz1B,EAAAwC,QAAA+c,aAAA,EAA+B8V,GAAAr1B,KADXy1B,GAAA,EAAcz1B,EAAAwC,QAAAyT,KAAAuW,IAAA,GAAAn4B,IAJ9C,GAAAohC,IAAA,CACAz1B,GAAAwC,QAAA+c,aAAA,EAMAvf,EAAAwC,QAAAyT,KAAAuW,IAAA,GAAAn4B,GAQA,QAAAkhC,IAAAv1B,GACA,GAAAO,GAAAP,EAAAwC,QAAAjC,MAAA8e,EAAArf,EAAAwC,QAAA6c,UAAA1C,EAAA3c,EAAA2c,IAAAxB,EAAAwB,EAAAxB,GACA,KAAAnb,EAAAkE,MAAA8F,SAAA0rB,GAAAn1B,IAAAo1B,GAAA31B,MAAAU,QAAAk1B,aAAA,QACA51B,GAAAkE,MAAAmY,eAAArc,EAAAkE,MAAA2xB,gBACAt1B,EAAAI,MAAAJ,EAAAI,MAAAm1B,UAAA,EAAAv1B,EAAAI,MAAAjI,OAAA,GACAsH,EAAAkE,MAAA2xB,eAAA,EAEA,IAAAj4B,GAAA2C,EAAAI,KACA,IAAA/C,GAAAyhB,GAAAnc,GAAAiY,EAAA7X,KAAA6X,EAAA5X,IAAA,QACA,IAAAwyB,KAAAtG,IAAAzvB,EAAAwC,QAAAwzB,oBAAAp4B,EAEA,MADAmf,IAAA/c,GAAA,IACA,CAGA,IAAA+0B,IAAA/0B,EAAA6gB,KACAkU,IAAA3B,GAAApzB,GACAmb,EAAAviB,OAAA,CAEA,KADA,GAAAq9B,GAAA,EAAAv7B,EAAA0D,KAAAL,IAAAshB,EAAA3mB,OAAAkF,EAAAlF,QACAgC,EAAAu7B,GAAA5W,EAAA6W,WAAAD,IAAAr4B,EAAAs4B,WAAAD,OACA,IAAA3yB,GAAA6X,EAAA7X,KAAAC,EAAA4X,EAAA5X,GACA4yB,EAAAv4B,EAAAW,MAAA03B,EACAA,GAAA5W,EAAA3mB,OACA4K,EAAAsC,GAAAtC,EAAAtF,KAAAsF,EAAAD,IAAAgc,EAAA3mB,OAAAu9B,IACAj2B,EAAAkE,MAAAiY,WAAAjZ,GAAAI,EAAAC,KAAAvD,EAAAkE,MAAAmY,gBACA9Y,EAAAqC,GAAArC,EAAAvF,KAAAI,KAAAL,IAAAmJ,GAAAyV,EAAApZ,EAAAvF,MAAAJ,KAAAlF,OAAA6K,EAAAF,GAAA8yB,EAAAz9B,SAEA,IAAA46B,GAAAtzB,EAAA6gB,MAAAyS,YACA8C,GAAuB9yB,OAAAC,KAAA3F,KAAAy4B,GAAAF,GACvBxxB,OAAA3E,EAAAkE,MAAAmY,cAAA,QAAArc,EAAAkE,MAAAoY,YAAA,eAIA,IAHAga,GAAAt2B,EAAA2c,IAAAyZ,EAAA,OACAp2B,EAAA6gB,MAAAyS,cACA3N,GAAA3lB,EAAA,YAAAA,EAAAo2B,GACAD,IAAAn2B,EAAAkE,MAAAmY,eAAArc,EAAAU,QAAA61B,eACAv2B,EAAAU,QAAA81B,aAAArb,EAAA5lB,KAAA8N,GAAA,KACA,GAAAozB,GAAAz2B,EAAA02B,UAAAvb,EAAA5lB,MAAAghC,aACA,IAAAE,EAAA,OAAA77B,GAAA,EAAmCA,EAAA67B,EAAA/9B,OAAqBkC,IACxD,GAAAu7B,EAAAj7B,QAAAu7B,EAAArvB,OAAAxM,IAAA,IACAqF,GAAAD,EAAAmb,EAAA5lB,KAAAyI,KAAA,QACA,QAQA,MAJAJ,GAAAlF,OAAA,KAAAkF,EAAA1C,QAAA,SAAAqF,EAAAI,MAAAX,EAAAwC,QAAA6c,UAAA,GACArf,EAAAwC,QAAA6c,UAAAzhB,EACAm3B,GAAAhB,GAAA/zB,GACAA,EAAAkE,MAAAmY,cAAArc,EAAAkE,MAAAoY,aAAA,GACA,EAGA,QAAAS,IAAA/c,EAAA22B,GACA,GAAAC,GAAAC,EAAAla,EAAA3c,EAAA2c,GACA,IAAAzZ,GAAAyZ,EAAAxB,IAAA7X,KAAAqZ,EAAAxB,IAAA5X,IAQKozB,IACL32B,EAAAwC,QAAA6c,UAAArf,EAAAwC,QAAAjC,MAAAI,MAAA,GACAo1B,KAAAtG,KAAAzvB,EAAAwC,QAAAwzB,kBAAA,WAVA,CACAh2B,EAAAwC,QAAA6c,UAAA,GACAuX,EAAAE,KACAna,EAAAxB,IAAA5X,GAAAvF,KAAA2e,EAAAxB,IAAA7X,KAAAtF,KAAA,MAAA64B,EAAA72B,EAAA8G,gBAAApO,OAAA,IACA,IAAA2c,GAAAuhB,EAAA,IAAAC,GAAA72B,EAAA8G,cACA9G,GAAAwC,QAAAjC,MAAAI,MAAA0U,EACArV,EAAAkE,MAAA8F,SAAA+sB,GAAA/2B,EAAAwC,QAAAjC,OACAw1B,KAAAtG,KAAAzvB,EAAAwC,QAAAwzB,kBAAA3gB,GAKArV,EAAAwC,QAAAqd,oBAAA+W,EAGA,QAAA7a,IAAA/b,GACA,YAAAA,EAAAU,QAAAs2B,UAAAlb,IAAApnB,SAAAwoB,eAAAld,EAAAwC,QAAAjC,OACAP,EAAAwC,QAAAjC,MAAAE,QAGA,QAAAw2B,IAAAj3B,GACAA,EAAAkE,MAAA8F,UAA4B+R,GAAA/b,GAAgBmS,GAAAnS,IAG5C,QAAA21B,IAAA31B,GACA,MAAAA,GAAAU,QAAAs2B,UAAAh3B,EAAA2c,IAAAua,SAKA,QAAAla,IAAAhd,GAuCA,QAAAm3B,KAAwBn3B,EAAAkE,MAAA8F,SAAAlR,WAAA3B,GAAA4kB,GAAA/b,GAAA,GAOxB,QAAAo3B,KACA,MAAAC,MAAAv+B,WAAA,WACAu+B,EAAA,KAEAxuB,EAAA2W,gBAAA3W,EAAA4W,iBAAA5W,EAAA6W,eAAA4X,GAAA,KACApW,EAAAlhB,GACAm1B,GAAAn1B,EAAA7I,GAAA2pB,GAAA9gB,KACO,MAMP,QAAAu3B,KACA,OAAAljC,GAAAwU,EAAAvR,QAAAyH,WAAwC1K,MAAAK,SAAAoB,KAAyBzB,IAAA0K,YACjE1K,EAAAyE,WAAAy+B,EAAA,KACA3/B,GAAAtD,OAAA,SAAA8iC,GAcA,QAAAI,GAAAn6B,GACAo6B,GAAAz3B,EAAA3C,IAAA2C,EAAAU,QAAAg3B,aAAA13B,EAAAU,QAAAg3B,YAAA13B,EAAA23B,GAAAt6B,KACAu6B,GAAAv6B,GA4BA,QAAAw6B,GAAAx6B,GACAwL,EAAAgX,sBACAhX,EAAAwW,UAAA,GACAxW,EAAAgX,qBAAA,EACAhX,EAAAtI,MAAAI,MAAAX,EAAA8G,eACAiwB,GAAAluB,EAAAtI,QAEA,OAAAlD,EAAAnI,OAAA8K,EAAAkE,MAAAoY,aAAA,GAhHA,GAAAzT,GAAA7I,EAAAwC,OACA1L,IAAA+R,EAAA2V,SAAA,YAAA9W,GAAA1H,EAAA83B,KACAhb,GACAhmB,GAAA+R,EAAA2V,SAAA,WAAA9W,GAAA1H,EAAA,SAAA3C,GACA,IAAAo6B,GAAAz3B,EAAA3C,GAAA,CACA,GAAAsG,GAAAo0B,GAAA/3B,EAAA3C,EACA,IAAAsG,IAAAq0B,GAAAh4B,EAAA3C,KAAA46B,GAAAj4B,EAAAwC,QAAAnF,GAAA,CACA66B,GAAA76B,EACA,IAAA4N,GAAAktB,GAAAjxB,GAAAlH,EAAA2c,IAAAhZ,EAAA3F,MAAAJ,KAAA+F,EACAy0B,IAAAp4B,EAAA2c,IAAA1R,EAAA3H,KAAA2H,EAAA1H,SAGAzM,GAAA+R,EAAA2V,SAAA,oBAAAnhB,GAA8Co6B,GAAAz3B,EAAA3C,IAAA66B,GAAA76B,KAC9CvG,GAAA+R,EAAAqV,UAAA,uBAAA7gB,GACA46B,GAAApvB,EAAAxL,IAAA66B,GAAA76B,KAKAg7B,IAAAvhC,GAAA+R,EAAA2V,SAAA,uBAAAnhB,GAAwEi7B,GAAAt4B,EAAA3C,KAExEvG,GAAA+R,EAAA2V,SAAA,oBACA3V,EAAA2V,SAAA5c,eACA22B,GAAAv4B,EAAA6I,EAAA2V,SAAA3L,WACAqhB,GAAAl0B,EAAA6I,EAAA2V,SAAA2F,YAAA,GACAlR,GAAAjT,EAAA,SAAAA,MAGAlJ,GAAA+R,EAAA8U,WAAA,oBACA9U,EAAA2V,SAAA5c,cAAA22B,GAAAv4B,EAAA6I,EAAA8U,WAAA9K,aAEA/b,GAAA+R,EAAA6U,WAAA,oBACA7U,EAAA2V,SAAA5c,cAAAsyB,GAAAl0B,EAAA6I,EAAA6U,WAAAyG,cAGArtB,GAAA+R,EAAA2V,SAAA,sBAAAnhB,GAA6Cm7B,GAAAx4B,EAAA3C,KAC7CvG,GAAA+R,EAAA2V,SAAA,0BAAAnhB,GAAiDm7B,GAAAx4B,EAAA3C,KAGjDvG,GAAA+R,EAAA6U,WAAA,YAAAyZ,GACArgC,GAAA+R,EAAA8U,WAAA,YAAAwZ,GAEArgC,GAAA+R,EAAAvR,QAAA,oBAAwCuR,EAAAvR,QAAAub,UAAAhK,EAAAvR,QAAA6sB,WAAA,GAExC,IAAAkT,EAUAvgC,IAAAxC,OAAA,SAAA8iC,GASAt+B,WAAAy+B,EAAA,KAEAzgC,GAAA+R,EAAAtI,MAAA,QAAAmH,GAAA1H,EAAAy4B,KACA3hC,GAAA+R,EAAAtI,MAAA,mBACAw1B,KAAAtG,IAAAzvB,EAAAwC,QAAAwzB,oBAAAh2B,EAAAwC,QAAAwzB,kBAAA,MACAR,GAAAx1B,KAEAlJ,GAAA+R,EAAAtI,MAAA,UAAAmH,GAAA1H,EAAA04B,KACA5hC,GAAA+R,EAAAtI,MAAA,WAAAmH,GAAA1H,EAAA24B,KACA7hC,GAAA+R,EAAAtI,MAAA,QAAApJ,GAAAgb,GAAAnS,IACAlJ,GAAA+R,EAAAtI,MAAA,OAAApJ,GAAA+a,GAAAlS,IAMAA,EAAAU,QAAAk4B,WACA9hC,GAAA+R,EAAA2V,SAAA,qBAAAnhB,GAA8Cw7B,GAAA74B,EAAA3C,KAC9CvG,GAAA+R,EAAA2V,SAAA,YAAAgZ,GACA1gC,GAAA+R,EAAA2V,SAAA,WAAAgZ,GACA1gC,GAAA+R,EAAA2V,SAAA,OAAA9W,GAAA1H,EAAA84B,MAEAhiC,GAAA+R,EAAA2V,SAAA,iBAAAnhB,GACA46B,GAAApvB,EAAAxL,KACA0e,GAAA/b,GACAw1B,GAAAx1B,MAEAlJ,GAAA+R,EAAAtI,MAAA,mBAIA,GAAA+c,KAAAtd,EAAAkE,MAAA2xB,iBAAA,GAAAlJ,MAAA3sB,EAAAkE,MAAA60B,eAAA,MACA,GAAAtzB,GAAAoD,EAAAtI,MAAAy4B,eAAAtzB,EAAAmD,EAAAtI,MAAA04B,YACApwB,GAAAtI,MAAAI,OAAA,IACAkI,EAAAtI,MAAAy4B,eAAAvzB,EACAoD,EAAAtI,MAAA04B,aAAAvzB,EACA1F,EAAAkE,MAAA2xB,eAAA,EAEA71B,EAAAkE,MAAAmY,eAAA,EACAmZ,GAAAx1B,KAYAlJ,GAAA+R,EAAAtI,MAAA,MAAAs3B,GACA/gC,GAAA+R,EAAAtI,MAAA,OAAAs3B,GAGAjZ,IAAA9nB,GAAA+R,EAAAuV,MAAA,qBACA1pB,SAAAwoB,eAAArU,EAAAtI,OAAAsI,EAAAtI,MAAA24B,OACAnd,GAAA/b,KAIA,QAAAi4B,IAAAz1B,EAAAnF,GACA,OAAA4F,GAAAk2B,GAAA97B,GAA6B4F,GAAAT,EAAAlL,QAAsB2L,IAAAlE,WACnD,IAAAkE,KAAAulB,cAAAvlB,EAAAlE,YAAAyD,EAAA4b,OAAAnb,GAAAT,EAAA2b,MAAA,SAIA,QAAA4Z,IAAA/3B,EAAA3C,EAAA+7B,GACA,GAAA52B,GAAAxC,EAAAwC,OACA,KAAA42B,EAAA,CACA,GAAA97B,GAAA67B,GAAA97B,EACA,IAAAC,GAAAkF,EAAAkb,YAAApgB,GAAAkF,EAAAkb,WAAAxK,YACA5V,GAAAkF,EAAAmb,YAAArgB,GAAAkF,EAAAmb,WAAAzK,YACA5V,GAAAkF,EAAAob,iBAAAtgB,GAAAkF,EAAAqb,aAAA,YAEA,GAAAgU,GAAAC,EAAAuH,EAAArU,GAAAxiB,EAAA0b,UAEA,KAAS2T,EAAAx0B,EAAAoY,QAAeqc,EAAAz0B,EAAAmY,QAAiB,MAAAnY,GAAY,YACrD,MAAA0b,IAAA/Y,EAAA6xB,EAAAwH,EAAA3yB,KAAAorB,EAAAuH,EAAA1oB,KAIA,QAAAmnB,IAAAz6B,GA+EA,QAAAi8B,GAAA/yB,GACA,IAAArD,GAAAq2B,EAAAhzB,GAAA,CAGA,GAFAgzB,EAAAhzB,EAEA,UAAArR,EAEA,WADAkjC,IAAAp4B,EAAA2c,IAAAhX,GAAAgX,EAAAlX,GAAAc,EAMA,IAFAizB,EAAA7zB,GAAAgX,EAAA6c,GACAC,EAAA9zB,GAAAgX,EAAA8c,GACA,UAAAvkC,EAAA,CACA,GAAA+V,GAAAktB,GAAAjxB,GAAAyV,EAAApW,EAAAvI,MAAAJ,KAAA2I,EACAmzB,IAAAnzB,EAAAizB,GAAApB,GAAAp4B,EAAA2c,IAAA1R,EAAA3H,KAAAm2B,GACArB,GAAAp4B,EAAA2c,IAAA6c,EAAAvuB,EAAA1H,QACO,UAAArO,IACPwkC,GAAAnzB,EAAAizB,GAAApB,GAAAp4B,EAAA2c,IAAA8c,EAAA9zB,GAAAgX,EAAA/W,GAAAW,EAAAvI,KAAA,KACAo6B,GAAAp4B,EAAA2c,IAAA6c,EAAA7zB,GAAAgX,EAAA/W,GAAAW,EAAAvI,KAAA,SAWA,QAAA27B,GAAAt8B,GACA,GAAAu8B,KAAAC,EACAtzB,EAAAwxB,GAAA/3B,EAAA3C,GAAA,EACA,IAAAkJ,EACA,GAAArD,GAAAqD,EAAAie,GAOO,CACP,GAAAmN,GAAAt0B,EAAAmY,QAAAskB,EAAAnpB,IAAA,IAAAtT,EAAAmY,QAAAskB,EAAAlpB,OAAA,IACA+gB,IAAA74B,WAAA4O,GAAA1H,EAAA,WACA65B,GAAAD,IACAp3B,EAAAgc,SAAA3L,WAAA8e,EACAgI,EAAAt8B,MACS,QAbT,CACA45B,GAAAj3B,GACAwkB,EAAAje,EACA+yB,EAAA/yB,EACA,IAAAgf,GAAA1B,EAAArhB,EAAAma,IACApW,EAAAvI,MAAAunB,EAAAhiB,IAAAgD,EAAAvI,KAAAunB,EAAAjiB,OACAxK,WAAA4O,GAAA1H,EAAA,WAA8C65B,GAAAD,GAAAD,EAAAt8B,KAAoC,MAWlF,QAAAsW,GAAAtW,GACAw8B,EAAA/T,IACAoS,GAAA76B,GACA0e,GAAA/b,GACApI,GAAAlD,SAAA,YAAAqlC,GACAniC,GAAAlD,SAAA,UAAAslC,GApIA,IAAAvC,GAAAr8B,KAAAiC,GAAA,CACA,GAAA2C,GAAA5E,KAAAoH,EAAAxC,EAAAwC,QAAAma,EAAA3c,EAAA2c,IAAAxB,EAAAwB,EAAAxB,GAGA,IAFAA,EAAAviB,MAAAyE,EAAA48B,SAEAhC,GAAAz1B,EAAAnF,GAKA,YAJAigB,KACA9a,EAAAgc,SAAAG,WAAA,EACA7lB,WAAA,WAA8B0J,EAAAgc,SAAAG,WAAA,GAAmC,MAIjE,KAAAqZ,GAAAh4B,EAAA3C,GAAA,CACA,GAAAoI,GAAAsyB,GAAA/3B,EAAA3C,EAGA,QAFA/I,OAAAmM,QAEAy5B,GAAA78B,IACA,OAEA,YADAg7B,IAAAC,GAAAnkC,KAAA6L,IAAA3C,GAEA,QAKA,MAJAigB,MAAAtd,EAAAkE,MAAA60B,gBAAA,GAAApM,OACAlnB,GAAA2yB,GAAAp4B,EAAA2c,IAAAlX,GACA3M,WAAA3B,GAAA4kB,GAAA/b,GAAA,QACAk4B,IAAA76B,GAMA,IAAAoI,EAA0E,YAAzD0zB,GAAA97B,IAAAmF,EAAAgc,UAAA0Z,GAAA76B,GAEjBvE,YAAA3B,GAAA8/B,GAAAj3B,GAAA,EAEA,IAAAm6B,IAAA,GAAAxN,MAAAz3B,EAAA,QACA,IAAAklC,OAAA9N,KAAA6N,EAAA,KAAAj3B,GAAAk3B,GAAAz2B,IAAA8B,GACAvQ,EAAA,SACAgjC,GAAA76B,GACAvE,WAAA3B,GAAA4kB,GAAA/b,GAAA,IACAq6B,GAAAr6B,EAAAyF,EAAAzH,UACK,IAAAs8B,OAAAhO,KAAA6N,EAAA,KAAAj3B,GAAAo3B,GAAA32B,IAAA8B,GAAA,CACLvQ,EAAA,SACAklC,IAAyB9N,KAAA6N,EAAAx2B,IAAA8B,GACzByyB,GAAA76B,EACA,IAAA4N,GAAAktB,GAAAjxB,GAAAyV,EAAAlX,EAAAzH,MAAAJ,KAAA6H,EACA2yB,IAAAp4B,EAAA2c,IAAA1R,EAAA3H,KAAA2H,EAAA1H,QACY+2B,KAAchO,KAAA6N,EAAAx2B,IAAA8B,EAE1B,IAAA+e,GAAA/e,CACA,IAAAzF,EAAAU,QAAAk4B,UAAA2B,KAAA5E,GAAA31B,KAAAkD,GAAAiY,EAAA7X,KAAA6X,EAAA5X,MACAm2B,GAAAj0B,EAAA0V,EAAA7X,QAAAo2B,GAAAve,EAAA5X,GAAAkC,IAAA,UAAAvQ,EAAA,CACA,GAAAslC,GAAA9yB,GAAA1H,EAAA,SAAAy6B,GACAnd,KAAA9a,EAAAgc,SAAAG,WAAA,GACA3e,EAAAkE,MAAAqY,cAAA,EACA3kB,GAAAlD,SAAA,UAAA8lC,GACA5iC,GAAA4K,EAAAgc,SAAA,OAAAgc,GACAp8B,KAAAs8B,IAAAr9B,EAAAoY,QAAAglB,EAAAhlB,SAAArX,KAAAs8B,IAAAr9B,EAAAmY,QAAAilB,EAAAjlB,SAAA,KACA0iB,GAAAuC,GACArC,GAAAp4B,EAAA2c,IAAAlX,GACAsW,GAAA/b,GAEA8c,KAAA2S,IACA32B,WAAA,WAAmCpE,SAAAoB,KAAA2K,QAAsBsb,GAAA/b,IAAiB,MAU1E,OANAsd,MAAA9a,EAAAgc,SAAAG,WAAA,GACA3e,EAAAkE,MAAAqY,aAAAie,EAEAh4B,EAAAgc,SAAAoa,UAAAp2B,EAAAgc,SAAAoa,WACA9hC,GAAApC,SAAA,UAAA8lC,OACA1jC,IAAA0L,EAAAgc,SAAA,OAAAgc,GAGAtC,GAAA76B,GACA,UAAAnI,GAAAkjC,GAAAp4B,EAAA2c,IAAAhX,GAAAgX,EAAAlX,GAEA,IAAA+zB,GAAAre,EAAA7X,KAAAm2B,EAAAte,EAAA5X,GAAAg2B,EAAA9zB,EAuBAq0B,EAAA9U,GAAAxiB,EAAAlL,SAKAuiC,EAAA,EA+BAE,EAAAryB,GAAA1H,EAAA,SAAA3C,IACA04B,KAAA4E,GAAAt9B,EAAAu9B,QAAAV,GAAA78B,IACAs8B,EAAAt8B,GADAsW,EAAAtW,KAGA28B,EAAAtyB,GAAA1H,EAAA2T,EACA7c,IAAApC,SAAA,YAAAqlC,GACAjjC,GAAApC,SAAA,UAAAslC,KAGA,QAAAa,IAAA76B,EAAA3C,EAAAnI,EAAA4lC,EAAAC,GACA,IAAS,GAAAC,GAAA39B,EAAAoY,QAAAwlB,EAAA59B,EAAAmY,QACT,MAAAnY,GAAc,SACd,GAAA29B,GAAA58B,KAAAuW,MAAAqQ,GAAAhlB,EAAAwC,QAAA2W,SAAAxS,OAAA,QACAm0B,IAAA5C,GAAA76B,EAEA,IAAAmF,GAAAxC,EAAAwC,QACA04B,EAAAlW,GAAAxiB,EAAAsb,QAEA,IAAAmd,EAAAC,EAAAtqB,SAAAuqB,GAAAn7B,EAAA9K,GAAA,MAAAkmC,IAAA/9B,EACA49B,IAAAC,EAAAvqB,IAAAnO,EAAAsc,UAEA,QAAAlkB,GAAA,EAAmBA,EAAAoF,EAAAU,QAAAyY,QAAAzgB,SAA+BkC,EAAA,CAClD,GAAAygC,GAAA74B,EAAA2W,QAAA1d,WAAAb,EACA,IAAAygC,GAAArW,GAAAqW,GAAA10B,OAAAq0B,EAAA,CACA,GAAAh9B,GAAAgmB,GAAAhkB,EAAA2c,IAAAse,GACAK,EAAAt7B,EAAAU,QAAAyY,QAAAve,EAEA,OADAmgC,GAAA/6B,EAAA9K,EAAA8K,EAAAhC,EAAAs9B,EAAAj+B,GACA+9B,GAAA/9B,KAKA,QAAAk+B,IAAAv7B,EAAA3C,GACA,MAAA89B,IAAAn7B,EAAA,qBACA66B,GAAA76B,EAAA3C,EAAA,uBAAA4V,KADA,EAIA,QAAA+kB,IAAAh4B,EAAA3C,GACA,MAAAw9B,IAAA76B,EAAA3C,EAAA,iBAAAsoB,IAOA,QAAAmT,IAAAz7B,GACA,GAAA2C,GAAA5E,IACA,MAAAq8B,GAAAz3B,EAAA3C,IAAA46B,GAAAj4B,EAAAwC,QAAAnF,IAAA2C,EAAAU,QAAAg3B,aAAA13B,EAAAU,QAAAg3B,YAAA13B,EAAA23B,GAAAt6B,KAAA,CAEA66B,GAAA76B,GACA04B,KAAAyF,IAAA,GAAA7O,MACA,IAAAhpB,GAAAo0B,GAAA/3B,EAAA3C,GAAA,GAAAo+B,EAAAp+B,EAAAq+B,aAAAD,KACA;GAAA93B,IAAAgyB,GAAA31B,GACA,GAAAy7B,KAAA/iC,QAAApE,OAAAqnC,YAAArnC,OAAAsnC,KAaA,OAZA34B,GAAAw4B,EAAA/iC,OAAAkF,EAAAsO,MAAAjJ,GAAA44B,EAAA,EACAC,EAAA,SAAAC,EAAAnhC,GACA,GAAAohC,GAAA,GAAAL,WACAK,GAAAC,OAAA,WACAr+B,EAAAhD,GAAAohC,EAAAhH,SACA6G,GAAA54B,IACAU,EAAAgC,GAAA3F,EAAA2c,IAAAhZ,GACA2yB,GAAAt2B,EAAA2c,KAAgCrZ,KAAAK,EAAAJ,GAAAI,EAAA/F,KAAAy4B,GAAAz4B,EAAAa,KAAA,OAAAkG,OAAA,SAAuE,YAGvGq3B,EAAAE,WAAAH,IAEAnhC,EAAA,EAAqBqI,EAAArI,IAAOA,EAAAkhC,EAAAL,EAAA7gC,UACvB,CAEL,GAAAoF,EAAAkE,MAAAqY,eAAAmd,GAAA/1B,EAAA3D,EAAA2c,IAAAxB,IAAA7X,QAAAo2B,GAAA15B,EAAA2c,IAAAxB,IAAA5X,GAAAI,GAIA,MAHA3D,GAAAkE,MAAAqY,aAAAlf,OAEAvE,YAAA3B,GAAA4kB,GAAA/b,GAAA,GAGA,KACA,GAAApC,GAAAP,EAAAq+B,aAAAS,QAAA,OACA,IAAAv+B,EAAA,CACA,GAAAw+B,GAAAp8B,EAAA2c,IAAAxB,IAAA7X,KAAA+4B,EAAAr8B,EAAA2c,IAAAxB,IAAA5X,EACAuC,IAAA9F,EAAA2c,IAAAhZ,KACA3D,EAAAkE,MAAAqY,cAAAzY,GAAA9D,EAAA2c,IAAA,GAAAyf,EAAAC,EAAA,SACAr8B,EAAA8E,iBAAAlH,EAAA,cACAme,GAAA/b,IAGA,MAAA3C,OAIA,QAAAw7B,IAAA74B,EAAA3C,GACA,GAAA04B,MAAA/1B,EAAAkE,MAAAqY,eAAA,GAAAoQ,MAAA6O,GAAA,KAAkF,WAAX5D,IAAAv6B,EACvE,KAAAo6B,GAAAz3B,EAAA3C,KAAA46B,GAAAj4B,EAAAwC,QAAAnF,GAAA,CAEA,GAAAwH,GAAA7E,EAAA8G,cAKA,IAJAzJ,EAAAq+B,aAAAY,QAAA,OAAAz3B,GAIAxH,EAAAq+B,aAAAa,eAAAC,GAAA,CACA,GAAAC,GAAAtsB,GAAA,oDACAssB,GAAA39B,IAAA,6EACA49B,KACAD,EAAAt6B,MAAAs6B,EAAAjrB,OAAA,EACAxR,EAAAwC,QAAAlL,QAAAjC,YAAAonC,GAEAA,EAAAE,KAAAF,EAAA/nB,WAEArX,EAAAq+B,aAAAa,aAAAE,EAAA,KACAC,IAAAD,EAAA19B,WAAAtJ,YAAAgnC,KAIA,QAAAlE,IAAAv4B,EAAA+H,GACA3J,KAAAs8B,IAAA16B,EAAA2c,IAAA9J,UAAA9K,GAAA,IACA/H,EAAA2c,IAAA9J,UAAA9K,EACA60B,IAAA3X,EAAAjlB,KAAA+H,GACA/H,EAAAwC,QAAAgc,SAAA3L,WAAA9K,IAAA/H,EAAAwC,QAAAgc,SAAA3L,UAAA9K,GACA/H,EAAAwC,QAAAmb,WAAA9K,WAAA9K,IAAA/H,EAAAwC,QAAAmb,WAAA9K,UAAA9K,GACA60B,IAAA3X,EAAAjlB,MACA4gB,EAAA5gB,EAAA,MAEA,QAAAk0B,IAAAl0B,EAAA+H,EAAA80B,IACAA,EAAA90B,GAAA/H,EAAA2c,IAAAwH,WAAA/lB,KAAAs8B,IAAA16B,EAAA2c,IAAAwH,WAAApc,GAAA,KACAA,EAAA3J,KAAAL,IAAAgK,EAAA/H,EAAAwC,QAAAgc,SAAA6E,YAAArjB,EAAAwC,QAAAgc,SAAA7c,aACA3B,EAAA2c,IAAAwH,WAAApc,EACAka,EAAAjiB,GACAA,EAAAwC,QAAAgc,SAAA2F,YAAApc,IAAA/H,EAAAwC,QAAAgc,SAAA2F,WAAApc,GACA/H,EAAAwC,QAAAkb,WAAAyG,YAAApc,IAAA/H,EAAAwC,QAAAkb,WAAAyG,WAAApc,IAwBA,QAAAywB,IAAAx4B,EAAA3C,GACA,GAAAy/B,GAAAz/B,EAAA0/B,YAAAC,EAAA3/B,EAAA4/B,WACA,OAAAH,GAAAz/B,EAAA6/B,QAAA7/B,EAAA8/B,MAAA9/B,EAAA+/B,kBAAAN,EAAAz/B,EAAA6/B,QACA,MAAAF,GAAA3/B,EAAA6/B,QAAA7/B,EAAA8/B,MAAA9/B,EAAAggC,cAAAL,EAAA3/B,EAAA6/B,OACA,MAAAF,MAAA3/B,EAAAigC,WAEA,IAAA96B,GAAAxC,EAAAwC,QAAA+6B,EAAA/6B,EAAAgc,QAEA,IAAAse,GAAAS,EAAAla,YAAAka,EAAA57B,aACAq7B,GAAAO,EAAApa,aAAAoa,EAAA37B,aADA,CAOA,GAAAo7B,GAAApV,IAAAtK,GACA,OAAA/W,GAAAlJ,EAAAC,OAA8BiJ,GAAAg3B,EAAeh3B,IAAAxH,WAC7C,GAAAwH,EAAAsgB,QAAA,CACA7mB,EAAAwC,QAAAqlB,mBAAAthB,CACA,OAWA,GAAAu2B,IAAAF,KAAAF,IAAA,MAAAc,GAMA,MALAR,IACAzE,GAAAv4B,EAAA5B,KAAAoL,IAAA,EAAApL,KAAAL,IAAAw/B,EAAA1qB,UAAAmqB,EAAAQ,GAAAD,EAAApa,aAAAoa,EAAA37B,gBACAsyB,GAAAl0B,EAAA5B,KAAAoL,IAAA,EAAApL,KAAAL,IAAAw/B,EAAApZ,WAAA2Y,EAAAU,GAAAD,EAAAla,YAAAka,EAAA57B,eACAu2B,GAAA76B,QACAmF,EAAA2d,YAAA,KAIA,IAAA6c,GAAA,MAAAQ,GAAA,CACA,GAAAC,GAAAT,EAAAQ,GACA7sB,EAAA3Q,EAAA2c,IAAA9J,UAAAiU,EAAAnW,EAAAnO,EAAAlL,QAAAsK,YACA,GAAA67B,EAAA9sB,EAAAvS,KAAAoL,IAAA,EAAAmH,EAAA8sB,EAAA,IACA3W,EAAA1oB,KAAAL,IAAAiC,EAAA2c,IAAAnL,OAAAsV,EAAA2W,EAAA,IACAxY,EAAAjlB,MAA6B2Q,MAAAC,OAAAkW,IAG7B,GAAA4W,KACA,MAAAl7B,EAAA2d,aACA3d,EAAA2d,YAAAod,EAAApZ,WAAgD3hB,EAAA4d,YAAAmd,EAAA1qB,UAChDrQ,EAAAyd,QAAA6c,EAA6Bt6B,EAAA0d,QAAA8c,EAC7BlkC,WAAA,WACA,SAAA0J,EAAA2d,YAAA,CACA,GAAAwd,GAAAJ,EAAApZ,WAAA3hB,EAAA2d,YACAyd,EAAAL,EAAA1qB,UAAArQ,EAAA4d,YACAyd,EAAAD,GAAAp7B,EAAA0d,SAAA0d,EAAAp7B,EAAA0d,SACAyd,GAAAn7B,EAAAyd,SAAA0d,EAAAn7B,EAAAyd,OACAzd,GAAA2d,YAAA3d,EAAA4d,YAAA,KACAyd,IACAL,OAAAE,GAAAG,IAAAH,GAAA,KACAA,MACS,OAETl7B,EAAAyd,SAAA6c,EAA8Bt6B,EAAA0d,SAAA8c,KAK9B,QAAAc,IAAA99B,EAAA0O,EAAAqvB,GACA,mBAAArvB,KACAA,EAAAwG,GAAAxG,IACAA,GAAA,QAIA1O,GAAAwC,QAAA+c,aAAAgW,GAAAv1B,OAAAwC,QAAA+c,aAAA,EACA,IAAA5C,GAAA3c,EAAA2c,IAAAqhB,EAAArhB,EAAAxB,IAAAviB,MAAA+a,GAAA,CACA,KACAgiB,GAAA31B,OAAAkE,MAAAkY,eAAA,GACA2hB,IAAAphB,EAAAxB,IAAAviB,OAAA,GACA+a,EAAAjF,EAAA1O,IAAAsG,GACK,QACLqW,EAAAxB,IAAAviB,MAAAolC,EACAh+B,EAAAkE,MAAAkY,eAAA,EAEA,MAAAzI,GAGA,QAAAsqB,IAAAj+B,GACA,GAAAk+B,GAAAl+B,EAAAkE,MAAA8X,QAAAzd,MAAA,EAGA,OAFAyB,GAAAU,QAAAE,WAAAs9B,EAAArlC,KAAAmH,EAAAU,QAAAE,WACAs9B,EAAArlC,KAAAmH,EAAAU,QAAAkR,QACAssB,EAIA,QAAAC,IAAAn+B,EAAA3C,GAEA,GAAA+gC,GAAAC,GAAAr+B,EAAAU,QAAAkR,QAAA7D,EAAAqwB,EAAA/qB,IACAjB,cAAAksB,IACAvwB,IAAAwwB,GAAAlhC,KAAAihC,GAAAxlC,WAAA,WACAulC,GAAAr+B,EAAAU,QAAAkR,SAAAwsB,IACAp+B,EAAAU,QAAAkR,OAAA7D,EAAA5Z,KAAA4Z,EAAA5Z,KAAA,KAAA6L,GAAA+N,EACAgU,EAAA/hB,KAEK,IAEL,IAAAxG,GAAAglC,GAAAnhC,GAAA,GAAAohC,GAAA,CACA,KAAAjlC,EAAA,QACA,IAAAklC,GAAAT,GAAAj+B,EAqBA,OAfAy+B,GAJAphC,EAAA48B,SAIA0E,GAAA,SAAAnlC,EAAAklC,EAAA,SAAAt7B,GAAiE,MAAA06B,IAAA99B,EAAAoD,GAAA,MACjEu7B,GAAAnlC,EAAAklC,EAAA,SAAAt7B,GACA,uBAAAA,GAAA,WAAAjN,KAAAiN,KAAAw7B,QACAd,GAAA99B,EAAAoD,GADA,SAIAu7B,GAAAnlC,EAAAklC,EAAA,SAAAt7B,GAAsD,MAAA06B,IAAA99B,EAAAoD,KAGtDq7B,IACAvG,GAAA76B,GACA6uB,EAAAlsB,GACAyvB,KAAmBpyB,EAAAwhC,WAAAxhC,EAAAyhC,QAA0BzhC,EAAAyhC,QAAA,GAC7CnZ,GAAA3lB,EAAA,aAAAA,EAAAxG,EAAA6D,IAEAohC,EAGA,QAAAM,IAAA/+B,EAAA3C,EAAAgG,GACA,GAAAo7B,GAAAE,GAAA,IAAAt7B,EAAA,IAAA46B,GAAAj+B,GACA,SAAAoD,GAAyC,MAAA06B,IAAA99B,EAAAoD,GAAA,IAMzC,OALAq7B,KACAvG,GAAA76B,GACA6uB,EAAAlsB,GACA2lB,GAAA3lB,EAAA,aAAAA,EAAA,IAAAqD,EAAA,IAAAhG,IAEAohC,EAGA,QAAAhG,IAAAp7B,GACA,GAAA2C,GAAA5E,IACAq8B,IAAAz3B,EAAA3C,IAAA2C,EAAAU,QAAAs+B,YAAAh/B,EAAAU,QAAAs+B,WAAAh/B,EAAA23B,GAAAt6B,KACA,IAAAA,EAAAyhC,UAAA9+B,EAAA2c,IAAAxB,IAAAviB,OAAA,GAIA,QAAA8/B,IAAAr7B,GACA,GAAA2C,GAAA5E,IAEA,IADA67B,GAAAj3B,KACAy3B,GAAAz3B,EAAA3C,IAAA2C,EAAAU,QAAAs+B,YAAAh/B,EAAAU,QAAAs+B,WAAAh/B,EAAA23B,GAAAt6B,KAAA,CACAyf,IAAA,IAAAzf,EAAAyhC,UAAAzhC,EAAA4hC,aAAA,EACA,IAAAC,GAAA7hC,EAAAyhC,OAEA9+B,GAAA2c,IAAAxB,IAAAviB,MAAA,IAAAsmC,GAAA7hC,EAAA48B,QAEA,IAAAwE,GAAAN,GAAAn+B,EAAA3C,EACAq/B,MACAyC,GAAAV,EAAAS,EAAA,MAEAT,GAAA,IAAAS,IAAApI,KAAAlP,GAAAvqB,EAAA+hC,QAAA/hC,EAAAgiC,UACAr/B,EAAA8E,iBAAA,MAIA,QAAA6zB,IAAAt7B,GACA,GAAA2C,GAAA5E,IACA,MAAAq8B,GAAAz3B,EAAA3C,IAAA2C,EAAAU,QAAAs+B,YAAAh/B,EAAAU,QAAAs+B,WAAAh/B,EAAA23B,GAAAt6B,KAAA,CACA,GAAAyhC,GAAAzhC,EAAAyhC,QAAAQ,EAAAjiC,EAAAiiC,QACA,IAAA5C,IAAAoC,GAAAK,GAAwF,MAA3CA,IAAA,SAAsBjH,IAAA76B,EACnE,MAAAq/B,MAAAr/B,EAAAkiC,OAAAliC,EAAAkiC,MAAA,KAAA3gB,MAAAuf,GAAAn+B,EAAA3C,GAAA,CACA,GAAAgG,GAAAwhB,OAAA2a,aAAA,MAAAF,EAAAR,EAAAQ,EACAP,IAAA/+B,EAAA3C,EAAAgG,KACA0yB,KAAAtG,KAAAzvB,EAAAwC,QAAAwzB,kBAAA,MACAR,GAAAx1B,MAGA,QAAAmS,IAAAnS,GACA,YAAAA,EAAAU,QAAAs2B,WACAh3B,EAAAkE,MAAA8F,UACAiJ,GAAAjT,EAAA,QAAAA,GACAA,EAAAkE,MAAA8F,SAAA,EACA,IAAAhK,EAAAwC,QAAAlL,QAAAuS,UAAAgf,OAAA,4BACA7oB,EAAAwC,QAAAlL,QAAAuS,WAAA,uBACA7J,EAAA6gB,QACA9D,GAAA/c,GAAA,GACAsd,IAAAxkB,WAAA3B,GAAA4lB,GAAA/c,GAAA,QAGAq1B,GAAAr1B,GACAksB,EAAAlsB,IAEA,QAAAkS,IAAAlS,GACAA,EAAAkE,MAAA8F,UACAiJ,GAAAjT,EAAA,OAAAA,GACAA,EAAAkE,MAAA8F,SAAA,EACAhK,EAAAwC,QAAAlL,QAAAuS,UAAA7J,EAAAwC,QAAAlL,QAAAuS,UAAAkD,QAAA,2BAEAoJ,cAAAnW,EAAAwC,QAAA2pB,SACArzB,WAAA,WAA2BkH,EAAAkE,MAAA8F,UAAAhK,EAAA2c,IAAAxB,IAAAviB,OAAA,IAAiD,KAI5E,QAAA0/B,IAAAt4B,EAAA3C,GAwBA,QAAAoiC,KACA,SAAAj9B,EAAAjC,MAAAy4B,eAAA,CACA,GAAA0G,GAAAl9B,EAAAjC,MAAAI,MAAA,KAAAuC,GAAAiY,EAAA7X,KAAA6X,EAAA5X,IAAA,GAAAf,EAAAjC,MAAAI,MACA6B,GAAA6c,UAAA,IACA7c,EAAAjC,MAAAy4B,eAAA,EAAyCx2B,EAAAjC,MAAA04B,aAAAyG,EAAAhnC,QAGzC,QAAAinC,KAOA,GANAn9B,EAAAib,SAAAznB,MAAAsf,SAAA,WACA9S,EAAAjC,MAAAvK,MAAAZ,QAAAwqC,EACAnQ,KAAAjtB,EAAAmb,WAAA9K,UAAArQ,EAAAgc,SAAA3L,UAAAgtB,GACAxK,GAAAr1B,GAGA,MAAAwC,EAAAjC,MAAAy4B,eAAA,GACAjD,IAAAtG,KAAAgQ,IACArtB,aAAA0tB,GACA,IAAAllC,GAAA,EAAAqb,EAAA,WACA,KAAAzT,EAAA6c,WAAA,GAAA7c,EAAAjC,MAAAy4B,eACAtxB,GAAA1H,EAAAkV,GAAA6qB,WAAA//B,GACApF,IAAA,GAAAklC,GAAAhnC,WAAAmd,EAAA,KACA8G,GAAA/c,GAEA8/B,IAAAhnC,WAAAmd,EAAA,MA9CA,IAAAwhB,GAAAz3B,EAAA3C,EAAA,gBACA,GAAAmF,GAAAxC,EAAAwC,QAAA2Y,EAAAnb,EAAA2c,IAAAxB,GACA,KAAA8c,GAAAz1B,EAAAnF,KAAAk+B,GAAAv7B,EAAA3C,GAAA,CAEA,GAAAsG,GAAAo0B,GAAA/3B,EAAA3C,GAAAwiC,EAAAr9B,EAAAgc,SAAA3L,SACA,IAAAlP,IAAA+4B,GAAA,CAIA,GAAAsD,GAAAhgC,EAAAU,QAAAu/B,2BACAD,KAAA98B,GAAAiY,EAAA7X,KAAA6X,EAAA5X,KAAAm2B,GAAA/1B,EAAAwX,EAAA7X,QAAAo2B,GAAA/1B,EAAAwX,EAAA5X,MACAmE,GAAA1H,EAAA8F,IAAA9F,EAAA2c,IAAAhZ,IAEA,IAAAi8B,GAAAp9B,EAAAjC,MAAAvK,MAAAZ,OAsCA,IArCAoN,EAAAib,SAAAznB,MAAAsf,SAAA,WACA9S,EAAAjC,MAAAvK,MAAAZ,QAAA,qDAA8EiI,EAAAmY,QAAA,GAC9E,cAAUnY,EAAAoY,QAAA,2KAEVsG,GAAA/b,GACA+c,GAAA/c,GAAA,GAEAkD,GAAAiY,EAAA7X,KAAA6X,EAAA5X,MAAAf,EAAAjC,MAAAI,MAAA6B,EAAA6c,UAAA,KA6BA0W,KAAAtG,IAAAgQ,IACApH,GAAA,CACAT,GAAAv6B,EACA,IAAA6iC,GAAA,WACAtoC,GAAAtD,OAAA,UAAA4rC,GACApnC,WAAA6mC,EAAA,IAEA7oC,IAAAxC,OAAA,UAAA4rC,OAEApnC,YAAA6mC,EAAA,OAaA,QAAAQ,IAAAxjB,EAAAsK,EAAAtjB,GACA,IAAA+1B,GAAAzS,EAAA3jB,KAAAK,GAAA,MAAAgC,IAAAgX,EAAAhZ,EACA,IAAAoiB,GAAAkB,EAAArpB,KAAAlF,OAAA,GAAAuuB,EAAA1jB,GAAAvF,KAAAipB,EAAA3jB,KAAAtF,KACA,IAAA2F,EAAA3F,KAAAipB,EAAA1jB,GAAAvF,KAAA+nB,EAAA,CACA,GAAAqa,GAAAz8B,EAAA3F,KAAA+nB,EAAAra,EAAAiR,EAAAjB,MAAAiB,EAAA+H,KAAA,CACA,OAAA0b,GAAA10B,EAAA9F,GAAA8F,EAAAxE,GAAAyV,EAAAjR,GAAA9N,KAAAlF,QACA2nC,GAAA18B,EAAAuD,GAAAyV,EAAAyjB,GAAAxiC,KAAAlF,QAEA,GAAAiL,EAAA3F,MAAAipB,EAAA1jB,GAAAvF,KAAA+nB,EACA,MAAAsa,IAAA18B,EAAA28B,GAAArZ,EAAArpB,MAAAlF,QAAA,GAAAuuB,EAAArpB,KAAAlF,OAAAuuB,EAAA3jB,KAAAD,GAAA,GACA6D,GAAAyV,EAAAsK,EAAA1jB,GAAAvF,MAAAJ,KAAAlF,OAAAuuB,EAAA1jB,GAAAF,GACA,IAAAk9B,GAAA58B,EAAA3F,KAAAipB,EAAA3jB,KAAAtF,IACA,OAAAqiC,IAAA18B,EAAAsjB,EAAArpB,KAAA2iC,GAAA7nC,QAAA6nC,EAAA,EAAAtZ,EAAA3jB,KAAAD,KAIA,QAAAm9B,IAAA7jB,EAAAsK,EAAA7T,GACA,GAAAA,GAAA,gBAAAA,GACA,OAAc5L,OAAA24B,GAAAxjB,EAAAsK,EAAA7T,EAAA5L,QACdjS,KAAA4qC,GAAAxjB,EAAAsK,EAAA7T,EAAA7d,MAEA,aAAA6d,EAAA,OAAiC5L,OAAAyf,EAAA3jB,KAAA/N,KAAA0xB,EAAA3jB,KAEjC,IAAAoC,GAAA+6B,GAAAxZ,EACA,cAAA7T,EAAA,OAAkC5L,OAAAyf,EAAA3jB,KAAA/N,KAAAmQ,EAClC,WAAA0N,EAAA,OAA+B5L,OAAA9B,EAAAnQ,KAAAmQ,EAG/B,IAAAg7B,GAAA,SAAA/8B,GACA,GAAA+1B,GAAA/1B,EAAAsjB,EAAA3jB,MAAA,MAAAK,EACA,KAAA+1B,GAAAzS,EAAA1jB,GAAAI,GAAA,MAAA+B,EAEA,IAAA1H,GAAA2F,EAAA3F,KAAAipB,EAAArpB,KAAAlF,QAAAuuB,EAAA1jB,GAAAvF,KAAAipB,EAAA3jB,KAAAtF,MAAA,EAAAqF,EAAAM,EAAAN,EAEA,OADAM,GAAA3F,MAAAipB,EAAA1jB,GAAAvF,OAAAqF,GAAAqC,EAAArC,GAAA4jB,EAAA1jB,GAAAF,IACAuC,GAAA5H,EAAAqF,GAEA,QAAYmE,OAAAk5B,EAAA/jB,EAAAxB,IAAA3T,QAAAjS,KAAAmrC,EAAA/jB,EAAAxB,IAAA5lB,OAGZ,QAAAorC,IAAAhkB,EAAAsK,EAAAnT,GACA,GAAA1G,IACAwzB,UAAA,EACAt9B,KAAA2jB,EAAA3jB,KACAC,GAAA0jB,EAAA1jB,GACA3F,KAAAqpB,EAAArpB,KACA+G,OAAAsiB,EAAAtiB,OACAk8B,OAAA,WAA0BzlC,KAAAwlC,UAAA,GAW1B,OATA9sB,KAAA1G,EAAA0G,OAAA,SAAAxQ,EAAAC,EAAA3F,EAAA+G,GACArB,IAAAlI,KAAAkI,KAAAqC,GAAAgX,EAAArZ,IACAC,IAAAnI,KAAAmI,GAAAoC,GAAAgX,EAAApZ,IACA3F,IAAAxC,KAAAwC,QACA3H,SAAA0O,IAAAvJ,KAAAuJ,YAEAsO,GAAA0J,EAAA,eAAAA,EAAAvP,GACAuP,EAAA3c,IAAAiT,GAAA0J,EAAA3c,GAAA,eAAA2c,EAAA3c,GAAAoN,GAEAA,EAAAwzB,SAAA,MACYt9B,KAAA8J,EAAA9J,KAAAC,GAAA6J,EAAA7J,GAAA3F,KAAAwP,EAAAxP,KAAA+G,OAAAyI,EAAAzI,QAKZ,QAAA2xB,IAAA3Z,EAAAsK,EAAA6Z,EAAAC,GACA,GAAApkB,EAAA3c,GAAA,CACA,IAAA2c,EAAA3c,GAAA6gB,MAAA,MAAAnZ,IAAAiV,EAAA3c,GAAAs2B,IAAA3Z,EAAAsK,EAAA6Z,EAAAC,EACA,IAAApkB,EAAA3c,GAAAkE,MAAAkY,cAAA,OAGA,KAAA+e,GAAAxe,EAAA,iBAAAA,EAAA3c,IAAAm7B,GAAAxe,EAAA3c,GAAA,mBACAinB,EAAA0Z,GAAAhkB,EAAAsK,GAAA,IADA,CAOA,GAAAppB,GAAAmjC,KAAAD,GAAAE,GAAAtkB,EAAAsK,EAAA3jB,KAAA2jB,EAAA1jB,GACA,IAAA1F,EAAA,CACA,OAAAjD,GAAAiD,EAAAnF,OAAA,EAAoCkC,GAAA,IAAQA,EAC5CsmC,GAAAvkB,GAAmCrZ,KAAAzF,EAAAjD,GAAA0I,KAAAC,GAAA1F,EAAAjD,GAAA2I,GAAA3F,MAAA,KACnCC,GAAAnF,QACAwoC,GAAAvkB,GAAmCrZ,KAAAzF,EAAA,GAAAyF,KAAAC,GAAA1F,EAAA,GAAA0F,GAAA3F,KAAAqpB,EAAArpB,MAAwDkjC,OAE3FI,IAAAvkB,EAAAsK,EAAA6Z,IAIA,QAAAI,IAAAvkB,EAAAsK,EAAA6Z,GACA,MAAA7Z,EAAArpB,KAAAlF,QAAA,IAAAuuB,EAAArpB,KAAA,KAAAsF,GAAA+jB,EAAA3jB,KAAA2jB,EAAA1jB,IAAA,CACA,GAAA49B,GAAAX,GAAA7jB,EAAAsK,EAAA6Z,EACAM,IAAAzkB,EAAAsK,EAAAka,EAAAxkB,EAAA3c,GAAA2c,EAAA3c,GAAA6gB,MAAA5sB,GAAAotC,KAEAC,GAAA3kB,EAAAsK,EAAAka,EAAAI,GAAA5kB,EAAAsK,GACA,IAAAua,KAEAC,IAAA9kB,EAAA,SAAAA,EAAA+kB,GACAA,GAAA,IAAAxmC,GAAAsmC,EAAA7kB,EAAAglB,WACAC,GAAAjlB,EAAAglB,QAAA1a,GACAua,EAAA3oC,KAAA8jB,EAAAglB,UAEAL,GAAA3kB,EAAAsK,EAAA,KAAAsa,GAAA5kB,EAAAsK,OAIA,QAAA4a,IAAAllB,EAAAznB,GACA,IAAAynB,EAAA3c,KAAA2c,EAAA3c,GAAAkE,MAAAkY,cAAA,CAEA,GAAA0lB,GAAAnlB,EAAAglB,QACAnqC,GAAA,QAAAtC,EAAA4sC,EAAAnuB,KAAAmuB,EAAAC,QAAA74B,KACA,IAAA1R,EAAA,CAEA,GAAAwqC,IAAgB9c,WAAA+c,aAAAzqC,EAAA0qC,YAAAC,WAAA3qC,EAAA4qC,UAChBF,YAAA1qC,EAAAyqC,aAAAG,UAAA5qC,EAAA2qC,WACAE,WAAAP,EAAAO,aACA,QAAAntC,EAAA4sC,EAAAC,OAAAD,EAAAnuB,MAAA9a,KAAAmpC,GACAF,EAAAO,WAAA7qC,EAAA6qC,cAAAP,EAAAQ,aAIA,QAFAC,GAAApH,GAAAxe,EAAA,iBAAAA,EAAA3c,IAAAm7B,GAAAxe,EAAA3c,GAAA,gBAEApF,EAAApD,EAAA0tB,QAAAxsB,OAAA,EAA0CkC,GAAA,IAAQA,EAAA,CAClD,GAAAqsB,GAAAzvB,EAAA0tB,QAAAtqB,EAEA,IADAqsB,EAAAtiB,OAAAzP,EACAqtC,IAAA5B,GAAAhkB,EAAAsK,GAAA,GAEA,aADA,QAAA/xB,EAAA4sC,EAAAnuB,KAAAmuB,EAAAC,QAAArpC,OAAA,EAIAspC,GAAA9c,QAAArsB,KAAA2pC,GAAA7lB,EAAAsK,GAEA,IAAAwb,GAAA7nC,EAAA4lC,GAAA7jB,EAAAsK,EAAA,OACuBzf,OAAAhQ,EAAAyqC,aAAA1sC,KAAAiC,EAAA2qC,WACvBb,IAAA3kB,EAAAsK,EAAAwb,EAAAC,GAAA/lB,EAAAsK,GACA,IAAAua,KAEAC,IAAA9kB,EAAA,SAAAA,EAAA+kB,GACAA,GAAA,IAAAxmC,GAAAsmC,EAAA7kB,EAAAglB,WACAC,GAAAjlB,EAAAglB,QAAA1a,GACAua,EAAA3oC,KAAA8jB,EAAAglB,UAEAL,GAAA3kB,EAAAsK,EAAA,KAAAyb,GAAA/lB,EAAAsK,SAKA,QAAA0b,IAAAhmB,EAAAimB,GACA,QAAAC,GAAAl/B,GAA4B,MAAAiC,IAAAjC,EAAA3F,KAAA4kC,EAAAj/B,EAAAN,IAC5BsZ,EAAAjB,OAAAknB,EACAjmB,EAAA3c,IAAA8gB,GAAAnE,EAAA3c,GAAA2c,EAAAjB,MAAAiB,EAAAjB,MAAAknB,GACAjmB,EAAAxB,IAAA5lB,KAAAstC,EAAAlmB,EAAAxB,IAAA5lB,MAA0ConB,EAAAxB,IAAA3T,OAAAq7B,EAAAlmB,EAAAxB,IAAA3T,QAC1CmV,EAAAxB,IAAA7X,KAAAu/B,EAAAlmB,EAAAxB,IAAA7X,MAA0CqZ,EAAAxB,IAAA5X,GAAAs/B,EAAAlmB,EAAAxB,IAAA5X,IAG1C,QAAA+9B,IAAA3kB,EAAAsK,EAAAka,EAAAtoB,GACA,GAAA8D,EAAA3c,KAAA2c,EAAA3c,GAAA6gB,MACA,MAAAnZ,IAAAiV,EAAA3c,GAAAshC,IAAA3kB,EAAAsK,EAAAka,EAAAtoB,EAEA,IAAAoO,EAAA1jB,GAAAvF,KAAA2e,EAAAjB,MAEA,WADAinB,IAAAhmB,EAAAsK,EAAArpB,KAAAlF,OAAA,GAAAuuB,EAAA1jB,GAAAvF,KAAAipB,EAAA3jB,KAAAtF,MAGA,MAAAipB,EAAA3jB,KAAAtF,KAAA2e,EAAAjR,YAAA,CAGA,GAAAub,EAAA3jB,KAAAtF,KAAA2e,EAAAjB,MAAA,CACA,GAAA9iB,GAAAquB,EAAArpB,KAAAlF,OAAA,GAAAikB,EAAAjB,MAAAuL,EAAA3jB,KAAAtF,KACA2kC,IAAAhmB,EAAA/jB,GACAquB,GAAgB3jB,KAAAsC,GAAA+W,EAAAjB,MAAA,GAAAnY,GAAAqC,GAAAqhB,EAAA1jB,GAAAvF,KAAApF,EAAAquB,EAAA1jB,GAAAF,IAChBzF,MAAA0iC,GAAArZ,EAAArpB,OAAA+G,OAAAsiB,EAAAtiB,QAEA,GAAA6f,GAAA7H,EAAAjR,UACAub,GAAA1jB,GAAAvF,KAAAwmB,IACAyC,GAAgB3jB,KAAA2jB,EAAA3jB,KAAAC,GAAAqC,GAAA4e,EAAAtd,GAAAyV,EAAA6H,GAAA5mB,KAAAlF,QAChBkF,MAAAqpB,EAAArpB,KAAA,IAAA+G,OAAAsiB,EAAAtiB,SAGAsiB,EAAA6b,QAAAC,GAAApmB,EAAAsK,EAAA3jB,KAAA2jB,EAAA1jB,IAEA49B,MAAAX,GAAA7jB,EAAAsK,EAAA,OACAtK,EAAA3c,GAAAgjC,GAAArmB,EAAA3c,GAAAinB,EAAApO,EAAAsoB,GACA8B,GAAAtmB,EAAAsK,EAAApO,EAAAsoB,IAGA,QAAA6B,IAAAhjC,EAAAinB,EAAApO,EAAAsoB,GACA,GAAAxkB,GAAA3c,EAAA2c,IAAAna,EAAAxC,EAAAwC,QAAAc,EAAA2jB,EAAA3jB,KAAAC,EAAA0jB,EAAA1jB,GAEA2/B,GAAA,EAAAC,EAAA7/B,EAAAtF,IACAgC,GAAAU,QAAAG,eACAsiC,EAAAz6B,GAAAwd,GAAAvJ,EAAAzV,GAAAyV,EAAArZ,EAAAtF,QACA2e,EAAA6D,KAAA2iB,EAAA5/B,EAAAvF,KAAA,WAAAA,GACA,MAAAA,IAAAwE,EAAAsd,SACAojB,GAAA,GACA,GAFA,UAOAxJ,GAAA/c,EAAAxB,IAAA5lB,KAAA0xB,EAAA3jB,OAAAo2B,GAAAzS,EAAA1jB,GAAAoZ,EAAAxB,IAAA5lB,QACAyK,EAAA6gB,MAAAjH,gBAAA,GAEAqpB,GAAAtmB,EAAAsK,EAAApO,EAAAsoB,EAAA/f,EAAAphB,IAEAA,EAAAU,QAAAG,eACA8b,EAAA6D,KAAA2iB,EAAA7/B,EAAAtF,KAAAipB,EAAArpB,KAAAlF,OAAA,SAAAsF,GACA,GAAAwkB,GAAAF,EAAA3F,EAAA3e,EACAwkB,GAAAhgB,EAAAud,gBACAvd,EAAAsd,QAAA9hB,EACAwE,EAAAud,cAAAyC,EACAhgB,EAAAwd,gBAAA,EACAkjB,GAAA,KAGAA,IAAAljC,EAAA6gB,MAAA6S,eAAA,IAIA/W,EAAAgE,SAAAviB,KAAAL,IAAA4e,EAAAgE,SAAArd,EAAAtF,MACA4iB,EAAA5gB,EAAA,IAEA,IAAAo1B,GAAAnO,EAAArpB,KAAAlF,QAAA6K,EAAAvF,KAAAsF,EAAAtF,MAAA,CAIA,IAFA8iB,GAAA9gB,EAAAsD,EAAAtF,KAAAuF,EAAAvF,KAAA,EAAAo3B,GAEA+F,GAAAn7B,EAAA,WACA,GAAAojC,IAAuB9/B,OAAAC,KACvB3F,KAAAqpB,EAAArpB,KACAklC,QAAA7b,EAAA6b,QACAn+B,OAAAsiB,EAAAtiB,OACA,IAAA3E,EAAA6gB,MAAA2S,YAAA,CACA,OAAAjtB,GAAAvG,EAAA6gB,MAAA2S,YAA4CjtB,EAAAwH,KAAUxH,IAAAwH,MACtDxH,EAAAwH,KAAAq1B,MACOpjC,GAAA6gB,MAAA2S,YAAA4P,GAIP,QAAAt/B,IAAA6Y,EAAAuiB,EAAA57B,EAAAC,EAAAoB,GAEA,GADApB,MAAAD,GACAo2B,GAAAn2B,EAAAD,GAAA,CAA4B,GAAAmoB,GAAAloB,CAAcA,GAAAD,EAAWA,EAAAmoB,EACrD,gBAAAyT,OAAA7I,GAAA6I,IACA5I,GAAA3Z,GAAqBrZ,OAAAC,KAAA3F,KAAAshC,EAAAv6B,UAA+C,MAKpE,QAAAiB,IAAA5H,EAAAqF,GACA,MAAAjI,gBAAAwK,KACAxK,KAAA4C,YAAqB5C,KAAAiI,OADrB,GAAAuC,IAAA5H,EAAAqF,GAKA,QAAAH,IAAAC,EAAAC,GAAwB,MAAAD,GAAAnF,MAAAoF,EAAApF,MAAAmF,EAAAE,IAAAD,EAAAC,GACxB,QAAAq2B,IAAAv2B,EAAAC,GAA0B,MAAAD,GAAAnF,KAAAoF,EAAApF,MAAAmF,EAAAnF,MAAAoF,EAAApF,MAAAmF,EAAAE,GAAAD,EAAAC,GAC1B,QAAAggC,IAAAlgC,EAAAC,GAAsB,MAAAD,GAAAnF,KAAAoF,EAAApF,MAAAmF,EAAAE,GAAAD,EAAAC,GACtB,QAAAigC,IAAAzR,GAAuB,MAAAjsB,IAAAisB,EAAA7zB,KAAA6zB,EAAAxuB,IAIvB,QAAAkgC,IAAA5mB,EAAA1Z,GAA6B,MAAA7E,MAAAoL,IAAAmT,EAAAjB,MAAAtd,KAAAL,IAAAkF,EAAA0Z,EAAAjB,MAAAiB,EAAA+H,KAAA,IAC7B,QAAA/e,IAAAgX,EAAAhZ,GACA,GAAAA,EAAA3F,KAAA2e,EAAAjB,MAAA,MAAA9V,IAAA+W,EAAAjB,MAAA,EACA,IAAA8I,GAAA7H,EAAAjB,MAAAiB,EAAA+H,KAAA,CACA,OAAA/gB,GAAA3F,KAAAwmB,EAAA5e,GAAA4e,EAAAtd,GAAAyV,EAAA6H,GAAA5mB,KAAAlF,QACA2nC,GAAA18B,EAAAuD,GAAAyV,EAAAhZ,EAAA3F,MAAAJ,KAAAlF,QAEA,QAAA2nC,IAAA18B,EAAA6/B,GACA,GAAAngC,GAAAM,EAAAN,EACA,cAAAA,KAAAmgC,EAAA59B,GAAAjC,EAAA3F,KAAAwlC,GACA,EAAAngC,EAAAuC,GAAAjC,EAAA3F,KAAA,GACA2F,EAEA,QAAA8/B,IAAA9mB,EAAAjiB,GAA2B,MAAAA,IAAAiiB,EAAAjB,OAAAhhB,EAAAiiB,EAAAjB,MAAAiB,EAAA+H,KAI3B,QAAA0T,IAAAzb,EAAAhZ,EAAAgnB,EAAAO,GACA,GAAAvO,EAAAxB,IAAAviB,OAAA+jB,EAAAxB,IAAAwe,OAAA,CACA,GAAAnyB,GAAAmV,EAAAxB,IAAA3T,MACA,IAAAmjB,EAAA,CACA,GAAA+Y,GAAAhK,GAAA/1B,EAAA6D,EACAk8B,IAAAhK,GAAA/O,EAAAnjB,IACAA,EAAA7D,EACAA,EAAAgnB,GACS+Y,GAAAhK,GAAA/1B,EAAAgnB,KACThnB,EAAAgnB,GAGA7kB,GAAA6W,EAAAnV,EAAA7D,EAAAunB,OAEAplB,IAAA6W,EAAAhZ,EAAAgnB,GAAAhnB,EAAAunB,EAEAvO,GAAA3c,KAAA2c,EAAA3c,GAAA6gB,MAAA0S,eAAA,GAGA,QAAAoQ,IAAAhnB,EAAAnV,EAAAjS,GACA,GAAA6X,IAAe5F,SAAAjS,OAIf,OAHA0d,IAAA0J,EAAA,wBAAAA,EAAAvP,GACAuP,EAAA3c,IAAAiT,GAAA0J,EAAA3c,GAAA,wBAAA2c,EAAA3c,GAAAoN,GACAA,EAAA5F,OAAA7B,GAAAgX,EAAAvP,EAAA5F,QAA0C4F,EAAA7X,KAAAoQ,GAAAgX,EAAAvP,EAAA7X,MAC1C6X,EAMA,QAAAtH,IAAA6W,EAAAnV,EAAAjS,EAAA21B,EAAA0Y,GACA,IAAAA,GAAAzI,GAAAxe,EAAA,0BAAAA,EAAA3c,IAAAm7B,GAAAxe,EAAA3c,GAAA,0BACA,GAAA6jC,GAAAF,GAAAhnB,EAAAnV,EAAAjS,EACAA,GAAAsuC,EAAAtuC,KACAiS,EAAAq8B,EAAAr8B,OAGA,GAAA2T,GAAAwB,EAAAxB,GASA,IARAA,EAAA2oB,WAAA,KACA,MAAA5Y,MAAAwO,GAAAnkC,EAAA4lB,EAAA5lB,MAAA,OAEAquC,IAAA1gC,GAAAsE,EAAA2T,EAAA3T,WACAA,EAAAu8B,GAAApnB,EAAAnV,EAAA0jB,EAAA,QAAA0Y,KACAA,IAAA1gC,GAAA3N,EAAA4lB,EAAA5lB,SACAA,EAAAwuC,GAAApnB,EAAApnB,EAAA21B,EAAA,QAAA0Y,KAEA1gC,GAAAiY,EAAA3T,YAAAtE,GAAAiY,EAAA5lB,QAAA,CAEA4lB,EAAA3T,SAAwB2T,EAAA5lB,MACxB,IAAAyuC,GAAAtK,GAAAnkC,EAAAiS,EACA2T,GAAA7X,KAAA0gC,EAAAzuC,EAAAiS,EACA2T,EAAA5X,GAAAygC,EAAAx8B,EAAAjS,EAEAonB,EAAA3c,KACA2c,EAAA3c,GAAA6gB,MAAAyS,YAAA3W,EAAA3c,GAAA6gB,MAAA4S,iBACA9W,EAAA3c,GAAA6gB,MAAAjH,gBAAA,GAEA+L,GAAAhJ,EAAA,iBAAAA,IAGA,QAAAsnB,IAAAjkC,GACA8F,GAAA9F,EAAA2c,IAAA3c,EAAA2c,IAAAxB,IAAA7X,KAAAtD,EAAA2c,IAAAxB,IAAA5X,GAAA,aAGA,QAAAwgC,IAAApnB,EAAAhZ,EAAAunB,EAAAgZ,GACA,GAAAC,IAAA,EAAAC,EAAAzgC,EACA9J,EAAAqxB,GAAA,CACAvO,GAAAua,UAAA,CACArO,GAAA,OAAmB,CACnB,GAAA7qB,GAAAkJ,GAAAyV,EAAAynB,EAAApmC,KACA,IAAAA,EAAAqwB,YACA,OAAAzzB,GAAA,EAAuBA,EAAAoD,EAAAqwB,YAAA31B,SAA6BkC,EAAA,CACpD,GAAAs1B,GAAAlyB,EAAAqwB,YAAAzzB,GAAA+Q,EAAAukB,EAAA9Y,MACA,WAAA8Y,EAAA5sB,OAAAqI,EAAA04B,cAAAnU,EAAA5sB,MAAA8gC,EAAA/gC,GAAA6sB,EAAA5sB,KAAA8gC,EAAA/gC,OACA,MAAA6sB,EAAA3sB,KAAAoI,EAAA24B,eAAApU,EAAA3sB,IAAA6gC,EAAA/gC,GAAA6sB,EAAA3sB,GAAA6gC,EAAA/gC,KAAA,CACA,GAAA6gC,IACAjxB,GAAAtH,EAAA,qBACAA,EAAA44B,mBAAA,CACA,GAAAvmC,EAAAqwB,YACA,GAAsBzzB,CAAI,UAD1B,MAIA,IAAA+Q,EAAA64B,OAAA,QACA,IAAA78B,GAAAgE,EAAA+W,OAAA,EAAA7oB,EAAA,YACA,IAAAqJ,GAAAyE,EAAAy8B,KACAz8B,EAAAtE,IAAAxJ,EACA8N,EAAAtE,GAAA,EACAsE,IAAA3J,KAAA2e,EAAAjB,MAAA/V,GAAAgX,EAAA/W,GAAA+B,EAAA3J,KAAA,IACA,KACe2J,EAAAtE,GAAArF,EAAAJ,KAAAlF,SACfiP,IAAA3J,KAAA2e,EAAAjB,MAAAiB,EAAA+H,KAAA,EAAA9e,GAAA+B,EAAA3J,KAAA,KACA,OAEA2J,GAAA,CACA,GAAAw8B,EAGA,MAAAD,IAEAvnB,EAAAua,UAAA,EACAtxB,GAAA+W,EAAAjB,MAAA,IAHAqoB,GAAApnB,EAAAhZ,EAAAunB,GAAA,EAKAiZ,IAAA,EAA+Bx8B,EAAAhE,EAAc9J,KAG7CuqC,EAAAz8B,CACA,SAAAkhB,IAIA,MAAAub,IAMA,QAAA5P,IAAAx0B,GACA,GAAAirB,GAAAqJ,GAAAt0B,IAAA2c,IAAAxB,IAAA5lB,KAAA,KAAAyK,EAAAU,QAAA+jC,mBACA,IAAAzkC,EAAAkE,MAAA8F,QAAA,CACA,GAAAxH,GAAAxC,EAAAwC,QAAA6O,EAAA2T,GAAAxiB,EAAA4b,OAAAsmB,EAAA,IAGA,IAFAzZ,EAAAta,IAAAU,EAAAV,IAAA,EAAA+zB,GAAA,EACAzZ,EAAAra,OAAAS,EAAAV,KAAArc,OAAA6c,aAAAzc,SAAAuc,gBAAArP,gBAAA8iC,GAAA,GACA,MAAAA,IAAAC,GAAA,CACA,GAAAC,GAAAz0B,GAAA,4CACA8a,EAAAta,IAAAnO,EAAAsc,YAAA,gBACAmM,EAAAra,OAAAqa,EAAAta,IAAA2N,IAAA,aACA2M,EAAAvkB,KAAA,kBACA1G,GAAAwC,QAAA0b,UAAA7oB,YAAAuvC,GACAA,EAAAC,eAAAH,GACA1kC,EAAAwC,QAAA0b,UAAAzoB,YAAAmvC,KAIA,QAAAtQ,IAAAt0B,EAAA2D,EAAA+B,EAAA6uB,GAEA,IADA,MAAAA,MAAA,KACW,CACX,GAAAxH,IAAA,EAAA9B,EAAAxa,EAAAzQ,EAAA2D,GACAmhC,EAAAp/B,MAAA/B,EAAA8M,EAAAzQ,EAAA0F,GAAAulB,EACA4U,EAAAzL,GAAAp0B,EAAA5B,KAAAL,IAAAktB,EAAAvkB,KAAAo+B,EAAAp+B,MACAtI,KAAAL,IAAAktB,EAAAta,IAAAm0B,EAAAn0B,KAAA4jB,EACAn2B,KAAAoL,IAAAyhB,EAAAvkB,KAAAo+B,EAAAp+B,MACAtI,KAAAoL,IAAAyhB,EAAAra,OAAAk0B,EAAAl0B,QAAA2jB,GACAwQ,EAAA/kC,EAAA2c,IAAA9J,UAAAmyB,EAAAhlC,EAAA2c,IAAAwH,UASA,IARA,MAAA0b,EAAAhtB,YACA0lB,GAAAv4B,EAAA6/B,EAAAhtB,WACAzU,KAAAs8B,IAAA16B,EAAA2c,IAAA9J,UAAAkyB,GAAA,IAAAhY,GAAA,IAEA,MAAA8S,EAAA1b,aACA+P,GAAAl0B,EAAA6/B,EAAA1b,YACA/lB,KAAAs8B,IAAA16B,EAAA2c,IAAAwH,WAAA6gB,GAAA,IAAAjY,GAAA,KAEAA,EAAA,MAAA9B,IAIA,QAAA4Z,IAAA7kC,EAAAilC,EAAAC,EAAAC,EAAAC,GACA,GAAAvF,GAAAzL,GAAAp0B,EAAAilC,EAAAC,EAAAC,EAAAC,EACA,OAAAvF,EAAAhtB,WAAA0lB,GAAAv4B,EAAA6/B,EAAAhtB,WACA,MAAAgtB,EAAA1b,YAAA+P,GAAAl0B,EAAA6/B,EAAA1b,YAGA,QAAAiQ,IAAAp0B,EAAAilC,EAAAC,EAAAC,EAAAC,GACA,GAAA5iC,GAAAxC,EAAAwC,QAAA6iC,EAAA/jB,GAAAthB,EAAAwC,QACA,GAAA0iC,MAAA,EACA,IAAAI,GAAA9iC,EAAAgc,SAAA5c,aAAA0c,GAAAinB,EAAA/iC,EAAAgc,SAAA3L,UAAAmiB,KACAwQ,EAAAxlC,EAAA2c,IAAAnL,OAAAyR,EAAAzgB,GACAijC,EAAAJ,EAAAH,EAAAQ,EAAAN,EAAAI,EAAAH,CACA,IAAAE,EAAAL,EACAlQ,EAAAniB,UAAA4yB,EAAA,EAAAP,MACK,IAAAE,EAAAG,EAAAD,EAAA,CACL,GAAA5yB,GAAAtU,KAAAL,IAAAmnC,GAAAQ,EAAAF,EAAAJ,GAAAE,EACA5yB,IAAA6yB,IAAAvQ,EAAAniB,UAAAH,GAGA,GAAAizB,GAAAnjC,EAAAgc,SAAA7c,YAAA2c,GAAAsnB,EAAApjC,EAAAgc,SAAA2F,UACA8gB,IAAAziC,EAAA2W,QAAAnI,YAAsCm0B,GAAA3iC,EAAA2W,QAAAnI,WACtC,IAAA60B,GAAArjC,EAAA2W,QAAAnI,YACA80B,EAAAD,EAAA,GAAAZ,CAOA,OANAW,GAAAC,EAAAZ,GAAAa,GACAA,IAAAb,EAAA,GACAjQ,EAAA7Q,WAAA/lB,KAAAoL,IAAA,EAAAy7B,EAAA,GAAAY,IACKV,EAAAQ,EAAAC,EAAA,IACL5Q,EAAA7Q,WAAAghB,EAAA,GAAAQ,GAEA3Q,EAGA,QAAArB,IAAA3zB,EAAA0G,EAAAiK,GACA3Q,EAAA6gB,MAAA8S,iBAAgCxP,WAAA,MAAAzd,EAAA1G,EAAA2c,IAAAwH,WAAAzd,EAChCmM,UAAA,MAAAlC,EAAA3Q,EAAA2c,IAAA9J,UAAAlC,GAGA,QAAAo1B,IAAA/lC,EAAA0G,EAAAiK,GACA,GAAAhN,GAAA3D,EAAA6gB,MAAA8S,kBAAA3zB,EAAA6gB,MAAA8S,iBAAuExP,WAAAnkB,EAAA2c,IAAAwH,WAAAtR,UAAA7S,EAAA2c,IAAA9J,YACvE0qB,EAAAv9B,EAAAwC,QAAAgc,QACA7a,GAAAkP,UAAAzU,KAAAoL,IAAA,EAAApL,KAAAL,IAAAw/B,EAAApa,aAAAoa,EAAA37B,aAAA+B,EAAAkP,UAAAlC,IACAhN,EAAAwgB,WAAA/lB,KAAAoL,IAAA,EAAApL,KAAAL,IAAAw/B,EAAAla,YAAAka,EAAA57B,YAAAgC,EAAAwgB,WAAAzd,IAKA,QAAAzG,IAAAD,EAAAiD,EAAA+iC,EAAAC,GACA,GAAA/hC,GAAAyY,EAAA3c,EAAA2c,GACA,OAAAqpB,MAAA,OACA,SAAAA,IACAhmC,EAAA2c,IAAAzd,KAAAhB,OACAgG,EAAA4oB,EAAA9sB,EAAAiD,GADA+iC,EAAA,OAIA,IAAArY,GAAA3tB,EAAAU,QAAAitB,QACA3vB,EAAAkJ,GAAAyV,EAAA1Z,GAAAijC,EAAAxY,GAAA1vB,EAAAJ,KAAA,KAAA+vB,EACA3vB,GAAAyiB,aAAAziB,EAAAyiB,WAAA,KACA,IAAA0lB,GAAAC,EAAApoC,EAAAJ,KAAAxH,MAAA,UACA,IAAA6vC,GAAA,KAAA9vC,KAAA6H,EAAAJ,OAGK,YAAAooC,IACLG,EAAAnmC,EAAA2c,IAAAzd,KAAAhB,OAAAgG,EAAAlG,EAAAJ,KAAAW,MAAA6nC,EAAA1tC,QAAAsF,EAAAJ,MACAuoC,GAAA7/B,IAAA,CACA,IAAA2/B,EAAA,MACAD,GAAA,YANAG,GAAA,EACAH,EAAA,KAQA,SAAAA,EACAG,EAAAljC,EAAA0Z,EAAAjB,MAAAgS,GAAAxmB,GAAAyV,EAAA1Z,EAAA,GAAArF,KAAA,KAAA+vB,GACA,EACK,OAAAqY,EACLG,EAAAD,EAAAlmC,EAAAU,QAAA2lC,WACK,YAAAL,EACLG,EAAAD,EAAAlmC,EAAAU,QAAA2lC,WACK,gBAAAL,KACLG,EAAAD,EAAAF,GAEAG,EAAA/nC,KAAAoL,IAAA,EAAA28B,EAEA,IAAAG,GAAA,GAAA3iC,EAAA,CACA,IAAA3D,EAAAU,QAAA6lC,eACA,OAAA3rC,GAAAwD,KAAAuW,MAAAwxB,EAAAxY,GAAqD/yB,IAAGA,EAAO+I,GAAAgqB,EAAe2Y,GAAA,GAC9EH,GAAAxiC,IAAA2iC,GAAAE,GAAAL,EAAAxiC,IAEA2iC,GAAAF,EACAtiC,GAAA9D,EAAA2c,IAAA2pB,EAAA1gC,GAAA3C,EAAA,GAAA2C,GAAA3C,EAAAmjC,EAAA1tC,QAAA,UACAikB,EAAAxB,IAAA5lB,KAAAyI,MAAAiF,GAAA0Z,EAAAxB,IAAA5lB,KAAA8N,GAAA+iC,EAAA1tC,QACAoN,GAAA6W,EAAA/W,GAAA3C,EAAAmjC,EAAA1tC,QAAAkN,GAAA3C,EAAAmjC,EAAA1tC,QAAA,GACAsF,EAAAyiB,WAAA,KAGA,QAAAgmB,IAAAzmC,EAAAwO,EAAAwlB,GACA,GAAA0S,GAAAl4B,EAAAxQ,EAAAwQ,EAAAmO,EAAA3c,EAAA2c,GAGA,OAFA,gBAAAnO,GAAAxQ,EAAAkJ,GAAAyV,EAAA4mB,GAAA5mB,EAAAnO,IACAk4B,EAAAh+B,GAAA8F,GACA,MAAAk4B,EAAA,KACA1S,EAAAh2B,EAAA0oC,IAAA5lB,GAAA9gB,EAAA0mC,IAAA,GAEA1oC,GADA,KAIA,QAAA2oC,IAAAhqB,EAAAhZ,EAAA9J,EAAA+sC,EAAAC,GAIA,QAAAC,KACA,GAAApsC,GAAAsD,EAAAnE,CACA,OAAAa,GAAAiiB,EAAAjB,OAAAhhB,GAAAiiB,EAAAjB,MAAAiB,EAAA+H,KAAAqiB,GAAA,GACA/oC,EAAAtD,EACAmsB,EAAA3f,GAAAyV,EAAAjiB,IAEA,QAAAssC,GAAAC,GACA,GAAAl5B,IAAA84B,EAAAhU,GAAAqU,IAAArgB,EAAAxjB,EAAAxJ,GAAA,EACA,UAAAkU,EAAA,CACA,GAAAk5B,IAAAH,IAGS,MAAAC,IAAA,CAFT1jC,GAAAwjC,GAAA,EAAAhtC,EAAA24B,GAAAD,IAAA1L,GACA,EAAAhtB,EAAAgtB,EAAAjpB,KAAAlF,OAAA,MAEO2K,GAAA0K,CACP,UAjBA,GAAA/P,GAAA2F,EAAA3F,KAAAqF,EAAAM,EAAAN,GAAA8jC,EAAAttC,EACAgtB,EAAA3f,GAAAyV,EAAA3e,GACA+oC,GAAA,CAkBA,YAAAH,EAAAI,QACA,cAAAJ,EAAAI,GAAA,OACA,YAAAJ,GAAA,SAAAA,EAEA,OADAQ,GAAA,KAAAC,EAAA,SAAAT,EACAlrB,GAAA,IACA,EAAA7hB,IAAAmtC,GAAAtrB,GAD6BA,GAAA,GAE7B,GAAAnV,GAAAsgB,EAAAjpB,KAAAwJ,OAAA/D,IAAA,KACAnO,EAAAoS,GAAAf,GAAA,IACA8gC,GAAA,MAAA9gC,EAAA,KACA8gC,GAAA,KAAAlxC,KAAAoQ,GAAA,KACA,GAEA,KADA8gC,GAAA3rB,GAAAxmB,MAAA,KACAkyC,MAAAlyC,EAAA,CACA,EAAA2E,IAAwBA,EAAA,EAAQmtC,IAChC,OAIA,GADA9xC,IAAAkyC,EAAAlyC,GACA2E,EAAA,IAAAmtC,GAAAtrB,GAAA,MAGA,GAAAsZ,GAAA+O,GAAApnB,EAAA/W,GAAA5H,EAAAqF,GAAA8jC,GAAA,EAEA,OADAJ,KAAA/R,EAAAsS,SAAA,GACAtS,EAGA,QAAAuS,IAAAvnC,EAAA2D,EAAA9J,EAAA+sC,GACA,GAAA9U,GAAAnV,EAAA3c,EAAA2c,IAAAkV,EAAAluB,EAAA+C,IACA,YAAAkgC,EAAA,CACA,GAAAY,GAAAppC,KAAAL,IAAAiC,EAAAwC,QAAAlL,QAAAsK,aAAAtN,OAAA6c,aAAAzc,SAAAuc,gBAAArP,aACAkwB,GAAAnuB,EAAAgN,IAAA9W,GAAA2tC,GAAA,EAAA3tC,EAAA,QAAAynB,GAAAthB,EAAAwC,cACK,QAAAokC,IACL9U,EAAAj4B,EAAA,EAAA8J,EAAAiN,OAAA,EAAAjN,EAAAgN,IAAA,EAEA,QAAW,CACX,GAAArT,GAAAyb,GAAA/Y,EAAA6xB,EAAAC,EACA,KAAAx0B,EAAAq0B,QAAA,KACA,MAAA93B,EAAA,GAAAi4B,KAAAnV,EAAAnL,OAAA,CAA+ClU,EAAAgqC,SAAA,CAAuB,OACtExV,GAAA,EAAAj4B,EAEA,MAAAyD,GAGA,QAAA66B,IAAAn6B,EAAA2F,GACA,GAAA8B,GAAA9B,EAAAN,GAAAqC,EAAA/B,EAAAN,EACA,IAAArF,EAAA,EACA2F,EAAAiuB,KAAA,GAAAlsB,GAAA1H,EAAAtF,SAAA+M,QAAiEC,CAKjE,KAJA,GAAA+hC,GAAAzpC,EAAAoJ,OAAA3B,GACAiiC,EAAApgC,GAAAmgC,GAAAngC,GACA,KAAAnR,KAAAsxC,GAAA,SAAApkC,GAA+C,WAAAlN,KAAAkN,IAC/C,SAAAA,GAAwB,YAAAlN,KAAAkN,KAAAiE,GAAAjE,IACxBoC,EAAA,GAAAiiC,EAAA1pC,EAAAoJ,OAAA3B,EAAA,OAAAA,CACA,MAAAC,EAAA1H,EAAAtF,QAAAgvC,EAAA1pC,EAAAoJ,OAAA1B,SAEA,OAAYpC,KAAAsC,GAAAjC,EAAA3F,KAAAyH,GAAAlC,GAAAqC,GAAAjC,EAAA3F,KAAA0H,IAGZ,QAAA20B,IAAAr6B,EAAAhC,GACAo6B,GAAAp4B,EAAA2c,IAAA/W,GAAA5H,EAAA,GAAA2H,GAAA3F,EAAA2c,IAAA/W,GAAA5H,EAAA,OA+aA,QAAA2pC,IAAAnuC,EAAAouC,EAAAp5B,EAAAq5B,GACAznC,EAAAmb,SAAA/hB,GAAAouC,EACAp5B,IAAA2O,GAAA3jB,GACAquC,EAAA,SAAA7nC,EAAA+H,EAAAC,GAA0CA,GAAAC,IAAAuG,EAAAxO,EAAA+H,EAAAC,IAAuCwG,GAiMjF,QAAAqe,IAAA3tB,EAAAgF,GACA,GAAAA,KAAA,QAAAA,EACA,IAAAhF,EAAA2tB,UAAA,MAAA3tB,GAAA2tB,UAAA3oB,EACA,IAAA4jC,KACA,QAAA7kC,KAAAiB,GAAA,CACA,GAAA6D,GAAA7D,EAAAjB,EACA8E,aAAAmE,SAAAnE,IAAA8a,YACAilB,EAAA7kC,GAAA8E,EAEA,MAAA+/B,GAIA,QAAAvb,IAAArtB,EAAA6oC,EAAAC,GACA,MAAA9oC,GAAAqtB,WAAArtB,EAAAqtB,WAAAwb,EAAAC,IAAA,EA+IA,QAAA3J,IAAAt2B,GACA,sBAAAA,GAAA6J,GAAA7J,GACAA,EAGA,QAAA42B,IAAAnlC,EAAA0kC,EAAA1vB,GACA,QAAAy5B,GAAA3pC,GACAA,EAAA+/B,GAAA//B,EACA,IAAAgL,GAAAhL,EAAA9E,EACA,IAAA8P,KAAA,cACA,UAAAA,GAAAkF,EAAAlF,GAAA,QACA,IAAAhL,EAAA4pC,cAAA,YAEA,IAAAC,GAAA7pC,EAAA6pC,WACA,UAAAA,EAAA,QACA,sBAAAt8B,OAAAC,UAAAs8B,SAAAj0C,KAAAg0C,GACA,MAAAF,GAAAE,EACA,QAAAvtC,GAAA,EAAAyC,EAAA8qC,EAAAzvC,OAA6C2E,EAAAzC,IAAOA,EAAA,CACpD,GAAA+Y,GAAAs0B,EAAAE,EAAAvtC,GACA,IAAA+Y,EAAA,MAAAA,GAEA,SAGA,OAAA/Y,GAAA,EAAmBA,EAAAsjC,EAAAxlC,SAAiBkC,EAAA,CACpC,GAAA+Y,GAAAs0B,EAAA/J,EAAAtjC,GACA,IAAA+Y,EAAA,cAAAA,GAGA,QAAA4qB,IAAA/mC,GACA,GAAAgC,GAAA6uC,GAAA7wC,EAAAsnC,QACA,eAAAtlC,GAAA,OAAAA,GAAA,SAAAA,GAAA,OAAAA,EAEA,QAAAglC,IAAAhnC,EAAA8wC,GACA,GAAA5L,IAAA,IAAAllC,EAAAsnC,SAAAtnC,EAAA,gBACA,IAAAgC,GAAA6uC,GAAA7wC,EAAAsnC,QACA,cAAAtlC,GAAAhC,EAAA+wC,aAAA,GACA/wC,EAAAgxC,SAAAhvC,EAAA,OAAAA,IACAivC,GAAAjxC,EAAA4nC,QAAA5nC,EAAA6nC,WAAA7lC,EAAA,QAAAA,IACAivC,GAAAjxC,EAAA6nC,QAAA7nC,EAAA4nC,WAAA5lC,EAAA,OAAAA,IACA8uC,GAAA9wC,EAAAyiC,WAAAzgC,EAAA,SAAAA,GACAA,GAmEA,QAAAkvC,IAAAh8B,EAAAihB,GACAvyB,KAAAuI,IAAAvI,KAAAqK,MAAA,EACArK,KAAAsR,SACAtR,KAAAuyB,WAAA,EACAvyB,KAAAutC,cAAAvtC,KAAAwtC,gBAAA,EACAxtC,KAAAytC,UAAA,EAsEA,QAAAC,IAAAnsB,EAAAznB,GACAkG,KAAAiH,SACAjH,KAAAlG,OACAkG,KAAAuhB,MA6FA,QAAA/S,IAAA+S,EAAArZ,EAAAC,EAAA7C,EAAAxL,GACA,GAAAwL,KAAAqoC,OAAA,MAAAC,IAAArsB,EAAArZ,EAAAC,EAAA7C,EAAAxL,EACA,IAAAynB,EAAA3c,KAAA2c,EAAA3c,GAAA6gB,MAAA,MAAAnZ,IAAAiV,EAAA3c,GAAA4J,IAAA+S,EAAArZ,EAAAC,EAAA7C,EAAAxL,EAEA,IAAAkiB,GAAA,GAAA0xB,IAAAnsB,EAAAznB,EAEA,IADAwL,GAAAuoC,GAAAvoC,EAAA0W,GACAsiB,GAAAn2B,EAAAD,IAAAJ,GAAAI,EAAAC,IAAA6T,EAAA8xB,kBAAA,EACA,MAAA9xB,EAMA,IALAA,EAAA+xB,eACA/xB,EAAA8S,WAAA,EACA9S,EAAA+xB,aAAAh5B,GAAA,QAAAiH,EAAA+xB,cAAA,qBACAzoC,EAAA6nB,oBAAAnR,EAAA+xB,aAAA3gB,cAAA,IAEApR,EAAA8S,UAAA,CACA,GAAAkf,GAAAzsB,EAAArZ,EAAAtF,KAAAsF,EAAAC,EAAA6T,IACA9T,EAAAtF,MAAAuF,EAAAvF,MAAAorC,GAAAzsB,EAAApZ,EAAAvF,KAAAsF,EAAAC,EAAA6T,GACA,SAAA3d,OAAA,mEACAwsB,KAAA,EAGA7O,EAAAgqB,cACAA,GAAAzkB,GAAyBrZ,OAAAC,KAAAoB,OAAA,aACLpP,KAAAonB,EAAAxB,IAAA5lB,KAAAiS,OAAAmV,EAAAxB,IAAA3T,QAA2C65B,IAE/D,IAAA3N,GAAAvoB,EAAA7H,EAAAtF,KAAAgC,EAAA2c,EAAA3c,EAgCA,OA/BA2c,GAAA6D,KAAArV,EAAA5H,EAAAvF,KAAA,WAAAA,GACAgC,GAAAoX,EAAA8S,YAAAlqB,EAAAU,QAAAG,cAAAqlB,GAAAvJ,EAAA3e,IAAAgC,EAAAwC,QAAAsd,UACA4T,GAAA,EACA,IAAAza,IAAkB3V,KAAA,KAAAC,GAAA,KAAA6T,SAClBjM,IAAA7H,EAAAtF,OAAAib,EAAA3V,OAAAD,IACA8H,GAAA5H,EAAAvF,OAAAib,EAAA1V,KAAAF,IACA+T,EAAA8S,WAAA/e,GAAA7H,EAAAtF,MAAA8jB,GAAA9jB,EAAA,GACAqrC,GAAArrC,EAAAib,KACA9N,IAEAiM,EAAA8S,WAAAvN,EAAA6D,KAAAld,EAAAtF,KAAAuF,EAAAvF,KAAA,WAAAA,GACA0jB,GAAA/E,EAAA3e,IAAA8jB,GAAA9jB,EAAA,KAGAoZ,EAAAkyB,cAAAxyC,GAAAsgB,EAAA,+BAAyEA,EAAAnN,UAEzEmN,EAAA4f,WACAgK,IAAA,GACArkB,EAAAglB,QAAAhuB,KAAAjb,QAAAikB,EAAAglB,QAAAI,OAAArpC,SACAikB,EAAA4sB,gBAEAnyB,EAAA8S,YACA9S,EAAAnjB,KAAAu1C,GACApyB,EAAAotB,QAAA,GAEAxkC,IACA0zB,IAAA1zB,EAAA6gB,MAAA6S,eAAA,IACAtc,EAAAvN,WAAAuN,EAAAle,OAAAke,EAAAqyB,YAAAryB,EAAAsyB,UAAAtyB,EAAA8S,YACApJ,GAAA9gB,EAAAsD,EAAAtF,KAAAuF,EAAAvF,KAAA,GACAoZ,EAAAotB,QAAAP,GAAAjkC,IAEAoX,EAKA,QAAAuyB,IAAAtgB,EAAAugB,GACAxuC,KAAAiuB,UACAjuB,KAAAwuC,SACA,QAAAhvC,GAAA,EAAAivC,EAAAzuC,KAA8BR,EAAAyuB,EAAA3wB,SAAoBkC,EAClDyuB,EAAAzuB,GAAAkvC,OAAA1uC,KACAtE,GAAAuyB,EAAAzuB,GAAA,mBAAyCivC,EAAA5/B,UAiBzC,QAAA++B,IAAArsB,EAAArZ,EAAAC,EAAA7C,EAAAxL,GACAwL,EAAAuoC,GAAAvoC,GACAA,EAAAqoC,QAAA,CACA,IAAA1f,IAAAzf,GAAA+S,EAAArZ,EAAAC,EAAA7C,EAAAxL,IAAA00C,EAAAvgB,EAAA,GACAlb,EAAAzN,EAAAyoC,YAQA,OAPA1H,IAAA9kB,EAAA,SAAAA,GACAxO,IAAAzN,EAAAyoC,aAAAh7B,EAAAuH,WAAA,IACA2T,EAAAxwB,KAAA+Q,GAAA+S,EAAAhX,GAAAgX,EAAArZ,GAAAqC,GAAAgX,EAAApZ,GAAA7C,EAAAxL,GACA,QAAA0F,GAAA,EAAqBA,EAAA+hB,EAAAotB,OAAArxC,SAAuBkC,EAC5C,GAAA+hB,EAAAotB,OAAAnvC,GAAAovC,SAAA,MACAJ,GAAAtJ,GAAAjX,KAEA,GAAAsgB,IAAAtgB,EAAAugB,GAKA,QAAAK,IAAApxB,EAAAzB,GACA,GAAAyB,EAAA,OAAAje,GAAA,EAA8BA,EAAAie,EAAAngB,SAAkBkC,EAAA,CAChD,GAAAqe,GAAAJ,EAAAje,EACA,IAAAqe,EAAA7B,UAAA,MAAA6B,IAGA,QAAAixB,IAAArxB,EAAAI,GACA,OAAAiV,GAAAtzB,EAAA,EAAsBA,EAAAie,EAAAngB,SAAkBkC,EACxCie,EAAAje,IAAAqe,IAAAiV,WAAAr1B,KAAAggB,EAAAje,GACA,OAAAszB,GAEA,QAAAmb,IAAArrC,EAAAib,GACAjb,EAAAqwB,YAAArwB,EAAAqwB,YAAArwB,EAAAqwB,YAAAxL,QAAA5J,QACAA,EAAA7B,OAAA+yB,WAAAnsC,GAGA,QAAAosC,IAAApiC,EAAAqiC,EAAAC,GACA,GAAAtiC,EAAA,OAAAuiC,GAAA3vC,EAAA,EAAgCA,EAAAoN,EAAAtP,SAAgBkC,EAAA,CAChD,GAAAqe,GAAAjR,EAAApN,GAAAwc,EAAA6B,EAAA7B,OACAozB,EAAA,MAAAvxB,EAAA3V,OAAA8T,EAAAitB,cAAAprB,EAAA3V,MAAA+mC,EAAApxB,EAAA3V,KAAA+mC,EACA,IAAAG,GAAAvxB,EAAA3V,MAAA+mC,GAAA,YAAAjzB,EAAAliB,QAAAo1C,IAAArxB,EAAA7B,OAAAqzB,YAAA,CACA,GAAAC,GAAA,MAAAzxB,EAAA1V,KAAA6T,EAAAktB,eAAArrB,EAAA1V,IAAA8mC,EAAApxB,EAAA1V,GAAA8mC,IACAE,WAAA1xC,MAAgCyK,KAAA2V,EAAA3V,KAChCC,GAAAmnC,EAAA,KAAAzxB,EAAA1V,GACA6T,YAGA,MAAAmzB,GAGA,QAAAI,IAAA3iC,EAAA4iC,EAAAN,GACA,GAAAtiC,EAAA,OAAAuiC,GAAA3vC,EAAA,EAAgCA,EAAAoN,EAAAtP,SAAgBkC,EAAA,CAChD,GAAAqe,GAAAjR,EAAApN,GAAAwc,EAAA6B,EAAA7B,OACAszB,EAAA,MAAAzxB,EAAA1V,KAAA6T,EAAAktB,eAAArrB,EAAA1V,IAAAqnC,EAAA3xB,EAAA1V,GAAAqnC,EACA,IAAAF,GAAAzxB,EAAA3V,MAAAsnC,GAAA,YAAAxzB,EAAAliB,QAAAo1C,GAAArxB,EAAA7B,OAAAqzB,YAAA,CACA,GAAAD,GAAA,MAAAvxB,EAAA3V,OAAA8T,EAAAitB,cAAAprB,EAAA3V,MAAAsnC,EAAA3xB,EAAA3V,KAAAsnC,IACAL,WAAA1xC,MAAgCyK,KAAAknC,EAAA,KAAAvxB,EAAA3V,KAAAsnC,EAChCrnC,GAAA,MAAA0V,EAAA1V,GAAA,KAAA0V,EAAA1V,GAAAqnC,EACAxzB,YAGA,MAAAmzB,GAGA,QAAAhJ,IAAA5kB,EAAAsK,GACA,GAAA4jB,GAAApH,GAAA9mB,EAAAsK,EAAA3jB,KAAAtF,OAAAkJ,GAAAyV,EAAAsK,EAAA3jB,KAAAtF,MAAAqwB,YACAyc,EAAArH,GAAA9mB,EAAAsK,EAAA1jB,GAAAvF,OAAAkJ,GAAAyV,EAAAsK,EAAA1jB,GAAAvF,MAAAqwB,WACA,KAAAwc,IAAAC,EAAA,WAEA,IAAAT,GAAApjB,EAAA3jB,KAAAD,GAAAunC,EAAA3jB,EAAA1jB,GAAAF,GAAAinC,EAAApnC,GAAA+jB,EAAA3jB,KAAA2jB,EAAA1jB,IAEAmY,EAAA0uB,GAAAS,EAAAR,EAAAC,GACA9lB,EAAAmmB,GAAAG,EAAAF,EAAAN,GAGAS,EAAA,GAAA9jB,EAAArpB,KAAAlF,OAAAsyC,EAAA1K,GAAArZ,EAAArpB,MAAAlF,QAAAqyC,EAAAV,EAAA,EACA,IAAA3uB,EAEA,OAAA9gB,GAAA,EAAqBA,EAAA8gB,EAAAhjB,SAAkBkC,EAAA,CACvC,GAAAqe,GAAAyC,EAAA9gB,EACA,UAAAqe,EAAA1V,GAAA,CACA,GAAA+F,GAAA2gC,GAAAzlB,EAAAvL,EAAA7B,OACA9N,GACAyhC,IAAA9xB,EAAA1V,GAAA,MAAA+F,EAAA/F,GAAA,KAAA+F,EAAA/F,GAAAynC,GADA/xB,EAAA1V,GAAA8mC,GAKA,GAAA7lB,EAEA,OAAA5pB,GAAA,EAAqBA,EAAA4pB,EAAA9rB,SAAiBkC,EAAA,CACtC,GAAAqe,GAAAuL,EAAA5pB,EAEA,IADA,MAAAqe,EAAA1V,KAAA0V,EAAA1V,IAAAynC,GACA,MAAA/xB,EAAA3V,KAAA,CACA,GAAAgG,GAAA2gC,GAAAvuB,EAAAzC,EAAA7B,OACA9N,KACA2P,EAAA3V,KAAA0nC,EACAD,IAAArvB,WAAA7iB,KAAAogB,QAGAA,GAAA3V,MAAA0nC,EACAD,IAAArvB,WAAA7iB,KAAAogB,GAKAyC,MAAAuvB,GAAAvvB,IACA8I,MAAA9I,IAAA8I,EAAAymB,GAAAzmB,GAEA,IAAA0mB,IAAAxvB,EACA,KAAAqvB,EAAA,CAEA,GAAAI,GAAAC,EAAAnkB,EAAArpB,KAAAlF,OAAA,CACA,IAAA0yC,EAAA,GAAA1vB,EACA,OAAA9gB,GAAA,EAAuBA,EAAA8gB,EAAAhjB,SAAkBkC,EACzC,MAAA8gB,EAAA9gB,GAAA2I,KACA4nC,WAAAtyC,MAAoDyK,KAAA,KAAAC,GAAA,KAAA6T,OAAAsE,EAAA9gB,GAAAwc,QACpD,QAAAxc,GAAA,EAAqBwwC,EAAAxwC,IAASA,EAC9BswC,EAAAryC,KAAAsyC,EACAD,GAAAryC,KAAA2rB,GAEA,MAAA0mB,GAGA,QAAAD,IAAApyB,GACA,OAAAje,GAAA,EAAmBA,EAAAie,EAAAngB,SAAkBkC,EAAA,CACrC,GAAAqe,GAAAJ,EAAAje,EACA,OAAAqe,EAAA3V,MAAA2V,EAAA3V,MAAA2V,EAAA1V,IAAA0V,EAAA7B,OAAA8xB,kBAAA,GACArwB,EAAAiK,OAAAloB,IAAA,GAEA,MAAAie,GAAAngB,OACAmgB,EADA,KAIA,QAAA6pB,IAAA/lB,EAAAsK,GACA,GAAAjf,GAAAqjC,GAAA1uB,EAAAsK,GACAqkB,EAAA/J,GAAA5kB,EAAAsK,EACA,KAAAjf,EAAA,MAAAsjC,EACA,KAAAA,EAAA,MAAAtjC,EAEA,QAAApN,GAAA,EAAmBA,EAAAoN,EAAAtP,SAAgBkC,EAAA,CACnC,GAAA2wC,GAAAvjC,EAAApN,GAAA4wC,EAAAF,EAAA1wC,EACA,IAAA2wC,GAAAC,EACA3yB,EAAA,OAAAG,GAAA,EAA8BA,EAAAwyB,EAAA9yC,SAAuBsgB,EAAA,CAErD,OADAC,GAAAuyB,EAAAxyB,GACA6Q,EAAA,EAAyBA,EAAA0hB,EAAA7yC,SAAmBmxB,EAC5C,GAAA0hB,EAAA1hB,GAAAzS,QAAA6B,EAAA7B,OAAA,QAAAyB,EACA0yB,GAAA1yC,KAAAogB,OAEOuyB,KACPxjC,EAAApN,GAAA4wC,GAGA,MAAAxjC,GAGA,QAAAi5B,IAAAtkB,EAAArZ,EAAAC,GACA,GAAA8lB,GAAA,IAQA,IAPA1M,EAAA6D,KAAAld,EAAAtF,KAAAuF,EAAAvF,KAAA,WAAAA,GACA,GAAAA,EAAAqwB,YAAA,OAAAzzB,GAAA,EAA2CA,EAAAoD,EAAAqwB,YAAA31B,SAA6BkC,EAAA,CACxE,GAAA6wC,GAAAztC,EAAAqwB,YAAAzzB,GAAAwc,QACAq0B,EAAAzU,UAAA3N,GAAA,IAAAnuB,GAAAmuB,EAAAoiB,KACApiB,WAAAxwB,KAAA4yC,OAGApiB,EAAA,WAEA,QADAqiB,KAAkBpoC,OAAAC,OAClB3I,EAAA,EAAmBA,EAAAyuB,EAAA3wB,SAAoBkC,EAEvC,OADA+wC,GAAAtiB,EAAAzuB,GAAA+Q,EAAAggC,EAAAjpB,OACA1J,EAAA,EAAqBA,EAAA0yB,EAAAhzC,SAAkBsgB,EAAA,CACvC,GAAA3kB,GAAAq3C,EAAA1yB,EACA,KAAA0gB,GAAArlC,EAAAkP,GAAAoI,EAAArI,QAAAo2B,GAAA/tB,EAAApI,GAAAlP,EAAAiP,MAAA,CACA,GAAAsoC,IAAA5yB,EAAA,IACA0gB,GAAArlC,EAAAiP,KAAAqI,EAAArI,QAAAqoC,EAAAtH,eAAAnhC,GAAA7O,EAAAiP,KAAAqI,EAAArI,QACAsoC,EAAA/yC,MAAyByK,KAAAjP,EAAAiP,KAAAC,GAAAoI,EAAArI,QACzBo2B,GAAA/tB,EAAApI,GAAAlP,EAAAkP,MAAAooC,EAAArH,gBAAAphC,GAAA7O,EAAAkP,GAAAoI,EAAApI,MACAqoC,EAAA/yC,MAAyByK,KAAAqI,EAAApI,MAAAlP,EAAAkP,KACzBmoC,EAAA5oB,OAAAmS,MAAAyW,EAAAE,GACA5yB,GAAA4yB,EAAAlzC,OAAA,GAGA,MAAAgzC,GAGA,QAAAG,IAAAz0B,GAA8B,MAAAA,GAAAitB,cAAA,KAC9B,QAAAyH,IAAA10B,GAA+B,MAAAA,GAAAktB,eAAA,IAE/B,QAAAyH,IAAA5oC,EAAAC,GACA,GAAA4oC,GAAA7oC,EAAAd,MAAA3J,OAAA0K,EAAAf,MAAA3J,MACA,OAAAszC,EAAA,MAAAA,EACA,IAAAC,GAAA9oC,EAAAuf,OAAAwpB,EAAA9oC,EAAAsf,OACAypB,EAAA9I,GAAA4I,EAAA3oC,KAAA4oC,EAAA5oC,OAAAuoC,GAAA1oC,GAAA0oC,GAAAzoC,EACA,IAAA+oC,EAAA,OAAAA,CACA,IAAAC,GAAA/I,GAAA4I,EAAA1oC,GAAA2oC,EAAA3oC,KAAAuoC,GAAA3oC,GAAA2oC,GAAA1oC,EACA,OAAAgpC,KACAhpC,EAAAnP,GAAAkP,EAAAlP,GAGA,QAAAo4C,IAAAruC,EAAAyH,GACA,GAAA6D,GAAAgjC,EAAArmB,IAAAjoB,EAAAqwB,WACA,IAAAie,EAAA,OAAApc,GAAAt1B,EAAA,EAAgCA,EAAA0xC,EAAA5zC,SAAgBkC,EAChDs1B,EAAAoc,EAAA1xC,GACAs1B,EAAA9Y,OAAA8S,WAAA,OAAAzkB,EAAAyqB,EAAA5sB,KAAA4sB,EAAA3sB,OACA+F,GAAAyiC,GAAAziC,EAAA4mB,EAAA9Y,QAAA,KACA9N,EAAA4mB,EAAA9Y,OAEA,OAAA9N,GAEA,QAAAmZ,IAAAzkB,GAAuC,MAAAquC,IAAAruC,GAAA,GACvC,QAAA2kB,IAAA3kB,GAAqC,MAAAquC,IAAAruC,GAAA,GAErC,QAAAorC,IAAAzsB,EAAAjU,EAAApF,EAAAC,EAAA6T,GACA,GAAApZ,GAAAkJ,GAAAyV,EAAAjU,GACA4jC,EAAArmB,IAAAjoB,EAAAqwB,WACA,IAAAie,EAAA,OAAA1xC,GAAA,EAA4BA,EAAA0xC,EAAA5zC,SAAgBkC,EAAA,CAC5C,GAAAs1B,GAAAoc,EAAA1xC,EACA,IAAAs1B,EAAA9Y,OAAA8S,UAAA,CACA,GAAA5gB,GAAA4mB,EAAA9Y,OAAAsL,MAAA,GACAypB,EAAA9I,GAAA/5B,EAAAhG,SAAAuoC,GAAA3b,EAAA9Y,QAAAy0B,GAAAz0B,GACAg1B,EAAA/I,GAAA/5B,EAAA/F,OAAAuoC,GAAA5b,EAAA9Y,QAAA00B,GAAA10B,EACA,MAAA+0B,GAAA,MAAAC,GAAA,GAAAD,GAAAC,GAAA,KACA,GAAAD,IAAA9I,GAAA/5B,EAAA/F,GAAAD,IAAAwoC,GAAA5b,EAAA9Y,QAAAy0B,GAAAz0B,IAAA,GACA+0B,GAAA,IAAA9I,GAAA/5B,EAAAhG,KAAAC,IAAAsoC,GAAA3b,EAAA9Y,QAAA00B,GAAA10B,IAAA,GACA,WAIA,QAAA8O,IAAAvJ,EAAA3e,GAEA,IADA,GAAAukB,GACAA,EAAAE,GAAAzkB,IACAA,EAAAkJ,GAAAyV,EAAA4F,EAAAG,OAAApf,KAAAtF,KACA,OAAAA,GAGA,QAAA0jB,IAAA/E,EAAA3e,GACA,GAAAsuC,GAAArmB,IAAAjoB,EAAAqwB,WACA,IAAAie,EAAA,OAAApc,GAAAt1B,EAAA,EAAgCA,EAAA0xC,EAAA5zC,SAAgBkC,EAEhD,GADAs1B,EAAAoc,EAAA1xC,GACAs1B,EAAA9Y,OAAA8S,UAAA,CACA,SAAAgG,EAAA5sB,KAAA,QACA,KAAA4sB,EAAA9Y,OAAA+xB,cACA,GAAAjZ,EAAA5sB,MAAA4sB,EAAA9Y,OAAAitB,eAAAkI,GAAA5vB,EAAA3e,EAAAkyB,GACA,UAGA,QAAAqc,IAAA5vB,EAAA3e,EAAAib,GACA,SAAAA,EAAA1V,GAAA,CACA,GAAAmC,GAAAuT,EAAA7B,OAAAsL,OAAAnf,GAAAiI,EAAAtE,GAAAyV,EAAAjX,EAAA1H,KACA,OAAAuuC,IAAA5vB,EAAAnR,EAAAy+B,GAAAz+B,EAAA6iB,YAAApV,EAAA7B,SAEA,GAAA6B,EAAA7B,OAAAktB,gBAAArrB,EAAA1V,IAAAvF,EAAAJ,KAAAlF,OACA,QACA,QAAAw3B,GAAAt1B,EAAA,EAAuBA,EAAAoD,EAAAqwB,YAAA31B,SAA6BkC,EAEpD,GADAs1B,EAAAlyB,EAAAqwB,YAAAzzB,GACAs1B,EAAA9Y,OAAA8S,YAAAgG,EAAA9Y,OAAA+xB,cAAAjZ,EAAA5sB,MAAA2V,EAAA1V,KACA,MAAA2sB,EAAA3sB,IAAA2sB,EAAA3sB,IAAA0V,EAAA3V,QACA4sB,EAAA9Y,OAAAitB,eAAAprB,EAAA7B,OAAAktB,iBACAiI,GAAA5vB,EAAA3e,EAAAkyB,GAAA,SAIA,QAAAsc,IAAAxuC,GACA,GAAA6a,GAAA7a,EAAAqwB,WACA,IAAAxV,EAAA,CACA,OAAAje,GAAA,EAAmBA,EAAAie,EAAAngB,SAAkBkC,EACrCie,EAAAje,GAAAwc,OAAAq1B,WAAAzuC,EACAA,GAAAqwB,YAAA,MAGA,QAAAqe,IAAA1uC,EAAA6a,GACA,GAAAA,EAAA,CACA,OAAAje,GAAA,EAAmBA,EAAAie,EAAAngB,SAAkBkC,EACrCie,EAAAje,GAAAwc,OAAA+yB,WAAAnsC,EACAA,GAAAqwB,YAAAxV,GAYA,QAAA8zB,IAAAv0C,GACA,kBACA,GAAA28B,IAAA35B,KAAA4E,GAAA6gB,KACAkU,IAAA3B,GAAAh4B,KAAA4E,GACA,KAAW,GAAAg1B,GAAA58B,EAAA68B,MAAA75B,KAAAsE,WACX,QAAeq1B,GAAAhB,GAAA34B,KAAA4E,IACf,MAAAg1B,IAuBA,QAAAxE,IAAAriB,GACA,aAAAA,EAAAqD,OAAArD,EAAAqD,QACArD,EAAAsG,KAAA1V,YAAA,GAAAoP,EAAAsG,KAAA1V,WAAA4wB,UACA1D,GAAA9d,EAAAnO,GAAAwC,QAAAyb,QAAA9N,GAAA,OAAAhC,EAAAsG,MAAA,4BACAtG,EAAAqD,OAAArD,EAAAsG,KAAArD,cAGA,QAAAw7B,IAAA5sC,EAAAwO,EAAAiG,EAAA/T,GACA,GAAAyN,GAAA,GAAA0+B,IAAA7sC,EAAAyU,EAAA/T,EAeA,OAdAyN,GAAA4b,YAAA/pB,EAAAwC,QAAA8c,cAAA,GACAmnB,GAAAzmC,EAAAwO,EAAA,SAAAxQ,GACA,GAAA+oB,GAAA/oB,EAAA+oB,UAAA/oB,EAAA+oB,WAIA,IAHA,MAAA5Y,EAAA2+B,SAAA/lB,EAAAluB,KAAAsV,GACA4Y,EAAAjE,OAAA1kB,KAAAL,IAAAgpB,EAAAruB,OAAA,EAAA0F,KAAAoL,IAAA,EAAA2E,EAAA2+B,WAAA,EAAA3+B,GACAA,EAAAnQ,QACA0jB,GAAA1hB,EAAA2c,IAAA3e,IAAAmQ,EAAAga,aAAA,CACA,GAAA4kB,GAAA/lB,GAAAhnB,EAAAhC,GAAAgC,EAAA2c,IAAA9J,SACAiP,IAAA9jB,IAAAwT,OAAAgf,GAAAriB,IACA4+B,GAAAhH,GAAA/lC,EAAA,EAAAmO,EAAAqD,QACAxR,EAAA6gB,MAAAwS,aAAA,EAEA,WAEAllB,EAeA,QAAA6+B,IAAAhvC,EAAAJ,EAAAywB,EAAAjN,GACApjB,EAAAJ,OACAI,EAAAyiB,aAAAziB,EAAAyiB,WAAA,MACAziB,EAAA0iB,SAAA1iB,EAAA0iB,OAAA,MACA,MAAA1iB,EAAAozB,QAAApzB,EAAAozB,MAAA,MACAob,GAAAxuC,GACA0uC,GAAA1uC,EAAAqwB,EACA,IAAAxM,GAAAT,IAAApjB,GAAA,CACA6jB,IAAA7jB,EAAAwT,QAAAsQ,GAAA9jB,EAAA6jB,GAGA,QAAAorB,IAAAjvC,GACAA,EAAA8rC,OAAA,KACA0C,GAAAxuC,GAMA,QAAAkvC,IAAAltC,EAAApC,EAAAsB,EAAAgF,EAAA9L,EAAA+0C,GACA,GAAAC,GAAAluC,EAAAkuC,YACA,OAAAA,MAAAptC,EAAAU,QAAA0sC,aACA,IACAp3C,GADAq3C,EAAA,EAAAC,EAAA,KACAnzB,EAAA,GAAAuuB,IAAA9qC,EAAAoC,EAAAU,QAAAitB,QAEA,KADA,IAAA/vB,GAAAsB,EAAAquC,WAAAruC,EAAAquC,UAAArpC,IACAiW,EAAAqzB,OAAA,CASA,GARArzB,EAAAxW,IAAA3D,EAAAU,QAAA+sC,oBACAL,GAAA,EACAD,GAAAhgB,GAAAntB,EAAApC,EAAAsG,EAAAiW,EAAAxW,KACAwW,EAAAxW,IAAA/F,EAAAlF,OACA1C,EAAA,MAEAA,EAAAkJ,EAAAoN,MAAA6N,EAAAjW,GAEAlE,EAAAU,QAAAgtC,aAAA,CACA,GAAAC,GAAAvtC,EAAAoM,UAAAtN,EAAAgF,GAAAhF,KAAA1F,IACAm0C,KAAA33C,EAAA,MAAAA,EAAA23C,EAAA,IAAA33C,EAAA23C,IAEAP,GAAAE,GAAAt3C,IACAq3C,EAAAlzB,EAAA1U,OAAArN,EAAA+hB,EAAA1U,MAAA6nC,GACAD,EAAAlzB,EAAA1U,MAAgC6nC,EAAAt3C,GAEhCmkB,EAAA1U,MAAA0U,EAAAxW,IAEA,KAAA0pC,EAAAlzB,EAAAxW,KAAA,CAEA,GAAAA,GAAAvF,KAAAL,IAAAoc,EAAAxW,IAAA0pC,EAAA,IACAj1C,GAAAuL,EAAA2pC,GACAD,EAAA1pC,GAIA,QAAAspB,IAAAjtB,EAAAhC,EAAAkG,EAAAipC,GAGA,GAAAS,IAAA5tC,EAAAkE,MAAAgY,QAEAgxB,IAAAltC,EAAAhC,EAAAJ,KAAAoC,EAAA2c,IAAAzd,KAAAgF,EAAA,SAAAwB,EAAA1P,GACA43C,EAAA/0C,KAAA6M,EAAA1P,IACKm3C,EAGL,QAAAU,GAAA,EAAmBA,EAAA7tC,EAAAkE,MAAA+X,SAAAvjB,SAA8Bm1C,EAAA,CACjD,GAAAl0B,GAAA3Z,EAAAkE,MAAA+X,SAAA4xB,GAAAjzC,EAAA,EAAAkzC,EAAA,CACAZ,IAAAltC,EAAAhC,EAAAJ,KAAA+b,EAAAza,MAAA,WAAAwG,EAAA1P,GAGA,IAFA,GAAAyP,GAAA7K,EAEA8K,EAAAooC,GAAA,CACA,GAAAC,GAAAH,EAAAhzC,EACAmzC,GAAAroC,GACAkoC,EAAA9qB,OAAAloB,EAAA,EAAA8K,EAAAkoC,EAAAhzC,EAAA,GAAAmzC,GACAnzC,GAAA,EACAkzC,EAAA1vC,KAAAL,IAAA2H,EAAAqoC,GAEA,GAAA/3C,EACA,GAAA2jB,EAAAq0B,OACAJ,EAAA9qB,OAAArd,EAAA7K,EAAA6K,EAAAC,EAAA1P,GACA4E,EAAA6K,EAAA,MAEA,MAAgB7K,EAAA6K,EAAWA,GAAA,GAC3B,GAAAc,GAAAqnC,EAAAnoC,EAAA,EACAmoC,GAAAnoC,EAAA,GAAAc,IAAA,IAAAvQ,OAMA,MAAA43C,GAGA,QAAAK,IAAAjuC,EAAAhC,GAGA,MAFAA,GAAA0iB,QAAA1iB,EAAA0iB,OAAA,IAAA1gB,EAAAkE,MAAAgY,UACAle,EAAA0iB,OAAAuM,GAAAjtB,EAAAhC,IAAAyiB,WAAAqM,EAAA9sB,EAAA0I,GAAA1K,MACAA,EAAA0iB,OAKA,QAAAyM,IAAAntB,EAAApC,EAAAsG,EAAAgqC,GACA,GAAAhvC,GAAAc,EAAA2c,IAAAzd,KACAib,EAAA,GAAAuuB,IAAA9qC,EAAAoC,EAAAU,QAAAitB,QAGA,KAFAxT,EAAA1U,MAAA0U,EAAAxW,IAAAuqC,GAAA,EACA,IAAAtwC,GAAAsB,EAAAquC,WAAAruC,EAAAquC,UAAArpC,IACAiW,EAAAqzB,OAAArzB,EAAAxW,KAAA3D,EAAAU,QAAA+sC,oBACAvuC,EAAAoN,MAAA6N,EAAAjW,GACAiW,EAAA1U,MAAA0U,EAAAxW,IAKA,QAAAwqC,IAAAn4C,EAAAo4C,GACA,IAAAp4C,EAAA,WACA,QAAW,CACX,GAAAq4C,GAAAr4C,EAAAI,MAAA,oCACA,KAAAi4C,EAAA,KACAr4C,KAAAuI,MAAA,EAAA8vC,EAAAC,OAAAt4C,EAAAuI,MAAA8vC,EAAAC,MAAAD,EAAA,GAAA31C,OACA,IAAAxC,GAAAm4C,EAAA,wBACA,OAAAD,EAAAl4C,GACAk4C,EAAAl4C,GAAAm4C,EAAA,GACA,GAAA9iC,QAAA,UAAA8iC,EAAA,cAAAl4C,KAAAi4C,EAAAl4C,MACAk4C,EAAAl4C,IAAA,IAAAm4C,EAAA,IAEA,WAAAl4C,KAAAH,GAAA,WACA,IAAA5B,GAAAg6C,EAAApuC,GAAAU,QAAAgtC,aAAAa,GAAAC,EACA,OAAAp6C,GAAA4B,KACA5B,EAAA4B,KAAA+W,QAAA,iBAGA,QAAAmc,IAAAlpB,EAAAyuC,EAAAxwB,EAAAywB,GAEA,IADA,GAAAnsB,GAAAvkB,EAAAywC,EAAAE,GAAA,EACApsB,EAAAE,GAAAzkB,IACAA,EAAAkJ,GAAAlH,EAAA2c,IAAA4F,EAAAG,OAAApf,KAAAtF,KAEA,IAAAowC,IAAmBhlB,IAAAjZ,GAAA,OAAAy+B,IAAA,EAAAjrC,IAAA,EACnBsa,QAAA,KAAA4wB,mBAAA,EAAA7uC,KACA0uC,cAEA,IACA1wC,EAAAJ,OAAA+wC,GAAA,GACAP,EAAAnwB,QAAAjgB,GAAAywC,GAAAxwB,EACAmwB,EAAAzqC,IAAA,EACAyqC,EAAAU,SAAAV,EAAAnwB,QAAA8wB,GAAAC,IACAjZ,IAAAzY,KAAAtd,EAAAqG,UAAA,kBACA+nC,EAAAU,SAAAG,GAAAb,EAAAU,UACA,IAAA/gC,GAAAmhC,GAAAlxC,EAAAowC,EAAAH,GAAAjuC,EAAAhC,GACAigB,IAAAjgB,GAAAywC,IAAAL,EAAAS,oBACA5wB,EAAA,GAAAmwB,EAAAhlB,IAAA/zB,YAAA86B,GAAAnwB,EAAAwC,QAAAyb,UACAmwB,EAAAS,mBAAA,GAEA9gC,IAAA/P,EAAAkJ,GAAAlH,EAAA2c,IAAA5O,EAAAxK,GAAAvF,aACK+P,IAELkQ,GAAAmwB,EAAAS,mBAAA5wB,EAAA,KACAA,EAAA,GAAAmwB,EAAAhlB,IAAA/zB,YAAAs5C,EAAAx+B,GAAA,YAAAggB,GAAAnwB,EAAAwC,QAAAyb,WACAmwB,EAAAhlB,IAAAlW,YAAAwO,GAAA1hB,EAAA2c,IAAA8xB,IACAL,EAAAhlB,IAAA/zB,YAAAX,SAAAY,eAAA,KAEA,IAAA87B,EAIA,IAAAnT,GAAA8X,KAAA3E,EAAA9F,GAAAttB,IAAA,CACA,GAAAtD,GAAA02B,EAAA14B,OAAA,CACA04B,GAAA12B,GAAA4I,MAAA8tB,EAAA12B,GAAA6I,MAAA7I,CACA,IAAA8pB,GAAA4M,EAAA12B,GAAA0gB,EAAAgW,EAAA12B,EAAA,EACA,IAAA8pB,EAAAlhB,KAAA,GAAAkhB,EAAAjhB,IAAA6X,GAAAoJ,EAAA6M,MAAAjW,EAAAiW,MAAA,CACA,GAAApY,GAAAgF,EAAAmwB,EAAAzqC,IAAA,EACAsV,MAAAla,WAAAiqB,aAAA/P,EAAA4W,aAAAM,GAAAnwB,EAAAwC,QAAAyb,SACAhF,EAAAoL,cAIA,GAAAkK,GAAA6f,EAAA7f,UAAA6f,EAAA7f,UAAA,KAAAkgB,EAAAlgB,WAAA,IAAAkgB,EAAAlgB,SAIA,OAHAA,KAAA6f,EAAAhlB,IAAAvf,UAAA0kB,GAEAtb,GAAAjT,EAAA,aAAAA,EAAAyuC,EAAAL,EAAAhlB,KACAglB,EAGA,QAAAe,IAAA9rC,GACA,GAAAiJ,GAAA6D,GAAA,4BAEA,OADA7D,GAAApT,MAAA,MAAAmK,EAAA6yB,WAAA,GAAAkS,SAAA,IACA97B,EAGA,QAAA0iC,IAAAZ,EAAAxwC,EAAA5H,EAAAyzC,EAAAC,EAAAxwC,GACA,GAAA0E,EAAA,CACA,GAAAwxC,GAAAhB,EAAApuC,GAAAU,QAAA2uC,YACA,IAAAD,EAAAj5C,KAAAyH,GAKA,IADA,GAAAyX,GAAA3gB,SAAA0jB,yBAAAzU,EAAA,IACA,CACAyrC,EAAAE,UAAA3rC,CACA,IAAAgI,GAAAyjC,EAAA3xC,KAAAG,GACA2xC,EAAA5jC,IAAA2iC,MAAA3qC,EAAA/F,EAAAlF,OAAAiL,CAKA,IAJA4rC,IACAl6B,EAAAhgB,YAAAX,SAAAY,eAAAsI,EAAAW,MAAAoF,IAAA4rC,KACAnB,EAAAQ,KAAAW,IAEA5jC,EAAA,KAEA,IADAhI,GAAA4rC,EAAA,EACA,KAAA5jC,EAAA,IACA,GAAAgiB,GAAAygB,EAAApuC,GAAAU,QAAAitB,QAAA6hB,EAAA7hB,EAAAygB,EAAAQ,IAAAjhB,CACAtY,GAAAhgB,YAAA8a,GAAA,OAAAq2B,GAAAgJ,GAAA,WACApB,EAAAQ,KAAAY,MACS,CACT,GAAAljC,GAAA8hC,EAAApuC,GAAAU,QAAA+uC,uBAAA9jC,EAAA,GACA0J,GAAAhgB,YAAAiX,GACA8hC,EAAAQ,KAAA,OAtBA,CACAR,EAAAQ,KAAAhxC,EAAAlF,MACA,IAAA2c,GAAA3gB,SAAAY,eAAAsI,GAwBA,GAAA5H,GAAAyzC,GAAAC,GAAA0E,EAAAnwB,QAAA,CACA,GAAAyxB,GAAA15C,GAAA,EACAyzC,KAAAiG,GAAAjG,GACAC,IAAAgG,GAAAhG,EACA,IAAAp9B,GAAA6D,GAAA,QAAAkF,GAAAq6B,EAEA,OADAx2C,KAAAoT,EAAApT,SACAk1C,EAAAhlB,IAAA/zB,YAAAiX,GAEA8hC,EAAAhlB,IAAA/zB,YAAAggB,IAGA,QAAA05B,IAAAX,EAAAxwC,EAAA5H,EAAAyzC,EAAAC,GAEA,OADAnoB,GAAA6sB,EAAApuC,GAAAU,QAAAG,aACAjG,EAAA,EAAmBA,EAAAgD,EAAAlF,SAAiBkC,EAAA,CAEpC,IADA,GAAA6K,GAAA,GAAA7K,EAAA2I,EAAA3I,EAAA,EACA2I,EAAA3F,EAAAlF,QAAAq6B,GAAAn1B,EAAAwJ,OAAA7D,QACA,IAAAF,GAAAzF,EAAAW,MAAA3D,EAAA2I,EACA3I,GAAA2I,EAAA,EACA3I,GAAA2mB,GAAAouB,GAAA/xC,EAAAhD,IACAwzC,EAAAhlB,IAAA/zB,YAAA8a,GAAA,OACA,IAAAnI,GAAAomC,EAAAnwB,QAAAmwB,EAAAzqC,KACAsV,EAAAm1B,EAAAnwB,QAAAmwB,EAAAzqC,KACAqrC,GAAAZ,EAAA/qC,EAAArN,EACAyP,GAAAgkC,EAAA7uC,GAAAgD,EAAAlF,OAAA,GAAAgxC,EACA1hC,KAAAiR,EAAAyS,SAAA1jB,EAAA0jB,UAAA1jB,GAIA8U,IAAAyE,GAAA,KAAAle,GAAAzI,IAAA,KAAAzE,KAAAyH,EAAAwJ,OAAAxM,EAAA,KACAA,EAAAgD,EAAAlF,OAAA,SAAAvC,KAAAyH,EAAAwJ,OAAAxM,EAAA,MACAqe,EAAAjjB,MAAA45C,WAAA,UACAxB,EAAAzqC,KAAAN,EAAA3K,OAEAkF,EAAAlF,SAAA01C,EAAAS,mBAAA,GAGA,QAAAI,IAAA53B,GACA,QAAAxZ,GAAAmK,GAEA,OADAvN,GAAA,IACAG,EAAA,EAAqBA,EAAAoN,EAAAtP,OAAA,IAAoBkC,EAAAH,GAAAG,EAAA,SAEzC,OADAH,IAAA,IAGA,gBAAA2zC,EAAAxwC,EAAA5H,EAAAyzC,EAAAC,EAAAxwC,GACA,MAAAme,GAAA+2B,EAAAxwC,EAAAmP,QAAA,SAA+ClP,GAAA7H,EAAAyzC,EAAAC,EAAAxwC,IAI/C,QAAA22C,IAAAzB,EAAA1pB,EAAAtN,EAAA04B,GACA,GAAA3hC,IAAA2hC,GAAA14B,EAAA+xB,YACA,IAAAh7B,IACAigC,EAAAM,cAAAvgC,IAAAuH,WAAA,IACA04B,EAAAhlB,IAAA/zB,YAAA8Y,GACAigC,EAAAnwB,SAAA,CACA,GAAAyG,EACA0pB,EAAAnwB,QAAAmwB,EAAAzqC,KAAAwK,MACS,CACT,GAAAgC,GAAAggB,GAAAie,EAAApuC,GAAAwC,QAAAyb,QACA,gBAAA7G,EAAAliB,MAAAkiB,EAAAqzB,WAEA,IAAA2D,EAAAnwB,QAAAmwB,EAAAzqC,KACA,MAEAyqC,GAAAnwB,QAAAmwB,EAAAzqC,KAAAyqC,EAAAhlB,IAAAJ,aAAA7Y,EAAAhC,OAJAigC,GAAAnwB,QAAAmwB,EAAAzqC,KAAAyqC,EAAAhlB,IAAA/zB,YAAA8a,GAMAi+B,EAAAS,mBAAA,EAGAT,EAAAzqC,KAAA+gB,EAKA,QAAAwqB,IAAAlxC,EAAAowC,EAAA1tB,GACA,GAAA7H,GAAA7a,EAAAqwB,YAAA0hB,EAAA/xC,EAAAJ,KAAAkwC,EAAA,CACA,IAAAj1B,EAQA,IAFA,GAAA7iB,GACAg6C,EAAAC,EAAAC,EAAAh3C,EAAAgxB,EADA1H,EAAAutB,EAAAr3C,OAAAiL,EAAA,EAAA/I,EAAA,EAAAgD,EAAA,GACAuyC,EAAA,IACW,CACX,GAAAA,GAAAxsC,EAAA,CACAqsC,EAAAC,EAAAC,EAAAh3C,EAAA,GACAgxB,EAAA,KAAyBimB,EAAArqB,GAEzB,QADAsqB,MACAp3B,EAAA,EAAuBA,EAAAH,EAAAngB,SAAkBsgB,EAAA,CACzC,GAAAkX,GAAArX,EAAAG,GAAArN,EAAAukB,EAAA9Y,MACA8Y,GAAA5sB,MAAAK,IAAA,MAAAusB,EAAA3sB,IAAA2sB,EAAA3sB,GAAAI,IACA,MAAAusB,EAAA3sB,IAAA4sC,EAAAjgB,EAAA3sB,KAAsD4sC,EAAAjgB,EAAA3sB,GAAoB0sC,EAAA,IAC1EtkC,EAAA9B,YAAAmmC,GAAA,IAAArkC,EAAA9B,WACA8B,EAAA89B,YAAAvZ,EAAA5sB,MAAAK,IAAAusC,GAAA,IAAAvkC,EAAA89B,YACA99B,EAAA+9B,UAAAxZ,EAAA3sB,IAAA4sC,IAAAF,GAAA,IAAAtkC,EAAA+9B,UACA/9B,EAAAzS,cAAAyS,EAAAzS,OACAyS,EAAAue,gBAAA6hB,GAAA7hB,EAAA9S,OAAAzL,GAAA,KACAue,EAAAgG,IACWA,EAAA5sB,KAAAK,GAAAwsC,EAAAjgB,EAAA5sB,OACX6sC,EAAAjgB,EAAA5sB,MAEA,YAAAqI,EAAAzW,MAAAg7B,EAAA5sB,MAAAK,GAAAgI,EAAAw9B,cAAAiH,EAAAv3C,KAAA8S,GAEA,GAAAue,MAAA5mB,MAAA,IAAAK,IACAksC,GAAAzB,GAAA,MAAAlkB,EAAA3mB,GAAAif,EAAA0H,EAAA3mB,IAAAI,EACAumB,EAAA9S,OAAA,MAAA8S,EAAA5mB,MACA,MAAA4mB,EAAA3mB,IAAA,MAAA2mB,GAAA9S,OAAAsL,MAEA,KAAAwH,GAAAkmB,EAAA13C,OAAA,OAAAsgB,GAAA,EAAgEA,EAAAo3B,EAAA13C,SAA2BsgB,EAC3F62B,GAAAzB,EAAA,EAAAgC,EAAAp3B,IAEA,GAAArV,GAAA6e,EAAA,KAGA,KADA,GAAA6tB,GAAAjyC,KAAAL,IAAAykB,EAAA2tB,KACA,CACA,GAAAvyC,EAAA,CACA,GAAA8H,GAAA/B,EAAA/F,EAAAlF,MACA,KAAAwxB,EAAA,CACA,GAAAomB,GAAA5qC,EAAA2qC,EAAAzyC,EAAAW,MAAA,EAAA8xC,EAAA1sC,GAAA/F,CACAwwC,GAAAU,SAAAV,EAAAkC,EAAAt6C,IAAAg6C,IACAE,EAAAvsC,EAAA2sC,EAAA53C,QAAAy3C,EAAAF,EAAA,GAAA/2C,GAEA,GAAAwM,GAAA2qC,EAAA,CAA4BzyC,IAAAW,MAAA8xC,EAAA1sC,GAA8BA,EAAA0sC,CAAY,OACtE1sC,EAAA+B,EACAwqC,EAAA,GAEAtyC,EAAAmyC,EAAAxxC,MAAAuvC,IAAAptB,EAAA9lB,MACA5E,EAAAm4C,GAAAztB,EAAA9lB,KAAAwzC,QAnDA,QAAAxzC,GAAA,EAAqBA,EAAA8lB,EAAAhoB,OAAmBkC,GAAA,EACxCwzC,EAAAU,SAAAV,EAAA2B,EAAAxxC,MAAAuvC,IAAAptB,EAAA9lB,IAAAuzC,GAAAztB,EAAA9lB,EAAA,GAAAwzC,IAyDA,QAAAnL,IAAAtmB,EAAAsK,EAAAoH,EAAA8S,EAAA/f,GACA,QAAAmvB,GAAAttC,GAA0B,MAAAorB,KAAAprB,GAAA,KAC1B,QAAA6Q,GAAA9V,EAAAJ,EAAAib,GACAm0B,GAAAhvC,EAAAJ,EAAAib,EAAAuI,GACAuE,GAAA3nB,EAAA,SAAAA,EAAAipB,GAGA,GAAA3jB,GAAA2jB,EAAA3jB,KAAAC,EAAA0jB,EAAA1jB,GAAA3F,EAAAqpB,EAAArpB,KACA6N,EAAAvE,GAAAyV,EAAArZ,EAAAtF,MAAA0N,EAAAxE,GAAAyV,EAAApZ,EAAAvF,MACAwyC,EAAAlQ,GAAA1iC,GAAA6yC,EAAAF,EAAA3yC,EAAAlF,OAAA,GAAAg4C,EAAAntC,EAAAvF,KAAAsF,EAAAtF,IAGA,OAAAsF,EAAAD,IAAA,GAAAE,EAAAF,IAAA,IAAAmtC,GACA7zB,EAAA3c,KAAA2c,EAAA3c,GAAAU,QAAAiwC,sBAQK,GAAAllC,GAAAC,EACL,MAAA9N,EAAAlF,OACAob,EAAArI,IAAA7N,KAAAW,MAAA,EAAA+E,EAAAD,IAAAmtC,EAAA/kC,EAAA7N,KAAAW,MAAAgF,EAAAF,IAAAotC,OACO,CACP,OAAAG,MAAAh2C,EAAA,EAAAyC,EAAAO,EAAAlF,OAAA,EAAwD2E,EAAAzC,IAAOA,EAC/Dg2C,EAAA/3C,KAAA,GAAAk3B,IAAAnyB,EAAAhD,GAAA21C,EAAA31C,GAAAwmB,GACAwvB,GAAA/3C,KAAA,GAAAk3B,IAAAygB,EAAA/kC,EAAA7N,KAAAW,MAAAgF,EAAAF,IAAAotC,EAAArvB,IACAtN,EAAArI,IAAA7N,KAAAW,MAAA,EAAA+E,EAAAD,IAAAzF,EAAA,GAAA2yC,EAAA,IACA5zB,EAAAk0B,OAAAvtC,EAAAtF,KAAA,EAAA4yC,OAEK,OAAAhzC,EAAAlF,OACLob,EAAArI,IAAA7N,KAAAW,MAAA,EAAA+E,EAAAD,IAAAzF,EAAA,GAAA8N,EAAA9N,KAAAW,MAAAgF,EAAAF,IAAAktC,EAAA,IACA5zB,EAAA5gB,OAAAuH,EAAAtF,KAAA,EAAA0yC,OACK,CACL58B,EAAArI,IAAA7N,KAAAW,MAAA,EAAA+E,EAAAD,IAAAzF,EAAA,GAAA2yC,EAAA,IACAz8B,EAAApI,EAAA8kC,EAAA9kC,EAAA9N,KAAAW,MAAAgF,EAAAF,IAAAotC,EACA,QAAA71C,GAAA,EAAAyC,EAAAO,EAAAlF,OAAA,EAAAk4C,KAAsDvzC,EAAAzC,IAAOA,EAC7Dg2C,EAAA/3C,KAAA,GAAAk3B,IAAAnyB,EAAAhD,GAAA21C,EAAA31C,GAAAwmB,GACAsvB,GAAA,GAAA/zB,EAAA5gB,OAAAuH,EAAAtF,KAAA,EAAA0yC,EAAA,GACA/zB,EAAAk0B,OAAAvtC,EAAAtF,KAAA,EAAA4yC,OA3BA,CAGA,OAAAh2C,GAAA,EAAAyC,EAAAO,EAAAlF,OAAA,EAAAk4C,KAAsDvzC,EAAAzC,IAAOA,EAC7Dg2C,EAAA/3C,KAAA,GAAAk3B,IAAAnyB,EAAAhD,GAAA21C,EAAA31C,GAAAwmB,GACAtN,GAAApI,IAAA9N,KAAA6yC,GACAC,GAAA/zB,EAAA5gB,OAAAuH,EAAAtF,KAAA0yC,GACAE,EAAAl4C,QAAAikB,EAAAk0B,OAAAvtC,EAAAtF,KAAA4yC,GAuBAjrB,GAAAhJ,EAAA,SAAAA,EAAAsK,GACAnhB,GAAA6W,EAAAwkB,EAAA35B,OAAA25B,EAAA5rC,KAAA,SAGA,QAAAu7C,IAAAzuC,GACAjH,KAAAiH,QACAjH,KAAA0uC,OAAA,IACA,QAAAlvC,GAAA,EAAAyC,EAAAgF,EAAA3J,OAAA8Y,EAAA,EAAiDnU,EAAAzC,IAAOA,EACxDyH,EAAAzH,GAAAkvC,OAAA1uC,KACAoW,GAAAnP,EAAAzH,GAAA4W,MAEApW,MAAAoW,SA4BA,QAAAu/B,IAAAv1C,GACAJ,KAAAI,UAEA,QADAkpB,GAAA,EAAAlT,EAAA,EACA5W,EAAA,EAAAyC,EAAA7B,EAAA9C,OAAwC2E,EAAAzC,IAAOA,EAAA,CAC/C,GAAAyI,GAAA7H,EAAAZ,EACA8pB,IAAArhB,EAAA2tC,YAA6Bx/B,GAAAnO,EAAAmO,OAC7BnO,EAAAymC,OAAA1uC,KAEAA,KAAAspB,OACAtpB,KAAAoW,SACApW,KAAA0uC,OAAA;CA6VA,QAAArI,IAAA9kB,EAAAvkB,EAAA64C,GACA,QAAAC,GAAAv0B,EAAAw0B,EAAAzP,GACA,GAAA/kB,EAAAotB,OAAA,OAAAnvC,GAAA,EAAqCA,EAAA+hB,EAAAotB,OAAArxC,SAAuBkC,EAAA,CAC5D,GAAAw2C,GAAAz0B,EAAAotB,OAAAnvC,EACA,IAAAw2C,EAAAz0B,KAAAw0B,EAAA,CACA,GAAApI,GAAArH,GAAA0P,EAAA1P,aACAuP,GAAAlI,KACA3wC,EAAAg5C,EAAAz0B,IAAAosB,GACAmI,EAAAE,EAAAz0B,MAAAosB,MAGAmI,EAAAv0B,EAAA,SAGA,QAAAE,IAAA7c,EAAA2c,GACA,GAAAA,EAAA3c,GAAA,SAAAvG,OAAA,mCACAuG,GAAA2c,MACAA,EAAA3c,KACAihB,EAAAjhB,GACAqgB,EAAArgB,GACAA,EAAAU,QAAAG,cAAAmgB,EAAAhhB,GACAA,EAAAU,QAAAxB,KAAAyd,EAAA2D,WACAQ,GAAA9gB,GAKA,QAAAkH,IAAAqoB,EAAAtsB,GAEA,IADAA,GAAAssB,EAAA7T,OACA6T,EAAAltB,OACA,OAAAzH,GAAA,KAAsBA,EAAA,CACtB,GAAAgB,GAAA2zB,EAAA/zB,SAAAZ,GAAAy2C,EAAAz1C,EAAAo1C,WACA,IAAAK,EAAApuC,EAAA,CAAqBssB,EAAA3zB,CAAe,OACpCqH,GAAAouC,EAGA,MAAA9hB,GAAAltB,MAAAY,GAGA,QAAA8/B,IAAApmB,EAAAlX,EAAAC,GACA,GAAAjL,MAAAwI,EAAAwC,EAAAzH,IAQA,OAPA2e,GAAA6D,KAAA/a,EAAAzH,KAAA0H,EAAA1H,KAAA,WAAAA,GACA,GAAAJ,GAAAI,EAAAJ,IACAqF,IAAAyC,EAAA1H,OAAAJ,IAAAW,MAAA,EAAAmH,EAAArC,KACAJ,GAAAwC,EAAAzH,OAAAJ,IAAAW,MAAAkH,EAAApC,KACA5I,EAAA5B,KAAA+E,KACAqF,IAEAxI,EAEA,QAAA62C,IAAA30B,EAAArZ,EAAAC,GACA,GAAA9I,KAEA,OADAkiB,GAAA6D,KAAAld,EAAAC,EAAA,SAAAvF,GAAuCvD,EAAA5B,KAAAmF,EAAAJ,QACvCnD,EAGA,QAAAqnB,IAAA9jB,EAAAwT,GAEA,OADAuU,GAAAvU,EAAAxT,EAAAwT,OACAvO,EAAAjF,EAAsBiF,EAAGA,IAAA6mC,OAAA7mC,EAAAuO,QAAAuU,EAGzB,QAAArd,IAAA1K,GACA,SAAAA,EAAA8rC,OAAA,WAEA,QADAvjC,GAAAvI,EAAA8rC,OAAApD,EAAAxrC,GAAAqL,EAAAlE,MAAArE,GACAuxB,EAAAhpB,EAAAujC,OAAgCva,EAAOhpB,EAAAgpB,MAAAua,OACvC,OAAAlvC,GAAA,EACA20B,EAAA/zB,SAAAZ,IAAA2L,IADsB3L,EAEtB8rC,GAAAnX,EAAA/zB,SAAAZ,GAAAo2C,WAGA,OAAAtK,GAAAngC,EAAAmV,MAGA,QAAAsI,IAAAuL,EAAAgiB,GACA,GAAAtuC,GAAAssB,EAAA7T,KACAoT,GAAA,GACA,OAAAl0B,GAAA,EAAAyC,EAAAkyB,EAAA/zB,SAAA9C,OAAgD2E,EAAAzC,IAAOA,EAAA,CACvD,GAAAgB,GAAA2zB,EAAA/zB,SAAAZ,GAAAyI,EAAAzH,EAAA4V,MACA,IAAAnO,EAAAkuC,EAAA,CAAqBhiB,EAAA3zB,CAAe,SAAAkzB,GACpCyiB,GAAAluC,EACAJ,GAAArH,EAAAo1C,YAEA,MAAA/tC,UACKssB,EAAAltB,MACL,QAAAzH,GAAA,EAAAyC,EAAAkyB,EAAAltB,MAAA3J,OAA2C2E,EAAAzC,IAAOA,EAAA,CAClD,GAAAoD,GAAAuxB,EAAAltB,MAAAzH,GAAA42C,EAAAxzC,EAAAwT,MACA,IAAAggC,EAAAD,EAAA,KACAA,IAAAC,EAEA,MAAAvuC,GAAArI,EAGA,QAAAosB,IAAAhnB,EAAA6mB,GACAA,EAAAX,GAAAlmB,EAAA2c,IAAAkK,EAGA,QADA0qB,GAAA,EAAAhiB,EAAA1I,EAAAijB,OACAlvC,EAAA,EAAmBA,EAAA20B,EAAAltB,MAAA3J,SAAwBkC,EAAA,CAC3C,GAAAoD,GAAAuxB,EAAAltB,MAAAzH,EACA,IAAAoD,GAAA6oB,EAAA,KACA0qB,IAAAvzC,EAAAwT,OAEA,OAAAnd,GAAAk7B,EAAAua,OAA8Bz1C,EAAGk7B,EAAAl7B,IAAAk7B,EAAAua,OACjC,OAAAlvC,GAAA,EAAqBA,EAAAvG,EAAAmH,SAAA9C,SAAuBkC,EAAA,CAC5C,GAAA2L,GAAAlS,EAAAmH,SAAAZ,EACA,IAAA2L,GAAAgpB,EAAA,KACAgiB,IAAAhrC,EAAAiL,OAGA,MAAA+/B,GAGA,QAAAjmB,IAAAttB,GACA,GAAAozB,GAAApzB,EAAAozB,KAEA,OADA,OAAAA,MAAApzB,EAAAozB,MAAAqgB,GAAAzzC,EAAAJ,OACAwzB,EAKA,QAAAsgB,IAAAC,GACA,OAIAh+B,QAAAouB,UAAA6P,UAAA9rB,IAGA+rB,SAAA,EAAAC,OAAA,KAAAC,WAAA,KAEA1P,WAAAsP,GAAA,EAAArP,cAAAqP,GAAA,GAIA,QAAAK,IAAAr1B,EAAAsK,EAAA3jB,EAAAC,GACA,GAAA0uC,GAAAhrB,EAAA,SAAAtK,EAAA1oB,IAAAgP,EAAA,CACA0Z,GAAA6D,KAAApiB,KAAAoL,IAAAmT,EAAAjB,MAAApY,GAAAlF,KAAAL,IAAA4e,EAAAjB,MAAAiB,EAAA+H,KAAAnhB,GAAA,SAAAvF,GACAA,EAAAqwB,eACA4jB,MAAAhrB,EAAA,SAAAtK,EAAA1oB,SAA+DgP,GAAAjF,EAAAqwB,eAC/DprB,IAIA,QAAAu/B,IAAA7lB,EAAAsK,GACA,GAAA3jB,IAAgBtF,KAAAipB,EAAA3jB,KAAAtF,KAAAqF,GAAA4jB,EAAA3jB,KAAAD,IAChB6uC,GAAsB5uC,OAAAC,GAAAk9B,GAAAxZ,GAAArpB,KAAAmlC,GAAApmB,EAAAsK,EAAA3jB,KAAA2jB,EAAA1jB,IAGtB,OAFAyuC,IAAAr1B,EAAAu1B,EAAAjrB,EAAA3jB,KAAAtF,KAAAipB,EAAA1jB,GAAAvF,KAAA,GACAyjC,GAAA9kB,EAAA,SAAAA,GAAmCq1B,GAAAr1B,EAAAu1B,EAAAjrB,EAAA3jB,KAAAtF,KAAAipB,EAAA1jB,GAAAvF,KAAA,KAAyE,GAC5Gk0C,EAGA,QAAA9Q,IAAAzkB,EAAAsK,EAAAka,EAAAgR,GACA,GAAArQ,GAAAnlB,EAAAglB,OACAG,GAAAC,OAAArpC,OAAA,CACA,IAAA4zB,IAAA,GAAAK,MAAApmB,EAAA+5B,GAAAwB,EAAAnuB,KAEA,IAAApN,IACAu7B,EAAAgQ,QAAAK,GACArQ,EAAAiQ,YAAA9qB,EAAAtiB,QAAAsiB,EAAAtiB,SACA,KAAAsiB,EAAAtiB,OAAAyC,OAAA,IAAAuV,EAAA3c,IAAA8hC,EAAA+P,SAAAvlB,EAAA3P,EAAA3c,GAAAU,QAAA0xC,mBACA,KAAAnrB,EAAAtiB,OAAAyC,OAAA,MAEA,GAAAod,GAAA8b,GAAA/5B,EAAA2e,QACAhiB,IAAA+jB,EAAA3jB,KAAA2jB,EAAA1jB,KAAAL,GAAA+jB,EAAA3jB,KAAAkhB,EAAAjhB,IAGAihB,EAAAjhB,GAAAk9B,GAAAxZ,GAGA1gB,EAAA2e,QAAArsB,KAAA2pC,GAAA7lB,EAAAsK,IAEA1gB,EAAA27B,YAAAf,EAAA35B,OAAwCjB,EAAA67B,UAAAjB,EAAA5rC,SAQxC,KALAgR,GAAa2e,SAAAsd,GAAA7lB,EAAAsK,IACbob,WAAAP,EAAAO,WACAJ,aAAAtlB,EAAAxB,IAAA3T,OAAA26B,WAAAxlB,EAAAxB,IAAA5lB,KACA2sC,YAAAf,EAAA35B,OAAA46B,UAAAjB,EAAA5rC,MACAusC,EAAAnuB,KAAA9a,KAAA0N,GACAu7B,EAAAnuB,KAAAjb,OAAAopC,EAAA8P,WACA9P,EAAAnuB,KAAA/a,OAEAkpC,GAAAO,aAAAP,EAAAQ,cACAR,EAAA+P,SAAAvlB,EACAwV,EAAAgQ,OAAAK,EACArQ,EAAAiQ,WAAA9qB,EAAAtiB,OAEA6f,GAAAvR,GAAA0J,EAAA,gBAGA,QAAA01B,IAAAx5B,GACA,IAAAA,EAAA,WACA,QAAApe,GAAAG,EAAA,EAAwBA,EAAAie,EAAAngB,SAAkBkC,EAC1Cie,EAAAje,GAAAwc,OAAAmtB,kBAA8C9pC,MAAAoe,EAAAta,MAAA,EAAA3D,IAC9CH,KAAA5B,KAAAggB,EAAAje,GAEA,OAAAH,KAAA/B,OAAA+B,EAAA,KAAAoe,EAGA,QAAAwyB,IAAA1uB,EAAAsK,GACA,GAAA3d,GAAA2d,EAAA,SAAAtK,EAAA1oB,GACA,KAAAqV,EAAA,WACA,QAAA1O,GAAA,EAAA2vC,KAA4B3vC,EAAAqsB,EAAArpB,KAAAlF,SAAwBkC,EACpD2vC,EAAA1xC,KAAAw5C,GAAA/oC,EAAA1O,IACA,OAAA2vC,GAKA,QAAA+H,IAAAz6C,EAAA06C,GACA,OAAA33C,GAAA,EAAAk1B,KAA8Bl1B,EAAA/C,EAAAa,SAAmBkC,EAAA,CACjD,GAAApD,GAAAK,EAAA+C,GAAAsqB,EAAA1tB,EAAA0tB,QAAAstB,IACA1iB,GAAAj3B,MAAiBqsB,QAAAstB,EAAAvQ,aAAAzqC,EAAAyqC,aAAAE,WAAA3qC,EAAA2qC,WACjBD,YAAA1qC,EAAA0qC,YAAAE,UAAA5qC,EAAA4qC,WACA,QAAAppB,GAAA,EAAqBA,EAAAkM,EAAAxsB,SAAoBsgB,EAAA,CACzC,GAAArN,GAAAsb,EAAA/B,EAAAlM,EAEA,IADAw5B,EAAA35C,MAAyByK,KAAA2jB,EAAA3jB,KAAAC,GAAA0jB,EAAA1jB,GAAA3F,KAAAqpB,EAAArpB,OACzB20C,EAAA,OAAAr8C,KAAA+wB,IAAAtb,EAAAzV,EAAAE,MAAA,mBACA8E,GAAAq3C,EAAAluC,OAAAsH,EAAA,UACA20B,GAAAkS,GAAAt8C,GAAA+wB,EAAA/wB,SACA+wB,GAAA/wB,KAKA,MAAA45B,GAKA,QAAA2iB,IAAA9uC,EAAAL,EAAAC,EAAAwiB,GACAxiB,EAAAI,EAAA3F,KACA2F,EAAA3F,MAAA+nB,EACKziB,EAAAK,EAAA3F,OACL2F,EAAA3F,KAAAsF,EACAK,EAAAN,GAAA,GAWA,QAAAqvC,IAAAC,EAAArvC,EAAAC,EAAAwiB,GACA,OAAAnrB,GAAA,EAAmBA,EAAA+3C,EAAAj6C,SAAkBkC,EAAA,CAErC,OADAg4C,GAAAD,EAAA/3C,GAAAi4C,GAAA,EACA75B,EAAA,EAAqBA,EAAA45B,EAAA1tB,QAAAxsB,SAAwBsgB,EAAA,CAC7C,GAAAzS,GAAAqsC,EAAA1tB,QAAAlM,EAEA,IADA45B,EAAAE,SAA0BvsC,EAAAjD,KAAAggC,GAAA/8B,EAAAjD,MAA8BiD,EAAAhD,GAAA+/B,GAAA/8B,EAAAhD,KACxDA,EAAAgD,EAAAjD,KAAAtF,KACAuI,EAAAjD,KAAAtF,MAAA+nB,EACAxf,EAAAhD,GAAAvF,MAAA+nB,MACS,IAAAziB,GAAAiD,EAAAhD,GAAAvF,KAAA,CACT60C,GAAA,CACA,QAGAD,EAAAE,SACAF,EAAA3Q,aAAAqB,GAAAsP,EAAA3Q,cAAqD2Q,EAAAzQ,WAAAmB,GAAAsP,EAAAzQ,YACrDyQ,EAAA1Q,YAAAoB,GAAAsP,EAAA1Q,aAAmD0Q,EAAAG,UAAAzP,GAAAsP,EAAAxQ,WACnDwQ,EAAAE,QAAA,GAEAD,GAIAJ,GAAAG,EAAA3Q,cAAwCwQ,GAAAG,EAAAzQ,YACxCsQ,GAAAG,EAAA1Q,aAAuCuQ,GAAAG,EAAAxQ,aAJvCuQ,EAAA7vB,OAAA,EAAAloB,EAAA,GACAA,EAAA,IAQA,QAAAgnC,IAAAE,EAAA7a,GACA,GAAA3jB,GAAA2jB,EAAA3jB,KAAAtF,KAAAuF,EAAA0jB,EAAA1jB,GAAAvF,KAAA+nB,EAAAkB,EAAArpB,KAAAlF,QAAA6K,EAAAD,GAAA,CACAovC,IAAA5Q,EAAAnuB,KAAArQ,EAAAC,EAAAwiB,GACA2sB,GAAA5Q,EAAAC,OAAAz+B,EAAAC,EAAAwiB,GAKA,QAAAitB,MAAyBpb,GAAAx8B,MAEzB,QAAAu8B,IAAAngC,GAEA,MADAA,GAAAkL,OAAAlL,EAAAkL,KAAAswC,IACAx7C,EAGA,QAAA0gC,IAAA76B,GACAA,EAAA41C,eAAA51C,EAAA41C,iBACA51C,EAAA4hC,aAAA,EAEA,QAAAiU,IAAA71C,GACAA,EAAA5E,gBAAA4E,EAAA5E,kBACA4E,EAAA81C,cAAA,EAEA,QAAA/X,IAAA/9B,GACA,aAAAA,EAAA+1C,iBAAA/1C,EAAA+1C,iBAAA,GAAA/1C,EAAA4hC,YAEA,QAAArH,IAAAv6B,GAAsB66B,GAAA76B,GAAoB61C,GAAA71C,GAK1C,QAAA87B,IAAA97B,GAAwB,MAAAA,GAAAC,QAAAD,EAAA0V,WACxB,QAAAmnB,IAAA78B,GACA,GAAA+F,GAAA/F,EAAAkiC,KAOA,OANA,OAAAn8B,IACA,EAAA/F,EAAAg2C,OAAAjwC,EAAA,EACA,EAAA/F,EAAAg2C,OAAAjwC,EAAA,EACA,EAAA/F,EAAAg2C,SAAAjwC,EAAA,IAEAwkB,IAAAvqB,EAAAgiC,SAAA,GAAAj8B,MAAA,GACAA,EAKA,QAAAtM,IAAAC,EAAA7B,EAAAkD,GACA,GAAArB,EAAAK,iBACAL,EAAAK,iBAAAlC,EAAAkD,GAAA,OACA,IAAArB,EAAAu8C,YACAv8C,EAAAu8C,YAAA,KAAAp+C,EAAAkD,OACA,CACA,GAAAkG,GAAAvH,EAAAw8C,YAAAx8C,EAAAw8C,cACAxnC,EAAAzN,EAAApJ,KAAAoJ,EAAApJ,MACA6W,GAAAlT,KAAAT,IAIA,QAAAR,IAAAb,EAAA7B,EAAAkD,GACA,GAAArB,EAAAU,oBACAV,EAAAU,oBAAAvC,EAAAkD,GAAA,OACA,IAAArB,EAAAy8C,YACAz8C,EAAAy8C,YAAA,KAAAt+C,EAAAkD,OACA,CACA,GAAA2T,GAAAhV,EAAAw8C,WAAAx8C,EAAAw8C,UAAAr+C,EACA,KAAA6W,EAAA,MACA,QAAAnR,GAAA,EAAqBA,EAAAmR,EAAArT,SAAgBkC,EACrC,GAAAmR,EAAAnR,IAAAxC,EAAA,CAA0B2T,EAAA+W,OAAAloB,EAAA,EAAkB,SAI5C,QAAAqY,IAAAlc,EAAA7B,GACA,GAAA6W,GAAAhV,EAAAw8C,WAAAx8C,EAAAw8C,UAAAr+C,EACA,IAAA6W,EAEA,OADA5M,GAAA+M,MAAAJ,UAAAvN,MAAApK,KAAAuL,UAAA,GACA9E,EAAA,EAAmBA,EAAAmR,EAAArT,SAAgBkC,EAAAmR,EAAAnR,GAAAq6B,MAAA,KAAA91B,GAInC,QAAAwmB,IAAA5uB,EAAA7B,GASA,QAAAu+C,GAAAr7C,GAAqB,kBAAkBA,EAAA68B,MAAA,KAAA91B,IARvC,GAAA4M,GAAAhV,EAAAw8C,WAAAx8C,EAAAw8C,UAAAr+C,EACA,IAAA6W,EAAA,CACA,GAAA5M,GAAA+M,MAAAJ,UAAAvN,MAAApK,KAAAuL,UAAA,EACAo0B,QACAD,GACAC,MACAh7B,WAAA46C,GAAA,GAGA,QAAA94C,GAAA,EAAmBA,EAAAmR,EAAArT,SAAgBkC,EACnCk5B,GAAAj7B,KAAA46C,EAAA1nC,EAAAnR,MAGA,QAAA68B,IAAAz3B,EAAA3C,EAAAs2C,GAEA,MADA1gC,IAAAjT,EAAA2zC,GAAAt2C,EAAAnI,KAAA8K,EAAA3C,GACA+9B,GAAA/9B,MAAAu2C,iBAGA,QAAAF,QACA7f,EACA,IAAAgB,GAAAf,EACAA,IAAA,IACA,QAAAl5B,GAAA,EAAmBA,EAAAi6B,EAAAn8B,SAAoBkC,EAAAi6B,EAAAj6B,KAGvC,QAAAugC,IAAApkC,EAAA7B,GACA,GAAA6W,GAAAhV,EAAAw8C,WAAAx8C,EAAAw8C,UAAAr+C,EACA,OAAA6W,MAAArT,OAAA,EAKA,QAAAm7C,IAAAC,GACAA,EAAAhoC,UAAAhV,GAAA,SAAA5B,EAAAkD,GAA2CtB,GAAAsE,KAAAlG,EAAAkD,IAC3C07C,EAAAhoC,UAAAlU,IAAA,SAAA1C,EAAAkD,GAA4CR,GAAAwD,KAAAlG,EAAAkD,IAY5C,QAAAqkB,MAAsBrhB,KAAAnH,GAAA,KAKtB,QAAAy5B,IAAAhhB,EAAAhH,EAAAioB,EAAAomB,EAAAC,GACA,MAAAtuC,IACAA,EAAAgH,EAAAmc,OAAA,eACA,IAAAnjB,MAAAgH,EAAAhU,QAEA,QAAAkC,GAAAm5C,GAAA,EAAA9wC,EAAA+wC,GAAA,EAAsDtuC,EAAA9K,IAASA,EAC/D,KAAA8R,EAAAtF,OAAAxM,GAAAqI,GAAA0qB,EAAA1qB,EAAA0qB,IACA1qB,CAEA,OAAAA,GAKA,QAAAujC,IAAAvjC,GACA,KAAAgxC,GAAAv7C,QAAAuK,GACAgxC,GAAAp7C,KAAAynC,GAAA2T,IAAA,IACA,OAAAA,IAAAhxC,GAGA,QAAAq9B,IAAAv0B,GAAqB,MAAAA,KAAArT,OAAA,GAErB,QAAAq+B,IAAAtiB,GACA,GAAA8I,GACA9I,EAAAukB,eAAA,EACAvkB,EAAAwkB,aAAAxkB,EAAA9T,MAAAjI,WAGA,KAAW+b,EAAAy/B,SACX,MAAAC,KAIA,QAAAj5C,IAAAk5C,EAAAjkC,GACA,GAAAikC,EAAAl5C,QAAA,MAAAk5C,GAAAl5C,QAAAiV,EACA,QAAAvV,GAAA,EAAAyC,EAAA+2C,EAAA17C,OAA0C2E,EAAAzC,IAAOA,EACjD,GAAAw5C,EAAAx5C,IAAAuV,EAAA,MAAAvV,EACA,UAGA,QAAAy5C,IAAA5mC,EAAA6mC,GACA,QAAAC,MACAA,EAAAzoC,UAAA2B,CACA,IAAA+mC,GAAA,GAAAD,EAEA,OADAD,IAAArL,GAAAqL,EAAAE,GACAA,EAGA,QAAAvL,IAAA77B,EAAA9P,GACAA,SACA,QAAApH,KAAAkX,KAAA3W,eAAAP,KAAAoH,EAAApH,GAAAkX,EAAAlX,GACA,OAAAoH,GAGA,QAAAgyB,IAAA5K,GACA,OAAAvhB,MAAAvI,EAAA,EAA2B8pB,EAAA9pB,IAAUA,EAAAuI,EAAAtK,KAAA5C,OACrC,OAAAkN,GAGA,QAAAhM,IAAAiB,GACA,GAAA+G,GAAA+M,MAAAJ,UAAAvN,MAAApK,KAAAuL,UAAA,EACA,mBAAsB,MAAAtH,GAAA68B,MAAA,KAAA91B,IAItB,QAAAmI,IAAAjE,GACA,WAAAlN,KAAAkN,MAAA,MACAA,EAAAwM,eAAAxM,EAAA1M,eAAA89C,GAAAt+C,KAAAkN,IAGA,QAAAqxC,IAAAtnC,GACA,OAAAnK,KAAAmK,GAAA,GAAAA,EAAA3W,eAAAwM,IAAAmK,EAAAnK,GAAA,QACA,UAIA,QAAA8vB,IAAA1vB,GAAgC,MAAAA,GAAA6yB,WAAA,SAAAye,GAAAx+C,KAAAkN,GAIhC,QAAA8M,IAAAykC,EAAAv/B,EAAAxL,EAAA7T,GACA,GAAAqH,GAAA3I,SAAAO,cAAA2/C,EAGA,IAFA/qC,IAAAxM,EAAAwM,aACA7T,IAAAqH,EAAArH,MAAAZ,QAAAY,GACA,gBAAAqf,GAAAsT,GAAAtrB,EAAAgY,OACA,IAAAA,EAAA,OAAAza,GAAA,EAAqCA,EAAAya,EAAA3c,SAAoBkC,EAAAyC,EAAAhI,YAAAggB,EAAAza,GACzD,OAAAyC,GAGA,QAAA8kB,IAAA9kB,GACA,OAAAw3C,GAAAx3C,EAAA5B,WAAA/C,OAAyCm8C,EAAA,IAAWA,EACpDx3C,EAAA5H,YAAA4H,EAAA6V,WACA,OAAA7V,GAGA,QAAA4uB,IAAA6d,EAAAzsC,GACA,MAAA8kB,IAAA2nB,GAAAz0C,YAAAgI,GAGA,QAAAsrB,IAAAtrB,EAAAwF,GACA4sB,IACApyB,EAAAiC,UAAA,GACAjC,EAAAhI,YAAAX,SAAAY,eAAAuN,KACKxF,EAAAy3C,YAAAjyC,EAGL,QAAAmiB,IAAAvQ,GACA,MAAAA,GAAAnD,wBAsBA,QAAAq+B,MAAkC,SAwBlC,QAAApsB,IAAAtF,GACA,SAAAqZ,GAAA,MAAAA,GACA,IAAAnhC,GAAAga,GAAA,gEAIA,OAHA8b,IAAAhO,EAAA9nB,GACAA,EAAA6a,cACAsmB,GAAAnhC,EAAAib,aAAAjb,EAAAyL,cACA01B,IAAA,EAIA,QAAAnH,IAAAlS,GACA,SAAA82B,GAAA,CACA,GAAA5+C,GAAAga,GAAA,WACA8b,IAAAhO,EAAA9N,GAAA,QAAAha,EAAAzB,SAAAY,eAAA,QACA,GAAA2oB,EAAA/K,WAAA9B,eACA2jC,GAAA5+C,EAAA6a,aAAA,GAAA7a,EAAAib,aAAA,IAAArH,IAEA,MAAAgrC,IAAA5kC,GAAA,YACAA,GAAA,yEA8DA,QAAAkb,IAAA+F,EAAA9tB,EAAAC,EAAAnL,GACA,IAAAg5B,EAAA,MAAAh5B,GAAAkL,EAAAC,EAAA,MAEA,QADA+F,IAAA,EACA1O,EAAA,EAAmBA,EAAAw2B,EAAA14B,SAAkBkC,EAAA,CACrC,GAAAu2B,GAAAC,EAAAx2B,IACAu2B,EAAA7tB,KAAAC,GAAA4tB,EAAA5tB,GAAAD,MAAAC,GAAA4tB,EAAA5tB,IAAAD,KACAlL,EAAAgG,KAAAoL,IAAA2nB,EAAA7tB,QAAAlF,KAAAL,IAAAozB,EAAA5tB,MAAA,GAAA4tB,EAAAE,MAAA,aACA/nB,GAAA,GAGAA,GAAAlR,EAAAkL,EAAAC,EAAA,OAGA,QAAA+tB,IAAAH,GAA2B,MAAAA,GAAAE,MAAA,EAAAF,EAAA5tB,GAAA4tB,EAAA7tB,KAC3B,QAAAiuB,IAAAJ,GAA4B,MAAAA,GAAAE,MAAA,EAAAF,EAAA7tB,KAAA6tB,EAAA5tB,GAE5B,QAAAgvB,IAAAv0B,GAA2B,GAAAozB,GAAA9F,GAAAttB,EAA4B,OAAAozB,GAAAE,GAAAF,EAAA,MACvD,QAAAoB,IAAAx0B,GACA,GAAAozB,GAAA9F,GAAAttB,EACA,OAAAozB,GACAG,GAAA+O,GAAAlP,IADApzB,EAAAJ,KAAAlF,OAIA,QAAAmwC,IAAA7oC,EAAAgoB,GACA,GAAAhqB,GAAAkJ,GAAAlH,EAAA2c,IAAAqL,GACAgtB,EAAA9uB,GAAAlmB,EAAA2c,IAAA3e,EACAg3C,IAAAh3C,IAAAgqB,EAAAtf,GAAAssC,GACA,IAAA5jB,GAAA9F,GAAA0pB,GACA3xC,EAAA+tB,IAAA,GAAAC,MAAA,EAAAmB,GAAAwiB,GAAAziB,GAAAyiB,GAAA,CACA,OAAApvC,IAAAoiB,EAAA3kB,GAEA,QAAA4xC,IAAAj1C,EAAAgoB,GAEA,IADA,GAAAzF,GAAAvkB,EACAukB,EAAAI,GAAA3kB,EAAAkJ,GAAAlH,EAAA2c,IAAAqL,KACAA,EAAAzF,EAAAG,OAAAnf,GAAAvF,IACA,IAAAozB,GAAA9F,GAAAttB,GACAqF,EAAA+tB,IAAA,GAAAC,MAAA,EAAAkB,GAAAv0B,GAAAw0B,GAAAx0B,KAAAJ,KAAAlF,MACA,OAAAkN,IAAAoiB,EAAA3kB,GAGA,QAAA6xC,IAAA9jB,EAAAjuB,EAAAC,GACA,GAAA+xC,GAAA/jB,EAAA,GAAAC,KACA,OAAAluB,IAAAgyC,GAAA,EACA/xC,GAAA+xC,GAAA,EACA/xC,EAAAD,EAGA,QAAAquB,IAAAJ,EAAAztB,GACA8tB,GAAA,IACA,QAAAnoB,GAAA1O,EAAA,EAA0BA,EAAAw2B,EAAA14B,SAAkBkC,EAAA,CAC5C,GAAA2L,GAAA6qB,EAAAx2B,EACA,IAAA2L,EAAAjD,KAAAK,GAAA4C,EAAAhD,GAAAI,EAAA,MAAA/I,EACA,IAAA2L,EAAAjD,MAAAK,GAAA4C,EAAAhD,IAAAI,EAAA,CACA,SAAA2F,EAES,MAAA4rC,IAAA9jB,EAAA7qB,EAAA8qB,MAAAD,EAAA9nB,GAAA+nB,QACT9qB,EAAAjD,MAAAiD,EAAAhD,KAAAkuB,GAAAnoB,GACA1O,IAEA2L,EAAAjD,MAAAiD,EAAAhD,KAAAkuB,GAAA72B,GACA0O,EANAA,GAAA1O,GAUA,MAAA0O,GAGA,QAAA8rC,IAAAp3C,EAAA2F,EAAA9J,EAAAw7C,GACA,IAAAA,EAAA,MAAA1xC,GAAA9J,CACA,GAAA8J,IAAA9J,QACA8J,EAAA,GAAAovB,GAAA/0B,EAAAJ,KAAAwJ,OAAAzD,IACA,OAAAA,GASA,QAAAkvB,IAAA70B,EAAAyH,EAAA5L,EAAAw7C,GACA,GAAAhjB,GAAA/G,GAAAttB,EACA,KAAAq0B,EAAA,MAAA6U,IAAAlpC,EAAAyH,EAAA5L,EAAAw7C,EAIA,KAHA,GAAA1xC,GAAA6tB,GAAAa,EAAA5sB,GAAA0rB,EAAAkB,EAAA1uB,GACArG,EAAA83C,GAAAp3C,EAAAyH,EAAA0rB,EAAAE,MAAA,GAAAx3B,IAAAw7C,KAEW,CACX,GAAA/3C,EAAA6zB,EAAA7tB,MAAAhG,EAAA6zB,EAAA5tB,GAAA,MAAAjG,EACA,IAAAA,GAAA6zB,EAAA7tB,MAAAhG,GAAA6zB,EAAA5tB,GACA,MAAAiuB,IAAAa,EAAA/0B,IAAAqG,EAAArG,GACA6zB,EAAAkB,EAAA1uB,GAAA9J,GACAA,EAAA,GAAAs3B,EAAAE,MAAA,EAAAF,EAAA5tB,GAAA4tB,EAAA7tB,KAGA,IADA6tB,EAAAkB,EAAA1uB,GAAA9J,IACAs3B,EAAA,WAEA7zB,GADAzD,EAAA,GAAAs3B,EAAAE,MAAA,EACA+jB,GAAAp3C,EAAAmzB,EAAA5tB,GAAA,GAAA8xC,GAEAD,GAAAp3C,EAAAmzB,EAAA7tB,KAAA,EAAA+xC,IAKA,QAAAnO,IAAAlpC,EAAAyH,EAAA5L,EAAAw7C,GACA,GAAA/3C,GAAAmI,EAAA5L,CACA,IAAAw7C,EAAA,KAAA/3C,EAAA,GAAAy1B,GAAA/0B,EAAAJ,KAAAwJ,OAAA9J,QAAAzD,CACA,UAAAyD,KAAAU,EAAAJ,KAAAlF,OAAA,KAAA4E,EAzxLA,GAAAs/B,IAAA,aAAAzmC,KAAAiU,UAAAC,WAIAyS,GAAA,UAAA3mB,KAAAiU,UAAAC,WACAN,GAAA+S,KAAA,MAAApoB,SAAA4V,cAAA5V,SAAA4V,aAAA,GACAmlB,GAAA3S,KAAA,MAAApoB,SAAA4V,cAAA5V,SAAA4V,aAAA,GACAqwB,GAAA7d,KAAA,MAAApoB,SAAA4V,cAAA5V,SAAA4V,aAAA,IACAgrC,GAAA,4BAAuCn/C,KAAAiU,UAAAC,WACvC0rB,GAAAjZ,IAAAw4B,GACAh4B,GAAA,WAAAnnB,KAAAiU,UAAAC,WACAkrC,GAAAj4B,IAAA,eAAAnnB,KAAAiU,UAAAC,WACAmrC,GAAA,WAAAr/C,KAAAiU,UAAAC,WACAqyB,GAAA,UAAAvmC,KAAAiU,UAAAC,WACAmyB,GAAA,iBAAArmC,KAAAiU,UAAAqrC,QACA72B,GAAA,UAAAzoB,KAAAiU,UAAAC,WACAqZ,GAAA,+BAAAvtB,KAAAiU,UAAAC,WACAsZ,GAAA,+BAAAxtB,KAAAiU,UAAAC,WACAs6B,GAAA,YAAAxuC,KAAAiU,UAAAC,WAEAkT,GAAA,cAAApnB,KAAAiU,UAAAC,YAAA,cAAAlU,KAAAiU,UAAAC,WAEAyR,GAAAyB,IAAA,2DAAApnB,KAAAiU,UAAAC,WACAud,GAAArK,IAAA,MAAApnB,KAAAiU,UAAArR,UACA28C,GAAA,OAAAv/C,KAAAiU,UAAArR,UAEA48C,GAAAjZ,IAAAtyB,UAAAC,UAAAjU,MAAA,sBACAu/C,SAAAtxC,OAAAsxC,GAAA,KACAA,QAAA,KAA6CjZ,IAAA,EAAepf,IAAA,EAE5D,IAgwCA6V,IAgZAmH,GAAAF,GAhpDAqO,GAAA7gB,KAAA2tB,IAAA7Y,KAAA,MAAAiZ,IAAA,MAAAA,KACAtd,GAAAuE,IAAA7G,KAAAtG,GAGAuR,IAAA,EAAA/a,IAAA,EAiyCA2N,GAAA,EA+hBA4H,GAAA,EAkGAkC,GAAA,EAAAF,GAAA,IAKAzH,IAAAyH,IAAA,IACAZ,GAAAY,GAAA,GACAgY,GAAAhY,IAAA,GACAhB,KAAAgB,GAAA,KAiGA,IAAAc,IA+GAwB,GAxDAX,GAAA,KA2HAsB,GAAArgC,EAAAqgC,UAAA,SAAAxZ,GACA,MAAAA,GAAArpB,KACAgI,GAAAqhB,EAAA3jB,KAAAtF,KAAAipB,EAAArpB,KAAAlF,OAAA,EACA4nC,GAAArZ,EAAArpB,MAAAlF,QAAA,GAAAuuB,EAAArpB,KAAAlF,OAAAuuB,EAAA3jB,KAAAD,GAAA,IAFA4jB,EAAA1jB,GA6PAnD,GAAAwF,OAkXAxF,EAAA0L,WACA8pC,YAAAx1C,EACAK,MAAA,WAAsBnM,OAAAmM,QAAesb,GAAA3gB,MAAkBo6B,GAAAp6B,OAEvDy6C,UAAA,SAAAlO,EAAAhnC,GACA,GAAAD,GAAAtF,KAAAsF,QAAAsH,EAAAtH,EAAAinC,IACAjnC,EAAAinC,IAAAhnC,GAAA,QAAAgnC,KACAjnC,EAAAinC,GAAAhnC,EACAwc,GAAA1mB,eAAAkxC,IACAjgC,GAAAtM,KAAA+hB,GAAAwqB,IAAAvsC,KAAAuF,EAAAqH,KAGA3B,UAAA,SAAAshC,GAAiC,MAAAvsC,MAAAsF,QAAAinC,IACjCznC,OAAA,WAAwB,MAAA9E,MAAAuhB,KAExBtU,UAAA,SAAA/J,EAAAsS,GACAxV,KAAA8I,MAAA8X,QAAApL,EAAA,kBAAAtS,IAEA4J,aAAA,SAAA5J,GAEA,OADA4/B,GAAA9iC,KAAA8I,MAAA8X,QACAphB,EAAA,EAAqBA,EAAAsjC,EAAAxlC,SAAiBkC,EACtC,GAAAsjC,EAAAtjC,IAAA0D,GAAA,gBAAA4/B,GAAAtjC,IAAAsjC,EAAAtjC,GAAApB,MAAA8E,EAEA,MADA4/B,GAAApb,OAAAloB,EAAA,IACA,GAIAof,WAAAtS,GAAA,cAAAouC,EAAAp1C,GACA,GAAAxB,GAAA42C,EAAAxpC,MAAAwpC,EAAA11C,EAAAqM,QAAArR,KAAAsF,QAAAo1C,EACA,IAAA52C,EAAAqtB,WAAA,SAAA9yB,OAAA,gCACA2B,MAAA8I,MAAA+X,SAAApjB,MAAgCqG,OAAA62C,SAAAD,EAAA9H,OAAAttC,KAAAstC,SAChC5yC,KAAA8I,MAAAgY,UACA4E,GAAA1lB,QAEA2e,cAAArS,GAAA,cAAAouC,GAEA,OADA75B,GAAA7gB,KAAA8I,MAAA+X,SACArhB,EAAA,EAAqBA,EAAAqhB,EAAAvjB,SAAqBkC,EAAA,CAC1C,GAAA2L,GAAA0V,EAAArhB,GAAAm7C,QACA,IAAAxvC,GAAAuvC,GAAA,gBAAAA,IAAAvvC,EAAA/M,MAAAs8C,EAIA,MAHA75B,GAAA6G,OAAAloB,EAAA,GACAQ,KAAA8I,MAAAgY,cACA4E,IAAA1lB,SAMA6E,WAAAyH,GAAA,cAAAzE,EAAApJ,EAAAosC,GACA,gBAAApsC,IAAA,gBAAAA,KACAA,EAAA,MAAAA,EAAAuB,KAAAsF,QAAA81B,YAAA,eACA38B,EAAA,kBAEA4pC,GAAAroC,KAAAuhB,IAAA1Z,IAAAhD,GAAA7E,KAAA6H,EAAApJ,EAAAosC,KAEA+P,gBAAAtuC,GAAA,cAAAs+B,GACA,GAAA7qB,GAAA/f,KAAAuhB,IAAAxB,GACA,IAAAjY,GAAAiY,EAAA7X,KAAA6X,EAAA5X,IAAA,MAAAtD,IAAA7E,KAAA+f,EAAA7X,KAAAtF,KAAAgoC,GAAA,EAEA,QADA3oC,GAAA8d,EAAA5X,GAAAvF,MAAAmd,EAAA5X,GAAAF,GAAA,KACAzI,EAAAugB,EAAA7X,KAAAtF,KAAiCX,GAAAzC,IAAQA,EAAAqF,GAAA7E,KAAAR,EAAAorC,KAKzC/+B,WAAA,SAAAtD,EAAAK,GACA,GAAA2Y,GAAAvhB,KAAAuhB,GACAhZ,GAAAgC,GAAAgX,EAAAhZ,EAIA,KAHA,GAAAO,GAAA4oB,EAAA1xB,KAAAuI,EAAA3F,KAAAgG,GAAA9E,EAAA9D,KAAAuhB,IAAAzd,KACAlB,EAAAkJ,GAAAyV,EAAAhZ,EAAA3F,MACAmc,EAAA,GAAAuuB,IAAA1qC,EAAAJ,KAAAxC,KAAAsF,QAAAitB,SACAxT,EAAAxW,MAAAN,KAAA8W,EAAAqzB,OAAA,CACArzB,EAAA1U,MAAA0U,EAAAxW,GACA,IAAA3N,GAAAkJ,EAAAoN,MAAA6N,EAAAjW,GAEA,OAAcuB,MAAA0U,EAAA1U,MACdC,IAAAyU,EAAAxW,IACA+I,OAAAyN,EAAA87B,UACApsC,UAAA7T,GAAA,KACAd,KAAAc,GAAA,KACAkO,UAGA6E,eAAA,SAAApF,GACAA,EAAAgC,GAAAvK,KAAAuhB,IAAAhZ,EACA,IAAA+c,GAAAutB,GAAA7yC,KAAA8L,GAAA9L,KAAAuhB,IAAAhZ,EAAA3F,OACAk4C,EAAA,EAAAzT,GAAA/hB,EAAAhoB,OAAA,KAAA2K,EAAAM,EAAAN,EACA,OAAAA,EAAA,MAAAqd,GAAA,EACA,QAAa,CACb,GAAAy1B,GAAAD,EAAAzT,GAAA,CACA,KAAA0T,EAAAz1B,EAAA,EAAAy1B,EAAA,OAAA9yC,EAAAo/B,EAAA0T,MACA,MAAAz1B,EAAA,EAAAy1B,EAAA,GAAA9yC,GACA,MAAAqd,GAAA,EAAAy1B,EAAA,EADAD,GAAAC,EAAA,KAKAzf,UAAA,SAAA/yB,GACA,GAAAzE,GAAA9D,KAAAuhB,IAAAzd,IACA,OAAAA,GAAAsN,UACApM,EAAAoM,UAAAtN,EAAA9D,KAAA6L,WAAAtD,GAAAO,OAAAhF,KADAA,GAIA6V,UAAA,SAAApR,EAAAzO,GACA,MAAAkG,MAAA0Z,WAAAnR,EAAAzO,GAAA,IAGA4f,WAAA,SAAAnR,EAAAzO,GACA,GAAAoU,KACA,KAAAuL,GAAApe,eAAAvB,GAAA,MAAA2f,GACA,IAAAuhC,GAAAvhC,GAAA3f,GAAAgK,EAAA9D,KAAAs7B,UAAA/yB,EACA,oBAAAzE,GAAAhK,GACAkhD,EAAAl3C,EAAAhK,KAAAoU,EAAAzQ,KAAAu9C,EAAAl3C,EAAAhK,SACO,IAAAgK,EAAAhK,GACP,OAAA0F,GAAA,EAAuBA,EAAAsE,EAAAhK,GAAAwD,OAAuBkC,IAAA,CAC9C,GAAAmN,GAAAquC,EAAAl3C,EAAAhK,GAAA0F,GACAmN,IAAAuB,EAAAzQ,KAAAkP,OAEO7I,GAAAm3C,YAAAD,EAAAl3C,EAAAm3C,YACP/sC,EAAAzQ,KAAAu9C,EAAAl3C,EAAAm3C,aACOD,EAAAl3C,EAAA1F,OACP8P,EAAAzQ,KAAAu9C,EAAAl3C,EAAA1F,MAEA,QAAAoB,GAAA,EAAqBA,EAAAw7C,EAAAE,QAAA59C,OAAyBkC,IAAA,CAC9C,GAAA2L,GAAA6vC,EAAAE,QAAA17C,EACA2L,GAAAgwC,KAAAr3C,EAAA9D,OAAA,IAAAF,GAAAoO,EAAA/C,EAAAwB,MACAuB,EAAAzQ,KAAA0N,EAAAwB,KAEA,MAAAuB,IAGAktC,cAAA,SAAAx4C,EAAAgG,GACA,GAAA2Y,GAAAvhB,KAAAuhB,GAEA,OADA3e,GAAAulC,GAAA5mB,EAAA,MAAA3e,EAAA2e,EAAAjB,MAAAiB,EAAA+H,KAAA,EAAA1mB,GACA8uB,EAAA1xB,KAAA4C,EAAA,EAAAgG,IAGAyM,aAAA,SAAAhL,EAAAvG,GACA,GAAAyE,GAAAwX,EAAA/f,KAAAuhB,IAAAxB,GAIA,OAHAxX,GAAA,MAAA8B,EAAA0V,EAAA5lB,KACA,gBAAAkQ,GAAAE,GAAAvK,KAAAuhB,IAAAlX,GACAA,EAAA0V,EAAA7X,KAAA6X,EAAA5X,GACAkN,EAAArV,KAAAuI,EAAAzE,GAAA,SAGAisB,WAAA,SAAAxnB,EAAAzE,GACA,MAAAisB,GAAA/vB,KAAAuK,GAAAvK,KAAAuhB,IAAAhZ,GAAAzE,GAAA,SAGA6Z,WAAA,SAAAkS,EAAA/rB,GAEA,MADA+rB,GAAA2F,EAAAx1B,KAAA6vB,EAAA/rB,GAAA,QACA6Z,GAAA3d,KAAA6vB,EAAAvkB,KAAAukB,EAAAta,MAGAqT,aAAA,SAAAxS,EAAAtS,GAEA,MADAsS,GAAAof,EAAAx1B,MAAsCuV,IAAAa,EAAA9K,KAAA,GAAqBxH,GAAA,QAAAyR,IAC3DqT,GAAA5oB,KAAAuhB,IAAAnL,EAAApW,KAAAoH,QAAAsc,aAEAkI,aAAA,SAAAhpB,EAAAkB,GACA,GAAAwG,IAAA,EAAA8e,EAAAppB,KAAAuhB,IAAAjB,MAAAtgB,KAAAuhB,IAAA+H,KAAA,CACA1mB,GAAA5C,KAAAuhB,IAAAjB,MAAA1d,EAAA5C,KAAAuhB,IAAAjB,MACA1d,EAAAwmB,IAA6BxmB,EAAAwmB,EAAa9e,GAAA,EAC1C,IAAAmhB,GAAA3f,GAAA9L,KAAAuhB,IAAA3e,EACA,OAAAuyB,GAAAn1B,KAAA8L,GAAA9L,KAAAuhB,IAAA3e,IAA6D2S,IAAA,EAAAjK,KAAA,GAAgBxH,GAAA,QAAAyR,KAC7EjL,EAAAmhB,EAAArV,OAAA,IAGAilC,kBAAA,WAAmC,MAAAn1B,IAAAlmB,KAAAoH,UACnCk0C,iBAAA,WAAkC,MAAAj1B,IAAArmB,KAAAoH,UAElC+V,gBAAA7Q,GAAA,cAAA1J,EAAA24C,EAAAh2C,GACA,MAAA8lC,IAAArrC,KAAA4C,EAAA,SAAAA,GACA,GAAAqrB,GAAArrB,EAAAsrB,gBAAAtrB,EAAAsrB,iBAGA,OAFAD,GAAAstB,GAAAh2C,GACAA,GAAA+zC,GAAArrB,KAAArrB,EAAAsrB,cAAA,OACA,MAIAzS,YAAAnP,GAAA,cAAAivC,GACA,GAAA32C,GAAA5E,KAAAuhB,EAAA3c,EAAA2c,IAAA/hB,EAAA+hB,EAAAjB,KACAiB,GAAA6D,KAAA,SAAAxiB,GACAA,EAAAsrB,eAAAtrB,EAAAsrB,cAAAqtB,KACA34C,EAAAsrB,cAAAqtB,GAAA,KACA71B,GAAA9gB,EAAApF,IAAA,GACA85C,GAAA12C,EAAAsrB,iBAAAtrB,EAAAsrB,cAAA,SAEA1uB,MAIAqgB,aAAAvT,GAAA,cAAA8G,EAAAjG,EAAAquC,GACA,MAAAnQ,IAAArrC,KAAAoT,EAAA,SAAAxQ,GACA,GAAA9H,GAAA,QAAAqS,EAAA,0BAAAA,EAAA,qBACA,IAAAvK,EAAA9H,GACA,OAAAqV,QAAA,YAAAqrC,EAAA,aAAAzgD,KAAA6H,EAAA9H,IAAA,QACA8H,GAAA9H,IAAA,IAAA0gD,MAFA54C,GAAA9H,GAAA0gD,CAGA,cAIAl8B,gBAAAhT,GAAA,cAAA8G,EAAAjG,EAAAquC,GACA,MAAAnQ,IAAArrC,KAAAoT,EAAA,SAAAxQ,GACA,GAAA9H,GAAA,QAAAqS,EAAA,0BAAAA,EAAA,sBACAhC,EAAAvI,EAAA9H,EACA,KAAAqQ,EAAA,QACA,UAAAqwC,EAAA54C,EAAA9H,GAAA,SACA,CACA,GAAAoT,GAAA/C,EAAAnQ,MAAA,GAAAmV,QAAA,aAAAqrC,EAAA,cACA,KAAAttC,EAAA,QACA,IAAA5D,GAAA4D,EAAAglC,MAAAhlC,EAAA,GAAA5Q,MACAsF,GAAA9H,GAAAqQ,EAAAhI,MAAA,EAAA+K,EAAAglC,QAAAhlC,EAAAglC,OAAA5oC,GAAAa,EAAA7N,OAAA,QAAA6N,EAAAhI,MAAAmH,IAAA,KAEA,aAIAknC,cAAAllC,GAAA,cAAA8G,EAAAiG,EAAA/T,GACA,MAAAksC,IAAAxxC,KAAAoT,EAAAiG,EAAA/T,KAGAm2C,iBAAA,SAAA1oC,GAAwCA,EAAAlE,SAExC6sC,SAAA,SAAA94C,GACA,mBAAAA,GAAA,CACA,IAAAylC,GAAAroC,KAAAuhB,IAAA3e,GAAA,WACA,IAAAiF,GAAAjF,CAEA,IADAA,EAAAkJ,GAAA9L,KAAAuhB,IAAA3e,IACAA,EAAA,gBACO,CACP,GAAAiF,GAAAyF,GAAA1K,EACA,UAAAiF,EAAA,YAEA,OAAcjF,KAAAiF,EAAAuL,OAAAxQ,EAAAJ,KAAAI,EAAAJ,KAAA0rB,cAAAtrB,EAAAsrB,cACdiF,UAAAvwB,EAAAuwB,UAAAhF,QAAAvrB,EAAAurB,QAAAC,UAAAxrB,EAAAwrB,UACAzC,QAAA/oB,EAAA+oB,UAGAgwB,YAAA,WAA6B,OAASzzC,KAAAlI,KAAAoH,QAAAwc,YAAAzb,GAAAnI,KAAAoH,QAAAyc,YAEtC+3B,UAAA,SAAArzC,EAAA8Q,EAAA8oB,EAAA0Z,EAAAC,GACA,GAAA10C,GAAApH,KAAAoH,OACAmB,GAAA8M,EAAArV,KAAAuK,GAAAvK,KAAAuhB,IAAAhZ,GACA,IAAAgN,GAAAhN,EAAAiN,OAAAlK,EAAA/C,EAAA+C,IAGA,IAFA+N,EAAAze,MAAAsf,SAAA,WACA9S,EAAA4b,MAAA/oB,YAAAof,GACA,QAAAwiC,EACAtmC,EAAAhN,EAAAgN,QACO,aAAAsmC,GAAA,QAAAA,EAAA,CACP,GAAAE,GAAA/4C,KAAAoL,IAAAhH,EAAAlL,QAAAsK,aAAAxG,KAAAuhB,IAAAnL,QACA4lC,EAAAh5C,KAAAoL,IAAAhH,EAAA4b,MAAAzc,YAAAa,EAAA0b,UAAAvc,cAEA,SAAAs1C,GAAAtzC,EAAAiN,OAAA6D,EAAArD,aAAA+lC,IAAAxzC,EAAAgN,IAAA8D,EAAArD,aACAT,EAAAhN,EAAAgN,IAAA8D,EAAArD,aACAzN,EAAAiN,OAAA6D,EAAArD,cAAA+lC,IACAxmC,EAAAhN,EAAAiN,QACAlK,EAAA+N,EAAAzD,YAAAomC,IACA1wC,EAAA0wC,EAAA3iC,EAAAzD,aAEAyD,EAAAze,MAAA2a,MAAA,KACA8D,EAAAze,MAAA0Q,KAAA+N,EAAAze,MAAA2Q,MAAA,GACA,SAAAuwC,GACAxwC,EAAAlE,EAAA4b,MAAAzc,YAAA8S,EAAAzD,YACAyD,EAAAze,MAAA2Q,MAAA,QAEA,QAAAuwC,EAAAxwC,EAAA,EACA,UAAAwwC,IAAAxwC,GAAAlE,EAAA4b,MAAAzc,YAAA8S,EAAAzD,aAAA,GACAyD,EAAAze,MAAA0Q,OAAA,MAEA62B,GACAsH,GAAAzpC,KAAAsL,EAAAiK,EAAAjK,EAAA+N,EAAAzD,YAAAL,EAAA8D,EAAArD,eAGAimC,iBAAA3vC,GAAA,KAAAgxB,IACA4e,kBAAA5vC,GAAA,KAAAixB,IACA4e,eAAA7vC,GAAA,KAAA+wB,IAEAvzB,YAAA,SAAAF,GACA,MAAAkQ,IAAAze,eAAAuO,GACAkQ,GAAAlQ,GAAA5J,MADA,QAIAurC,SAAA,SAAArjC,EAAAk0C,EAAA5Q,EAAAC,GACA,GAAAhtC,GAAA,CACA,GAAA29C,IAAuB39C,EAAA,GAAU29C,KACjC,QAAA58C,GAAA,EAAA2L,EAAAZ,GAAAvK,KAAAuhB,IAAArZ,GAAoDk0C,EAAA58C,IACpD2L,EAAAogC,GAAAvrC,KAAAuhB,IAAApW,EAAA1M,EAAA+sC,EAAAC,IACAtgC,EAAA+gC,WAFgE1sC,GAIhE,MAAA2L,IAGAkxC,MAAA/vC,GAAA,cAAA7N,EAAA+sC,GACA,GAAAjjC,GAAAwX,EAAA/f,KAAAuhB,IAAAxB,GAEAxX,GADAwX,EAAAviB,OAAAuiB,EAAAwe,QAAAz2B,GAAAiY,EAAA7X,KAAA6X,EAAA5X,IACAojC,GAAAvrC,KAAAuhB,IAAAxB,EAAA5lB,KAAAsE,EAAA+sC,EAAAxrC,KAAAsF,QAAAg3C,iBAEA,EAAA79C,EAAAshB,EAAA7X,KAAA6X,EAAA5X,GACA60B,GAAAh9B,KAAAuhB,IAAAhZ,IAAA9J,KAGA89C,QAAAjwC,GAAA,cAAA7N,EAAA+sC,GACA,GAAAzrB,GAAA/f,KAAAuhB,IAAAxB,GACAjY,IAAAiY,EAAA7X,KAAA6X,EAAA5X,IACAO,GAAA1I,KAAAuhB,IAAA,GAAAxB,EAAA7X,KAAAqjC,GAAAvrC,KAAAuhB,IAAAxB,EAAA5lB,KAAAsE,EAAA+sC,GAAA,cADA9iC,GAAA1I,KAAAuhB,IAAA,GAAAxB,EAAA7X,KAAA6X,EAAA5X,GAAA,WAEAnI,KAAAylB,MAAA0S,eAAA,IAGAgU,SAAA,SAAAjkC,EAAAk0C,EAAA5Q,EAAA9C,GACA,GAAAjqC,GAAA,EAAAg4B,EAAAiS,CACA,GAAA0T,IAAuB39C,EAAA,GAAU29C,KACjC,QAAA58C,GAAA,EAAA2L,EAAAZ,GAAAvK,KAAAuhB,IAAArZ,GAAoDk0C,EAAA58C,IAAYA,EAAA,CAChE,GAAAqwB,GAAAxa,EAAArV,KAAAmL,EAAA,MAIA,IAHA,MAAAsrB,IAAA5G,EAAAvkB,KACAukB,EAAAvkB,KAAAmrB,EACAtrB,EAAAghC,GAAAnsC,KAAA6vB,EAAApxB,EAAA+sC,GACArgC,EAAA+gC,QAAA,MAEA,MAAA/gC,IAGAqxC,MAAAlwC,GAAA,cAAA7N,EAAA+sC,GACA,GAAAtpC,GAAAu6C,EAAA18B,EAAA/f,KAAAuhB,IAAAxB,GACA,IAAAA,EAAAviB,OAAAuiB,EAAAwe,QAAAz2B,GAAAiY,EAAA7X,KAAA6X,EAAA5X,IAAA,CACA,GAAAI,GAAA8M,EAAArV,KAAA+f,EAAA5lB,KAAA,MACA,OAAA4lB,EAAA2oB,aAAAngC,EAAA+C,KAAAyU,EAAA2oB,YACAxmC,EAAAiqC,GAAAnsC,KAAAuI,EAAA9J,EAAA+sC,GACA,QAAAA,GAAAb,GAAA3qC,KAAA,EAAA+vB,EAAA/vB,KAAAkC,EAAA,OAAAqT,IAAAhN,EAAAgN,KACAknC,EAAAl0C,EAAA+C,SAEApJ,GAAA,EAAAzD,EAAAshB,EAAA7X,KAAA6X,EAAA5X,EAEA60B,IAAAh9B,KAAAuhB,IAAArf,IAAAzD,GACA,MAAAg+C,IAAA18B,EAAA2oB,WAAA+T,KAGAC,gBAAA,SAAAn3C,IACA,MAAAA,MAAAvF,KAAA8I,MAAAiY,cACA/gB,KAAA8I,MAAAiY,WAAA/gB,KAAA8I,MAAAiY,WACA/gB,KAAAoH,QAAAkP,OAAA7H,WAAA,wBAEAzO,KAAAoH,QAAAkP,OAAA7H,UAAAzO,KAAAoH,QAAAkP,OAAA7H,UAAAkD,QAAA,4BAEAkG,GAAA7X,KAAA,kBAAAA,UAAA8I,MAAAiY,aAEAc,SAAA,WAA0B,MAAAvoB,UAAAwoB,eAAA9hB,KAAAoH,QAAAjC,OAE1Bw3C,SAAArwC,GAAA,cAAAmqB,EAAAC,GACA6B,GAAAv4B,KAAAy2B,EAAAC,KAEAxf,cAAA,WACA,GAAAkM,GAAApjB,KAAAoH,QAAAgc,SAAAw5B,EAAA15B,EACA,QAAc5X,KAAA8X,EAAA2F,WAAAxT,IAAA6N,EAAA3L,UACdrB,OAAAgN,EAAA2E,aAAA60B,EAAA71C,MAAAqc,EAAA6E,YAAA20B,EACAp2C,aAAA4c,EAAA5c,aAAAo2C,EAAAr2C,YAAA6c,EAAA7c,YAAAq2C,IAGAnT,eAAAn9B,GAAA,cAAAwD,EAAAqpB,GACA,MAAArpB,KAAkC5H,KAAAlI,KAAAuhB,IAAAxB,IAAA5lB,KAAAgO,GAAA,MAClC,gBAAA2H,MAAkD5H,KAAAsC,GAAAsF,EAAA,GAAA3H,GAAA,MAClD,MAAA2H,EAAA5H,OAAA4H,GAA4C5H,KAAA4H,EAAA3H,GAAA,OAC5C2H,EAAA3H,KAAA2H,EAAA3H,GAAA2H,EAAA5H,MACAixB,MAAA,EAEA,IAAAtJ,GAAA/f,CACA,OAAAA,EAAA5H,KAAAtF,OACA5C,KAAAylB,MAAAwT,aAAkC/wB,KAAA4H,EAAA5H,KAAAC,GAAA2H,EAAA3H,GAAAgxB,UAClCtJ,GAAkB3nB,KAAAmN,EAAArV,KAAA8P,EAAA5H,MAClBC,GAAAkN,EAAArV,KAAA8P,EAAA3H,KAEA,IAAA00C,GAAA7jB,GAAAh5B,KAAAgD,KAAAL,IAAAktB,EAAA3nB,KAAAoD,KAAAukB,EAAA1nB,GAAAmD,MACAtI,KAAAL,IAAAktB,EAAA3nB,KAAAqN,IAAAsa,EAAA1nB,GAAAoN,KAAA4jB,EACAn2B,KAAAoL,IAAAyhB,EAAA3nB,KAAAqD,MAAAskB,EAAA1nB,GAAAoD,OACAvI,KAAAoL,IAAAyhB,EAAA3nB,KAAAsN,OAAAqa,EAAA1nB,GAAAqN,QAAA2jB,EACAZ,IAAAv4B,KAAA68C,EAAA9zB,WAAA8zB,EAAAplC,aAGAtQ,QAAAmF,GAAA,cAAAvF,EAAAqP,GACA,QAAA0mC,GAAAnwC,GACA,sBAAAA,IAAA,QAAA5R,KAAA0uB,OAAA9c,MAAA,KAAAA,EAEA,MAAA5F,IAAA/G,KAAAoH,QAAAlL,QAAAtB,MAAAmM,MAAA+1C,EAAA/1C,IACA,MAAAqP,IAAApW,KAAAoH,QAAAlL,QAAAtB,MAAAwb,OAAA0mC,EAAA1mC,IACApW,KAAAsF,QAAAG,eACAzF,KAAAoH,QAAAmd,iBAAAjnB,OAAA0C,KAAAoH,QAAAod,oBAAA,GACAxkB,KAAAylB,MAAAwS,aAAA,EACApgB,GAAA7X,KAAA,UAAAA,QAGAsM,UAAA,SAAAtP,GAA2B,MAAA+8B,IAAA/5B,KAAAhD,IAE3BuK,QAAA+E,GAAA,gBACA,GAAAywC,GAAA/8C,KAAAoH,QAAAid,gBACAyB,GAAA9lB,MACAu4B,GAAAv4B,UAAAuhB,IAAAwH,WAAA/oB,KAAAuhB,IAAA9J,WACAiO,GAAA1lB,OACA,MAAA+8C,GAAA/5C,KAAAs8B,IAAAyd,EAAA72B,GAAAlmB,KAAAoH,UAAA,KACAye,EAAA7lB,MACA6X,GAAA7X,KAAA,UAAAA,QAGAg9C,QAAA1wC,GAAA,cAAAiV,GACA,GAAA3U,GAAA5M,KAAAuhB,GAOA,OANA3U,GAAAhI,GAAA,KACA6c,GAAAzhB,KAAAuhB,GACAuE,EAAA9lB,MACA2hB,GAAA3hB,MAAA,GACAu4B,GAAAv4B,KAAAuhB,EAAAwH,WAAAxH,EAAA9J,WACA8S,GAAAvqB,KAAA,UAAAA,KAAA4M,GACAA,IAGAqwC,cAAA,WAA8B,MAAAj9C,MAAAoH,QAAAjC,OAC9BkS,kBAAA,WAAkC,MAAArX,MAAAoH,QAAAlL,SAClCghD,mBAAA,WAAmC,MAAAl9C,MAAAoH,QAAAgc,UACnC+5B,iBAAA,WAAiC,MAAAn9C,MAAAoH,QAAA2W,UAEjC06B,GAAAzzC,EAIA,IAAA+c,IAAA/c,EAAA+c,kBAGA5B,GAAAnb,EAAAmb,YAQAtT,GAAA7H,EAAA6H,MAAgCmgC,SAAA,WAAqB,yBAIrDT,IAAA,oBAAA3nC,EAAA+H,GACA/H,EAAAw4C,SAAAzwC,KACG,GACH4/B,GAAA,qBAAA3nC,EAAA+H,GACA/H,EAAA2c,IAAA2D,WAAAvY,EACAsY,EAAArgB,KACG,GAEH2nC,GAAA,eAAAtnB,GAAA,GACAsnB,GAAA,qBACAA,GAAA,kBACAA,GAAA,qBAAA3nC,GACAugB,EAAAvgB,GACAkhB,EAAAlhB,GACA8gB,GAAA9gB,KACG,GACH2nC,GAAA,2EAAA3nC,EAAA+H,GACA/H,EAAAU,QAAA2uC,aAAA,GAAA9jC,QAAAxD,EAAAxP,QAAAwP,EAAA5R,KAAA,mBACA6J,EAAA2C,YACG,GACHglC,GAAA,yBAAAwH,GAAA,SAAAnvC,GAAgFA,EAAA2C,YAAc,GAC9FglC,GAAA,oBACAA,GAAA,mBAAA+N,IACA/N,GAAA,4BAEAA,GAAA,2BAAA3nC,GACA0c,EAAA1c,GACAgiB,EAAAhiB,KACG,GACH2nC,GAAA,mBAAA5lB,GACA4lB,GAAA,kBAEAA,GAAA,mBACAA,GAAA,oBAEAA,GAAA,kBAAA5mB,GAAA,GACA4mB,GAAA,sBAAA3nC,GACAwb,EAAAxb,EAAAU,SACAshB,EAAAhiB,KACG,GACH2nC,GAAA,0BAAA3nC,EAAA+H,GACA/H,EAAAwC,QAAA2W,QAAAnjB,MAAA0Q,KAAAqB,EAAAmc,EAAAlkB,EAAAwC,SAAA,SACAxC,EAAA2C,YACG,GACHglC,GAAA,gCAAAxmB,GAAA,GACAwmB,GAAA,0BAAA3nC,GACAwb,EAAAxb,EAAAU,SACAshB,EAAAhiB,KACG,GACH2nC,GAAA,oBAAA3lB,GAAA,GACA2lB,GAAA,+BAAA8Q,GAAmD,MAAAA,IAAgBz2B,GAAA,GACnE2lB,GAAA,6BAAAjiB,GAAA,GAEAiiB,GAAA,kCAEAA,GAAA,uBAAA3nC,EAAA+H,GACA,YAAAA,GACAmK,GAAAlS,GACAA,EAAAwC,QAAAjC,MAAA24B,OACAl5B,EAAAwC,QAAAk2C,UAAA,IAEA14C,EAAAwC,QAAAk2C,UAAA,EACA3wC,GAAAgV,GAAA/c,GAAA,MAGA2nC,GAAA,2BAAA3nC,EAAA+H,GAAmDA,GAAAgV,GAAA/c,GAAA,KAAgC,GACnF2nC,GAAA,eAEAA,GAAA,uBACAA,GAAA,wBACAA,GAAA,kBACAA,GAAA,gBACAA,GAAA,iBACAA,GAAA,kBAAApnB,GAAA,GACAonB,GAAA,kBAAApnB,GAAA,GACAonB,GAAA,oBACAA,GAAA,wBAAA3nC,EAAA+H,GAA4C/H,EAAA2c,IAAAglB,QAAAiQ,UAAA7pC,IAC5C4/B,GAAA,yBACAA,GAAA,6BAAA3nC,GAA4CA,EAAA2C,YAAc,GAC1DglC,GAAA,yBAAApnB,GAAA,GACAonB,GAAA,0BACAA,GAAA,kCAAA3nC,EAAA+H,GACAA,IAAA/H,EAAAwC,QAAAib,SAAAznB,MAAA2a,IAAA3Q,EAAAwC,QAAAib,SAAAznB,MAAA0Q,KAAA,KAGAihC,GAAA,yBAAA3nC,EAAA+H,GACA/H,EAAAwC,QAAAjC,MAAAo4C,SAAA5wC,GAAA,KAEA4/B,GAAA,iBAKA,IAAAiR,IAAAx4C,EAAAw4C,SAAmCC,GAAAz4C,EAAAy4C,YAEnCz4C,GAAA04C,WAAA,SAAAt/C,EAAA0F,GAEA,GADAkB,EAAAmb,SAAArc,MAAA,QAAA1F,IAAA4G,EAAAmb,SAAArc,KAAA1F,GACAkG,UAAAhH,OAAA,GACAwG,EAAA65C,eACA,QAAAn+C,GAAA,EAAqBA,EAAA8E,UAAAhH,SAAsBkC,EAAAsE,EAAA65C,aAAAlgD,KAAA6G,UAAA9E,IAE3Cg+C,GAAAp/C,GAAA0F,GAGAkB,EAAA44C,WAAA,SAAAC,EAAAnD,GACA+C,GAAAI,GAAAnD,GAGA11C,EAAA84C,YAAA,SAAApD,GACA,mBAAAA,IAAA+C,GAAApiD,eAAAq/C,GACAA,EAAA+C,GAAA/C,OACK,IAAAA,GAAA,gBAAAA,GAAAt8C,MAAAq/C,GAAApiD,eAAAq/C,EAAAt8C,MAAA,CACL,GAAA8P,GAAAuvC,GAAA/C,EAAAt8C,KACA,iBAAA8P,QAA6C9P,KAAA8P,IAC7CwsC,EAAAzB,GAAA/qC,EAAAwsC,GACAA,EAAAt8C,KAAA8P,EAAA9P,SACK,oBAAAs8C,IAAA,0BAAA3/C,KAAA2/C,GACL,MAAA11C,GAAA84C,YAAA,kBAEA,uBAAApD,IAAyCt8C,KAAAs8C,GACzCA,IAAyBt8C,KAAA,SAGzB4G,EAAAqM,QAAA,SAAA/L,EAAAo1C,GACA,GAAAA,GAAA11C,EAAA84C,YAAApD,GACAqD,EAAAP,GAAA9C,EAAAt8C,KACA,KAAA2/C,EAAA,MAAA/4C,GAAAqM,QAAA/L,EAAA,aACA,IAAA04C,GAAAD,EAAAz4C,EAAAo1C,EACA,IAAAuD,GAAA5iD,eAAAq/C,EAAAt8C,MAAA,CACA,GAAA8/C,GAAAD,GAAAvD,EAAAt8C,KACA,QAAAtD,KAAAojD,GACAA,EAAA7iD,eAAAP,KACAkjD,EAAA3iD,eAAAP,KAAAkjD,EAAA,IAAAljD,GAAAkjD,EAAAljD,IACAkjD,EAAAljD,GAAAojD,EAAApjD,IAKA,GAFAkjD,EAAA5/C,KAAAs8C,EAAAt8C,KACAs8C,EAAAO,aAAA+C,EAAA/C,WAAAP,EAAAO,YACAP,EAAAyD,UAAA,OAAArjD,KAAA4/C,GAAAyD,UACAH,EAAAljD,GAAA4/C,EAAAyD,UAAArjD,EAEA,OAAAkjD,IAGAh5C,EAAA04C,WAAA,kBACA,OAAYxsC,MAAA,SAAA6N,GAAyBA,EAAAI,gBAErCna,EAAA44C,WAAA,oBAEA,IAAAK,IAAAj5C,EAAAi5C,iBACAj5C,GAAAo5C,WAAA,SAAAt6C,EAAAu6C,GACA,GAAAH,GAAAD,GAAA5iD,eAAAyI,GAAAm6C,GAAAn6C,GAAAm6C,GAAAn6C,KACA+pC,IAAAwQ,EAAAH,IAKAl5C,EAAAyK,gBAAA,SAAArR,EAAAkgD,GACAt5C,EAAA0L,UAAAtS,GAAAkgD,GAEAt5C,EAAAu5C,mBAAA,SAAAngD,EAAAkgD,GACA98B,GAAA9Q,UAAAtS,GAAAkgD,GAEAt5C,EAAA0H,aAAA6/B,EAEA,IAAAtqB,MACAjd,GAAAw5C,eAAA,SAAAxhD,GAA2CilB,GAAAxkB,KAAAT,GAE3C,IAAAyc,IAAAzU,EAAAyU,UACAzU,GAAA4K,eAAA,SAAA9V,EAAAsE,EAAAmH,GACAkU,GAAApe,eAAAvB,KAAA2f,GAAA3f,GAAAkL,EAAAlL,IAA2EohD,aAC3EzhC,GAAA3f,GAAAsE,GAAAmH,GAEAP,EAAAy5C,qBAAA,SAAA3kD,EAAAsE,EAAAsgD,EAAAn5C,GACAP,EAAA4K,eAAA9V,EAAAsE,EAAAmH,GACAkU,GAAA3f,GAAAohD,QAAAz9C,MAAgC09C,KAAAuD,EAAA/xC,IAAApH,KAKhCP,EAAAkH,cAiBAlH,EAAAysB,aAKAzsB,EAAAmsB,cAEAnsB,EAAAoM,UAAA,SAAAtN,EAAAgF,GACA,KAAAhF,EAAAsN,WAAA,CACA,GAAAutC,GAAA76C,EAAAsN,UAAAtI,EACA,KAAA61C,KAAA76C,QAAA,KACAgF,GAAA61C,EAAA71C,MACAhF,EAAA66C,EAAA76C,KAEA,MAAA66C,KAAoB76C,OAAAgF,SAKpB,IAAAgR,IAAA9U,EAAA8U,UACA6qB,UAAA,SAAA//B,GAA6BA,EAAA8F,aAAAF,GAAA5F,EAAAyL,YAAA,GAAA7F,GAAA5F,EAAA0L,cAC7BsuC,SAAA,SAAAh6C,GACA,GAAAsD,GAAAtD,EAAAG,WAAA,GAAAoD,EAAAvD,EAAAG,WAAA,GAAAgb,GAAAjY,GAAAI,EAAAC,EACA4X,IAAAnb,EAAAkH,QAAA5D,EAAAtF,MAAAtF,QAAA4K,EAAAD,GAEArD,EAAA8D,aAAA,GAAAR,EAAA6X,EAAA5X,EAAAqC,GAAAtC,EAAAtF,MAAA,WADAgC,EAAA8D,aAAA,GAAAR,EAAAsC,GAAAtC,EAAAtF,KAAA,iBAGAi8C,WAAA,SAAAj6C,GACA,GAAAtF,GAAAsF,EAAAG,YAAAnC,IACAgC,GAAA8D,aAAA,GAAA8B,GAAAlL,EAAA,GAAAkL,GAAAlL,EAAA,iBAEAw/C,YAAA,SAAAl6C,GACA,GAAAuG,GAAAvG,EAAAG,WACAH,GAAA8D,aAAA,GAAA8B,GAAAW,EAAAvI,KAAA,GAAAuI,EAAA,YAEA4zC,KAAA,SAAAn6C,GAAwBA,EAAAm6C,QACxBC,KAAA,SAAAp6C,GAAwBA,EAAAo6C,QACxBC,WAAA,SAAAr6C,GAA8BA,EAAAo4B,gBAAAxyB,GAAA5F,EAAAyL,YAAA,KAC9B6uC,SAAA,SAAAt6C,GAA4BA,EAAAo4B,gBAAAxyB,GAAA5F,EAAA0L,cAC5B6uC,YAAA,SAAAv6C,GACAA,EAAAo4B,gBAAAyQ,GAAA7oC,IAAAG,YAAAnC,QAEAw8C,iBAAA,SAAAx6C,GACA,GAAAuG,GAAAvG,EAAAG,YAAAsF,EAAAojC,GAAA7oC,EAAAuG,EAAAvI,MACAA,EAAAgC,EAAAqJ,cAAA5D,EAAAzH,MACAozB,EAAA9F,GAAAttB,EACA,IAAAozB,GAAA,GAAAA,EAAA,GAAAC,MAIOrxB,EAAAo4B,gBAAA3yB,OAJP,CACA,GAAAg1C,GAAAr8C,KAAAoL,IAAA,EAAAxL,EAAAJ,KAAAirB,OAAA,OACA6xB,EAAAn0C,EAAAvI,MAAAyH,EAAAzH,MAAAuI,EAAAlD,IAAAo3C,GAAAl0C,EAAAlD,EACArD,GAAAo4B,gBAAAxyB,GAAAH,EAAAzH,KAAA08C,EAAA,EAAAD,MAGAE,UAAA,SAAA36C,GACAA,EAAAo4B,gBAAA6c,GAAAj1C,IAAAG,YAAAnC,QAEA48C,YAAA,SAAA56C,GACA,GAAA2Q,GAAA3Q,EAAAmrB,WAAAnrB,EAAAG,YAAA,OAAAwQ,IAAA,CACA3Q,GAAAo4B,gBAAAp4B,EAAA+Y,YAAwCrS,KAAA1G,EAAAwC,QAAAsb,QAAA9M,YAAA,IAAAL,OAAqD,SAE7FkqC,WAAA,SAAA76C,GACA,GAAA2Q,GAAA3Q,EAAAmrB,WAAAnrB,EAAAG,YAAA,OAAAwQ,IAAA,CACA3Q,GAAAo4B,gBAAAp4B,EAAA+Y,YAAwCrS,KAAA,EAAAiK,OAAkB,SAE1DmqC,SAAA,SAAA96C,GAA4BA,EAAA43C,MAAA,YAC5BmD,WAAA,SAAA/6C,GAA8BA,EAAA43C,MAAA,WAC9BoD,SAAA,SAAAh7C,GAA4BA,EAAA43C,MAAA,YAC5BqD,WAAA,SAAAj7C,GAA8BA,EAAA43C,MAAA,WAC9BsD,WAAA,SAAAl7C,GAA8BA,EAAAy3C,MAAA,YAC9B0D,YAAA,SAAAn7C,GAA+BA,EAAAy3C,MAAA,WAC/B2D,aAAA,SAAAp7C,GAAgCA,EAAAy3C,MAAA,cAChC4D,cAAA,SAAAr7C,GAAiCA,EAAAy3C,MAAA,aACjC6D,WAAA,SAAAt7C,GAA8BA,EAAAy3C,MAAA,YAC9B8D,aAAA,SAAAv7C,GAAgCA,EAAAy3C,MAAA,YAChC+D,YAAA,SAAAx7C,GAA+BA,EAAAy3C,MAAA,aAC/BgE,YAAA,SAAAz7C,GAA+BA,EAAAy3C,MAAA,WAC/BiE,cAAA,SAAA17C,GAAiCA,EAAA23C,QAAA,YACjCgE,aAAA,SAAA37C,GAAgCA,EAAA23C,QAAA,WAChCiE,cAAA,SAAA57C,GAAiCA,EAAA23C,QAAA,YACjCkE,aAAA,SAAA77C,GAAgCA,EAAA23C,QAAA,WAChCmE,eAAA,SAAA97C,GAAkCA,EAAA23C,QAAA,aAClCoE,cAAA,SAAA/7C,GAAiCA,EAAA23C,QAAA,YACjCqE,WAAA,SAAAh8C,GAA8BA,EAAAg2C,gBAAA,UAC9BiG,WAAA,SAAAj8C,GAA8BA,EAAAg2C,gBAAA,QAC9BkG,WAAA,SAAAl8C,GAA8BA,EAAAg2C,gBAAA,aAC9BmG,UAAA,SAAAn8C,GACAA,EAAA8E,iBAAA,qBAEAs3C,WAAA,SAAAp8C,GACAA,EAAAoG,oBAAApG,EAAAg2C,gBAAA,OACAh2C,EAAA8E,iBAAA,qBAEAu3C,eAAA,SAAAr8C,GACA,GAAAuG,GAAAvG,EAAAG,YAAAnC,EAAAgC,EAAAkH,QAAAX,EAAAvI,KACAuI,GAAAlD,GAAA,GAAAkD,EAAAlD,GAAArF,EAAAtF,OAAA,GACAsH,EAAA8D,aAAA9F,EAAAoJ,OAAAb,EAAAlD,IAAArF,EAAAoJ,OAAAb,EAAAlD,GAAA,GACAuC,GAAAW,EAAAvI,KAAAuI,EAAAlD,GAAA,GAAAuC,GAAAW,EAAAvI,KAAAuI,EAAAlD,GAAA,KAEAi5C,iBAAA,SAAAt8C,GACA0H,GAAA1H,EAAA,WACAA,EAAA8E,iBAAA,qBACA9E,EAAAC,WAAAD,EAAAG,YAAAnC,KAAA,cAGA85C,gBAAA,SAAA93C,GAAmCA,EAAA83C,oBAKnClmC,GAAAxR,EAAAwR,SACAA,IAAA2qC,OACAC,KAAA,aAAAC,MAAA,cAAA5tC,GAAA,WAAAE,KAAA,aACAM,IAAA,YAAAF,KAAA,mBAAAH,OAAA,WAAAE,SAAA,aACAwtC,OAAA,eAAAv2C,UAAA,gBAAAw2C,kBAAA,gBACA58C,IAAA,aAAA68C,YAAA,aACAx0C,MAAA,mBAAAy0C,OAAA,mBAIAjrC,GAAAkrC,WACAC,SAAA,YAAAC,SAAA,aAAAC,SAAA,OAAAC,eAAA,OAAAC,SAAA,OACAC,YAAA,aAAAC,UAAA,aAAAC,WAAA,WAAAC,YAAA,WACAC,YAAA,cAAAC,aAAA,eAAAC,WAAA,cAAAC,YAAA,YACAC,iBAAA,iBAAAC,cAAA,gBAAAC,SAAA,OAAAC,SAAA,OACAC,SAAA,WAAAC,eAAA,WAAAC,eAAA,UAAAC,eAAA,aACAC,SAAA,aAAAC,SAAA,aACAlW,YAAA,SAEAv2B,GAAA0sC,YACAC,QAAA,YAAAC,QAAA,aAAAC,QAAA,OAAAC,cAAA,OAAAC,QAAA,OACAC,SAAA,aAAAC,UAAA,WAAAC,WAAA,WAAApB,WAAA,cACAC,YAAA,eAAAoB,WAAA,cAAAC,YAAA,YAAAC,gBAAA,iBACAC,qBAAA,gBAAAC,aAAA,gBAAAC,QAAA,OAAAC,QAAA,OACAC,QAAA,WAAAC,cAAA,WAAAC,YAAA,UAAAC,kBAAA,aACAC,QAAA,aAAAC,QAAA,aAAAC,gBAAA,cACAzX,aAAA,mBAEAv2B,GAAA,WAAAgW,GAAAhW,GAAA0sC,WAAA1sC,GAAAkrC,UACAlrC,GAAAiuC,QACA9B,SAAA,cAAA+B,SAAA,aAAAC,SAAA,WAAAC,SAAA,aACAC,QAAA,cAAAC,QAAA,aAAAnD,SAAA,cAAAoD,SAAA,YACAC,SAAA,aAAAC,eAAA,WAAArD,SAAA,eAAAsD,SAAA,gBACAC,QAAA,eAAAtB,gBAAA,gBAAAuB,SAAA,WAAAC,SAAA,kBAgDArgD,EAAAu+B,aACAv+B,EAAAm+B,iBACAn+B,EAAAo+B,WAIAp+B,EAAAsgD,aAAA,SAAAC,EAAAjgD,GAiBA,QAAAktB,KAAqB+yB,EAAAhgD,MAAAX,EAAA+X,WARrB,GARArX,UACAA,EAAAC,MAAAggD,EAAAhgD,OACAD,EAAAkgD,UAAAD,EAAAC,WACAlgD,EAAAkgD,SAAAD,EAAAC,WACAlgD,EAAAmgD,aAAAF,EAAAE,cACAngD,EAAAmgD,YAAAF,EAAAE,aAGA,MAAAngD,EAAAmb,UAAA,CACA,GAAAoB,GAAAvoB,SAAAoB,IAEA,KAAWmnB,EAAAvoB,SAAAwoB,cAAqC,MAAA7f,IAChDqD,EAAAmb,UAAAoB,GAAA0jC,GACA,MAAAA,EAAAG,aAAA,cAAA7jC,GAAAvoB,SAAAoB,KAIA,GAAA6qD,EAAAI,OACAjqD,GAAA6pD,EAAAI,KAAA,SAAAnzB,IAEAltB,EAAAsgD,wBAAA,CACA,GAAAD,GAAAJ,EAAAI,KAAAE,EAAAF,EAAAG,MACA,KACA,GAAAC,GAAAJ,EAAAG,OAAA,WACAtzB,IACAmzB,EAAAG,OAAAD,EACAF,EAAAG,SACAH,EAAAG,OAAAC,GAES,MAAA9jD,KAITsjD,EAAA3qD,MAAAwM,QAAA,MACA,IAAAxC,GAAAI,EAAA,SAAAqU,GACAksC,EAAA5hD,WAAAiqB,aAAAvU,EAAAksC,EAAAt8B,cACK3jB,EAaL,OAZAV,GAAA4tB,OACA5tB,EAAAohD,YAAA,WAAiC,MAAAT,IACjC3gD,EAAAqhD,WAAA,WACAzzB,IACA+yB,EAAA5hD,WAAAtJ,YAAAuK,EAAAyS,qBACAkuC,EAAA3qD,MAAAwM,QAAA,GACAm+C,EAAAI,OACAnpD,GAAA+oD,EAAAI,KAAA,SAAAnzB,GACA,kBAAA+yB,GAAAI,KAAAG,SACAP,EAAAI,KAAAG,OAAAD,KAGAjhD,GAiBA0oC,GAAA58B,WACA0hC,IAAA,WAAqB,MAAApyC,MAAAuI,KAAAvI,KAAAsR,OAAAhU,QACrB4oD,IAAA,WAAqB,MAAAlmD,MAAAuI,KAAAvI,KAAAytC,WACrB0Y,KAAA,WAAsB,MAAAnmD,MAAAsR,OAAAtF,OAAAhM,KAAAuI,MAAA1N,QACtB8X,KAAA,WACA,MAAA3S,MAAAuI,IAAAvI,KAAAsR,OAAAhU,OACA0C,KAAAsR,OAAAtF,OAAAhM,KAAAuI,OADA,QAGA69C,IAAA,SAAAprD,GACA,GAAAiN,GAAAjI,KAAAsR,OAAAtF,OAAAhM,KAAAuI,IACA,oBAAAvN,GAAA,GAAAy8C,GAAAxvC,GAAAjN,MACA,IAAAy8C,GAAAxvC,IAAAjN,EAAAD,KAAAC,EAAAD,KAAAkN,GAAAjN,EAAAiN,GACA,OAAAwvC,MAAez3C,KAAAuI,IAAWN,GAA1B,QAEAo+C,SAAA,SAAArrD,GAEA,IADA,GAAAqP,GAAArK,KAAAuI,IACAvI,KAAAomD,IAAAprD,KACA,MAAAgF,MAAAuI,IAAA8B,GAEAi8C,SAAA,WAEA,IADA,GAAAj8C,GAAArK,KAAAuI,IACA,aAAAxN,KAAAiF,KAAAsR,OAAAtF,OAAAhM,KAAAuI,SAAAvI,KAAAuI,GACA,OAAAvI,MAAAuI,IAAA8B,GAEA8U,UAAA,WAA2Bnf,KAAAuI,IAAAvI,KAAAsR,OAAAhU,QAC3B4hB,OAAA,SAAAjX,GACA,GAAAiG,GAAAlO,KAAAsR,OAAAxR,QAAAmI,EAAAjI,KAAAuI,IACA,OAAA2F,GAAA,IAAuBlO,KAAAuI,IAAA2F,GAAiB,GAAxC,QAEAq4C,OAAA,SAAA1+C,GAAyB7H,KAAAuI,KAAAV,GACzB2+C,OAAA,WAKA,MAJAxmD,MAAAutC,cAAAvtC,KAAAqK,QACArK,KAAAwtC,gBAAAlb,GAAAtyB,KAAAsR,OAAAtR,KAAAqK,MAAArK,KAAAuyB,QAAAvyB,KAAAutC,cAAAvtC,KAAAwtC,iBACAxtC,KAAAutC,cAAAvtC,KAAAqK,OAEArK,KAAAwtC,iBAAAxtC,KAAAytC,UAAAnb,GAAAtyB,KAAAsR,OAAAtR,KAAAytC,UAAAztC,KAAAuyB,SAAA,IAEAwY,YAAA,WACA,MAAAzY,IAAAtyB,KAAAsR,OAAA,KAAAtR,KAAAuyB,UACAvyB,KAAAytC,UAAAnb,GAAAtyB,KAAAsR,OAAAtR,KAAAytC,UAAAztC,KAAAuyB,SAAA,IAEAv3B,MAAA,SAAAyrD,EAAAC,EAAAC,GACA,mBAAAF,GAOO,CACP,GAAAzrD,GAAAgF,KAAAsR,OAAAnO,MAAAnD,KAAAuI,KAAAvN,MAAAyrD,EACA,OAAAzrD,MAAAk4C,MAAA,QACAl4C,GAAA0rD,KAAA,IAAA1mD,KAAAuI,KAAAvN,EAAA,GAAAsC,QACAtC,GAVA,GAAA4rD,GAAA,SAAAn/C,GAAmC,MAAAk/C,GAAAl/C,EAAAlM,cAAAkM,GACnCo/C,EAAA7mD,KAAAsR,OAAAu1C,OAAA7mD,KAAAuI,IAAAk+C,EAAAnpD,OACA,OAAAspD,GAAAC,IAAAD,EAAAH,IACAC,KAAA,IAAA1mD,KAAAuI,KAAAk+C,EAAAnpD,SACA,GAFA,QAWAu9C,QAAA,WAAwB,MAAA76C,MAAAsR,OAAAnO,MAAAnD,KAAAqK,MAAArK,KAAAuI,MACxBu+C,eAAA,SAAAj/C,EAAAoU,GACAjc,KAAAytC,WAAA5lC,CACA,KAAW,MAAAoU,KACX,QAAejc,KAAAytC,WAAA5lC,KAGf7C,EAAAsoC,gBASAtoC,EAAA0oC,cACA+K,GAAA/K,IAEAA,GAAAh9B,UAAA7B,MAAA,WACA,IAAA7O,KAAAmpC,kBAAA,CACA,GAAAvkC,GAAA5E,KAAAuhB,IAAA3c,GAAA+0B,EAAA/0B,MAAA6gB,KAEA,IADAkU,GAAA3B,GAAApzB,GACAm7B,GAAA//B,KAAA,UACA,GAAAkO,GAAAlO,KAAAsnB,MACApZ,IAAAqc,GAAAvqB,KAAA,QAAAkO,EAAAhG,KAAAgG,EAAA/F,IAGA,OADAxF,GAAA,KAAAyL,EAAA,KACA5O,EAAA,EAAmBA,EAAAQ,KAAAiH,MAAA3J,SAAuBkC,EAAA,CAC1C,GAAAoD,GAAA5C,KAAAiH,MAAAzH,GACAqe,EAAAgxB,GAAAjsC,EAAAqwB,YAAAjzB,KACA,OAAA6d,EAAA1V,KAAAiG,EAAAd,GAAA1K,IACAA,EAAAqwB,YAAA6b,GAAAlsC,EAAAqwB,YAAApV,GACA,MAAAA,EAAA3V,KACAvF,EAAA2K,GAAA1K,GACA5C,KAAA8uB,YAAAxI,GAAAtmB,KAAAuhB,IAAA3e,IAAAgC,GACA8hB,GAAA9jB,EAAAsjB,GAAAthB,EAAAwC,UAEA,GAAAxC,GAAA5E,KAAA8uB,YAAAlqB,EAAAU,QAAAG,aAAA,OAAAjG,GAAA,EAAyEA,EAAAQ,KAAAiH,MAAA3J,SAAuBkC,EAAA,CAChG,GAAAo6C,GAAA9uB,GAAAlmB,EAAA2c,IAAAvhB,KAAAiH,MAAAzH,IAAA4nB,EAAAF,EAAAtiB,EAAA2c,IAAAq4B,EACAxyB,GAAAxiB,EAAAwC,QAAAud,gBACA/f,EAAAwC,QAAAsd,QAAAk1B,EACAh1C,EAAAwC,QAAAud,cAAAyC,EACAxiB,EAAAwC,QAAAwd,gBAAA,GAIA,MAAAjiB,GAAAiC,GAAA8gB,GAAA9gB,EAAAjC,EAAAyL,EAAA,GACApO,KAAAiH,MAAA3J,OAAA,EACA0C,KAAAmpC,mBAAA,EACAnpC,KAAAopC,QAAAppC,KAAAuhB,IAAAua,WACA97B,KAAAuhB,IAAAua,UAAA,EACAl3B,GAAAikC,GAAAjkC,IAEA+0B,GAAAhB,GAAA/zB,KAGA8oC,GAAAh9B,UAAA4W,KAAA,SAAAy/B,GAEA,OADA7+C,GAAAC,EACA3I,EAAA,EAAmBA,EAAAQ,KAAAiH,MAAA3J,SAAuBkC,EAAA,CAC1C,GAAAoD,GAAA5C,KAAAiH,MAAAzH,GACAqe,EAAAgxB,GAAAjsC,EAAAqwB,YAAAjzB,KACA,UAAA6d,EAAA3V,MAAA,MAAA2V,EAAA1V,GAAA,CACA,GAAA+F,GAAAZ,GAAA1K,EACA,OAAAib,EAAA3V,SAAAsC,GAAA0D,EAAA2P,EAAA3V,OACA,MAAA2V,EAAA1V,OAAAqC,GAAA0D,EAAA2P,EAAA1V,MAGA,kBAAAnI,KAAAlG,MAAAitD,EACA7+C,IAAoBA,OAAAC,MADpBD,GAIAwlC,GAAAh9B,UAAAihB,QAAA,WACA,GAAAppB,GAAAvI,KAAAsnB,OAAA1iB,EAAA5E,KAAAuhB,IAAA3c,EACA,IAAA2D,GAAA3D,EAAA,CACA,YAAA5E,KAAAlG,OAAAyO,IAAAL,KACA,IAAAtF,GAAAkJ,GAAA9L,KAAAuhB,IAAAhZ,EAAA3F,KAEA,IADAwwB,EAAAxuB,EAAAhC,GACA2F,EAAA3F,MAAAgC,EAAAwC,QAAAwc,aAAArb,EAAA3F,KAAAgC,EAAAwC,QAAAyc,UAAA,CACA,OAAAxK,GAAAzU,EAAAwC,QAAAsb,QAAA5K,WAAoDuB,EAAMA,IAAA4P,YAAA,GAAA5P,EAAAoS,SAAA7oB,EAAA,CAC1DyW,EAAArD,cAAApT,EAAAwT,QAAAsQ,GAAA9jB,EAAAyW,EAAArD,aACA,OAEA+jB,GAAAn1B,EAAA,WACAA,EAAA6gB,MAAA4S,iBAAAzzB,EAAA6gB,MAAAwS,YAAArzB,EAAA6gB,MAAA6S,eAAA,OAKAoV,GAAAh9B,UAAAq+B,WAAA,SAAAnsC,GACA,IAAA5C,KAAAiH,MAAA3J,QAAA0C,KAAAuhB,IAAA3c,GAAA,CACA,GAAAg0B,GAAA54B,KAAAuhB,IAAA3c,GAAA6gB,KACAmT,GAAAU,oBAAA,IAAAx5B,GAAA84B,EAAAU,mBAAAt5B,QACA44B,EAAAY,uBAAAZ,EAAAY,0BAAA/7B,KAAAuC;CAEAA,KAAAiH,MAAAxJ,KAAAmF,IAEA8qC,GAAAh9B,UAAA2gC,WAAA,SAAAzuC,GAEA,GADA5C,KAAAiH,MAAAygB,OAAA5nB,GAAAE,KAAAiH,MAAArE,GAAA,IACA5C,KAAAiH,MAAA3J,QAAA0C,KAAAuhB,IAAA3c,GAAA,CACA,GAAAg0B,GAAA54B,KAAAuhB,IAAA3c,GAAA6gB,OACAmT,EAAAU,qBAAAV,EAAAU,wBAAA77B,KAAAuC,OAIA,IAAAouC,IAAA,CAuEAppC,GAAAupC,oBACAkK,GAAAlK,IAEAA,GAAA79B,UAAA7B,MAAA,WACA,IAAA7O,KAAAmpC,kBAAA,CACAnpC,KAAAmpC,mBAAA,CACA,QAAA3pC,GAAA,EAAmBA,EAAAQ,KAAAiuB,QAAA3wB,SAAyBkC,EAC5CQ,KAAAiuB,QAAAzuB,GAAAqP,OACA0b,IAAAvqB,KAAA,WAEAuuC,GAAA79B,UAAA4W,KAAA,WACA,MAAAtnB,MAAAwuC,QAAAlnB,OAqRA,IAAAmqB,IAAAzsC,EAAAysC,WAAA,SAAA7sC,EAAAyU,EAAA/T,GACA,GAAAA,EAAA,OAAA4a,KAAA5a,KAAAjK,eAAA6kB,KACAlgB,KAAAkgB,GAAA5a,EAAA4a,GACAlgB,MAAA4E,KACA5E,KAAAqZ,OAEAo/B,IAAAhH,IAUAA,GAAA/gC,UAAA7B,MAAA0iC,GAAA,WACA,GAAA7iB,GAAA1uB,KAAA4C,KAAA+oB,QAAA2f,EAAAh+B,GAAAtN,KAAA4C,KACA,UAAA0oC,GAAA5c,EAAA,CACA,OAAAlvB,GAAA,EAAmBA,EAAAkvB,EAAApxB,SAAekC,EAAAkvB,EAAAlvB,IAAAQ,MAAA0uB,EAAAhH,OAAAloB,IAAA,EAClCkvB,GAAApxB,SAAA0C,KAAA4C,KAAA+oB,QAAA,KACA,IAAAgmB,GAAA/lB,GAAA5rB,KAAA4E,GAAA5E,KAAA4C,MAAA5C,KAAA4E,GAAA2c,IAAA9J,SACAiP,IAAA1mB,KAAA4C,KAAAI,KAAAoL,IAAA,EAAApO,KAAA4C,KAAAwT,OAAAgf,GAAAp1B,QACA2xC,GAAAhH,GAAA3qC,KAAA4E,GAAA,GAAA5E,KAAAoW,QACAsP,GAAA1lB,KAAA4E,GAAA0mC,IAAA,MAEAmG,GAAA/gC,UAAAihB,QAAA4f,GAAA,WACA,GAAAyV,GAAAhnD,KAAAoW,MACApW,MAAAoW,OAAA,IACA,IAAAuU,GAAAyK,GAAAp1B,MAAAgnD,CACA,IAAAr8B,EAAA,CACAjE,GAAA1mB,KAAA4C,KAAA5C,KAAA4C,KAAAwT,OAAAuU,EACA,IAAA2gB,GAAAh+B,GAAAtN,KAAA4C,KACA8iB,IAAA1lB,KAAA4E,GAAA0mC,IAAA,KAiCA,IAAA3W,IAAA3vB,EAAA2vB,KAAA,SAAAnyB,EAAAywB,EAAAjN,GACAhmB,KAAAwC,OACA8uC,GAAAtxC,KAAAizB,GACAjzB,KAAAoW,OAAA4P,IAAAhmB,MAAA,EAEAy4C,IAAA9jB,IACAA,GAAAjkB,UAAApD,OAAA,WAAsC,MAAAA,IAAAtN,MA+GtC,IAAAozC,OAA4BD,KAwS5BuC,IAAAhlC,WACAklC,UAAA,WAA2B,MAAA51C,MAAAiH,MAAA3J,QAC3B2pD,YAAA,SAAAvU,EAAA7qC,GACA,OAAArI,GAAAkzC,EAAAzwC,EAAAywC,EAAA7qC,EAAkC5F,EAAAzC,IAAOA,EAAA,CACzC,GAAAoD,GAAA5C,KAAAiH,MAAAzH,EACAQ,MAAAoW,QAAAxT,EAAAwT,OACAy7B,GAAAjvC,GACA2nB,GAAA3nB,EAAA,UAEA5C,KAAAiH,MAAAygB,OAAAgrB,EAAA7qC,IAEAq/C,SAAA,SAAAjgD,GACAA,EAAAygB,OAAAmS,MAAA5yB,KAAA3J,OAAA,GAAAmqB,OAAAznB,KAAAiH,SAEAkgD,YAAA,SAAAzU,EAAAzrC,EAAAmP,GACApW,KAAAoW,UACApW,KAAAiH,MAAAjH,KAAAiH,MAAA9D,MAAA,EAAAuvC,GAAAjrB,OAAAxgB,GAAAwgB,OAAAznB,KAAAiH,MAAA9D,MAAAuvC,GACA,QAAAlzC,GAAA,EAAAyC,EAAAgF,EAAA3J,OAAuC2E,EAAAzC,IAAOA,EAAAyH,EAAAzH,GAAAkvC,OAAA1uC,MAE9ConD,MAAA,SAAA1U,EAAA7qC,EAAA+wB,GACA,OAAA32B,GAAAywC,EAAA7qC,EAA0B5F,EAAAywC,IAAQA,EAClC,GAAA9Z,EAAA54B,KAAAiH,MAAAyrC,IAAA,WAiBAiD,GAAAjlC,WACAklC,UAAA,WAA2B,MAAA51C,MAAAspB,MAC3B29B,YAAA,SAAAvU,EAAA7qC,GACA7H,KAAAspB,MAAAzhB,CACA,QAAArI,GAAA,EAAqBA,EAAAQ,KAAAI,SAAA9C,SAA0BkC,EAAA,CAC/C,GAAAgB,GAAAR,KAAAI,SAAAZ,GAAAy2C,EAAAz1C,EAAAo1C,WACA,IAAAK,EAAAvD,EAAA,CACA,GAAAl4B,GAAAxX,KAAAL,IAAAkF,EAAAouC,EAAAvD,GAAAqK,EAAAv8C,EAAA4V,MAIA,IAHA5V,EAAAymD,YAAAvU,EAAAl4B,GACAxa,KAAAoW,QAAA2mC,EAAAv8C,EAAA4V,OACA6/B,GAAAz7B,IAAyBxa,KAAAI,SAAAsnB,OAAAloB,IAAA,GAA8BgB,EAAAkuC,OAAA,MACvD,IAAA7mC,GAAA2S,GAAA,KACAk4B,GAAA,MACSA,IAAAuD,EAET,GAAAj2C,KAAAspB,KAAAzhB,EAAA,IACA,GAAAZ,KACAjH,MAAAknD,SAAAjgD,GACAjH,KAAAI,UAAA,GAAAs1C,IAAAzuC,IACAjH,KAAAI,SAAA,GAAAsuC,OAAA1uC,OAGAknD,SAAA,SAAAjgD,GACA,OAAAzH,GAAA,EAAAyC,EAAAjC,KAAAI,SAAA9C,OAA+C2E,EAAAzC,IAAOA,EAAAQ,KAAAI,SAAAZ,GAAA0nD,SAAAjgD,IAEtDkgD,YAAA,SAAAzU,EAAAzrC,EAAAmP,GACApW,KAAAspB,MAAAriB,EAAA3J,OACA0C,KAAAoW,SACA,QAAA5W,GAAA,EAAAyC,EAAAjC,KAAAI,SAAA9C,OAA+C2E,EAAAzC,IAAOA,EAAA,CACtD,GAAAgB,GAAAR,KAAAI,SAAAZ,GAAAy2C,EAAAz1C,EAAAo1C,WACA,IAAAK,GAAAvD,EAAA,CAEA,GADAlyC,EAAA2mD,YAAAzU,EAAAzrC,EAAAmP,GACA5V,EAAAyG,OAAAzG,EAAAyG,MAAA3J,OAAA,IACA,KAAAkD,EAAAyG,MAAA3J,OAAA,KACA,GAAA+pD,GAAA7mD,EAAAyG,MAAAygB,OAAAlnB,EAAAyG,MAAA3J,OAAA,OACAgqD,EAAA,GAAA5R,IAAA2R,EACA7mD,GAAA4V,QAAAkxC,EAAAlxC,OACApW,KAAAI,SAAAsnB,OAAAloB,EAAA,IAAA8nD,GACAA,EAAA5Y,OAAA1uC,KAEAA,KAAAunD,aAEA,MAEA7U,GAAAuD,IAGAsR,WAAA,WACA,KAAAvnD,KAAAI,SAAA9C,QAAA,KACA,GAAAmxC,GAAAzuC,IACA,IACA,GAAAqnD,GAAA5Y,EAAAruC,SAAAsnB,OAAA+mB,EAAAruC,SAAA9C,OAAA,KACAkqD,EAAA,GAAA7R,IAAA0R,EACA,IAAA5Y,EAAAC,OAKS,CACTD,EAAAnlB,MAAAk+B,EAAAl+B,KACAmlB,EAAAr4B,QAAAoxC,EAAApxC,MACA,IAAAqxC,GAAA3nD,GAAA2uC,EAAAC,OAAAtuC,SAAAquC,EACAA,GAAAC,OAAAtuC,SAAAsnB,OAAA+/B,EAAA,IAAAD,OATA,CACA,GAAA9yB,GAAA,GAAAihB,IAAAlH,EAAAruC,SACAs0B,GAAAga,OAAAD,EACAA,EAAAruC,UAAAs0B,EAAA8yB,GACA/Y,EAAA/Z,EAOA8yB,EAAA9Y,OAAAD,EAAAC,aACOD,EAAAruC,SAAA9C,OAAA,GACPmxC,GAAAC,OAAA6Y,eAEAH,MAAA,SAAA1U,EAAA7qC,EAAA+wB,GACA,OAAAp5B,GAAA,EAAAyC,EAAAjC,KAAAI,SAAA9C,OAA+C2E,EAAAzC,IAAOA,EAAA,CACtD,GAAAgB,GAAAR,KAAAI,SAAAZ,GAAAy2C,EAAAz1C,EAAAo1C,WACA,IAAAK,EAAAvD,EAAA,CACA,GAAAgV,GAAA1kD,KAAAL,IAAAkF,EAAAouC,EAAAvD,EACA,IAAAlyC,EAAA4mD,MAAA1U,EAAAgV,EAAA9uB,GAAA,QACA,QAAA/wB,GAAA6/C,GAAA,KACAhV,GAAA,MACSA,IAAAuD,IAKT,IAAA0R,IAAA,EACAnmC,GAAAxc,EAAAwc,IAAA,SAAAhf,EAAAsB,EAAAuM,GACA,KAAArQ,eAAAwhB,KAAA,UAAAA,IAAAhf,EAAAsB,EAAAuM,EACA,OAAAA,MAAA,GAEAslC,GAAA58C,KAAAiH,MAAA,GAAA01C,KAAA,GAAA/gB,IAAA,aACA30B,KAAAsgB,MAAAjQ,EACArQ,KAAAyX,UAAAzX,KAAA+oB,WAAA,EACA/oB,KAAA87B,UAAA,EACA97B,KAAAumC,QAAA+P,KACAt2C,KAAA4nD,gBAAA,EACA5nD,KAAAulB,SAAAlV,CACA,IAAAhG,GAAAG,GAAA6F,EAAA,EACArQ,MAAA+f,KAAgB7X,KAAAmC,EAAAlC,GAAAkC,EAAAlQ,KAAAkQ,EAAA+B,OAAA/B,EAAA7M,OAAA,EAAA+gC,QAAA,EAAAmK,WAAA,MAChB1oC,KAAAnH,KAAA8uD,GACA3nD,KAAAklB,WAAAphB,EAEA,gBAAAtB,OAAAy4B,GAAAz4B,IACAqlC,GAAA7nC,MAAqBkI,KAAAmC,EAAAlC,GAAAkC,EAAA7H,QAAmC,MAASrI,KAAAkQ,EAAA+B,OAAA/B,IAGjEmX,IAAA9Q,UAAAuoC,GAAAtD,GAAAjlC,WACA8pC,YAAAh5B,GACA4D,KAAA,SAAAld,EAAAC,EAAAywB,GACAA,EAAA54B,KAAAonD,MAAAl/C,EAAAlI,KAAAsgB,MAAAnY,EAAAD,EAAA0wB,GACA54B,KAAAonD,MAAApnD,KAAAsgB,MAAAtgB,KAAAsgB,MAAAtgB,KAAAspB,KAAAphB,IAGAutC,OAAA,SAAA/C,EAAAzrC,GAEA,OADAmP,GAAA,EACA5W,EAAA,EAAAyC,EAAAgF,EAAA3J,OAAuC2E,EAAAzC,IAAOA,EAAA4W,GAAAnP,EAAAzH,GAAA4W,MAC9CpW,MAAAmnD,YAAAzU,EAAA1yC,KAAAsgB,MAAArZ,EAAAmP,IAEAzV,OAAA,SAAA+xC,EAAA7qC,GAA6B7H,KAAAinD,YAAAvU,EAAA1yC,KAAAsgB,MAAAzY,IAE7B8U,SAAA,SAAAkrC,GACA,GAAA5gD,GAAAivC,GAAAl2C,UAAAsgB,MAAAtgB,KAAAsgB,MAAAtgB,KAAAspB,KACA,OAAAu+B,MAAA,EAAA5gD,EACAA,EAAA5D,KAAAwkD,GAAA,OAEAzK,SAAA,SAAAtZ,GACA,GAAAvuB,GAAA/K,GAAAxK,KAAAsgB,MAAA,GAAA8I,EAAAppB,KAAAsgB,MAAAtgB,KAAAspB,KAAA,CACA4R,IAAAl7B,MAAwBkI,KAAAqN,EAAApN,GAAAqC,GAAA4e,EAAAtd,GAAA9L,KAAAopB,GAAA5mB,KAAAlF,QACxBkF,KAAAy4B,GAAA6I,GAAAv6B,OAAA,aACkBpP,KAAAob,EAAAnJ,OAAAmJ,IAAuB,IAEzC7M,aAAA,SAAAo7B,EAAA57B,EAAAC,EAAAoB,GACArB,EAAAqC,GAAAvK,KAAAkI,GACAC,IAAAoC,GAAAvK,KAAAmI,GAAAD,EACAQ,GAAA1I,KAAA8jC,EAAA57B,EAAAC,EAAAoB,IAEAlB,SAAA,SAAAH,EAAAC,EAAA0/C,GACA,GAAA5gD,GAAA0gC,GAAA3nC,KAAAuK,GAAAvK,KAAAkI,GAAAqC,GAAAvK,KAAAmI,GACA,OAAA0/C,MAAA,EAAA5gD,EACAA,EAAA5D,KAAAwkD,GAAA,OAGA/7C,QAAA,SAAAlJ,GAA6B,GAAAtD,GAAAU,KAAAiO,cAAArL,EAAiC,OAAAtD,MAAAkD,MAC9DslD,QAAA,SAAAllD,EAAAJ,GACA6lC,GAAAroC,KAAA4C,IACA8F,GAAA1I,KAAAwC,EAAAgI,GAAA5H,EAAA,GAAA2H,GAAAvK,KAAAwK,GAAA5H,MAEAmlD,WAAA,SAAAnlD,GACAA,EAAA8F,GAAA1I,KAAA,GAAAuK,GAAAvK,KAAAwK,GAAA5H,EAAA,IAAA2H,GAAAvK,KAAAwK,GAAA5H,KACA8F,GAAA1I,KAAA,GAAAwK,GAAA,KAAAD,GAAAvK,KAAAwK,GAAA,QAGAyD,cAAA,SAAArL,GAAmC,MAAAylC,IAAAroC,KAAA4C,GAAAkJ,GAAA9L,KAAA4C,GAAA,QACnColD,cAAA,SAAAplD,GAAmC,MAAA0K,IAAA1K,IAEnCgd,yBAAA,SAAAhd,GAEA,MADA,gBAAAA,OAAAkJ,GAAA9L,KAAA4C,IACAkoB,GAAA9qB,KAAA4C,IAGAuL,UAAA,WAA2B,MAAAnO,MAAAspB,MAC3BjZ,UAAA,WAA2B,MAAArQ,MAAAsgB,OAC3BhQ,SAAA,WAA0B,MAAAtQ,MAAAsgB,MAAAtgB,KAAAspB,KAAA,GAE1B/e,QAAA,SAAAhC,GAA4B,MAAAgC,IAAAvK,KAAAuI,IAE5BxD,UAAA,SAAAsF,GACA,GAAA9B,GAAAwX,EAAA/f,KAAA+f,GAKA,OAJAxX,GAAA,MAAA8B,GAAA,QAAAA,EAAA0V,EAAA5lB,KACA,UAAAkQ,EAAA0V,EAAA3T,OACA,OAAA/B,QAAA,EAAA0V,EAAA5X,GACA4X,EAAA7X,KACAggC,GAAA3/B,IAEAyC,kBAAA,WAAmC,OAAAlD,GAAA9H,KAAA+f,IAAA5lB,KAAA6F,KAAA+f,IAAA3T,SAEnC67C,UAAAnuB,GAAA,SAAAl3B,EAAAqF,EAAAs2B,GACA,GAAAh2B,GAAAgC,GAAAvK,KAAA,gBAAA4C,GAAA4H,GAAA5H,EAAAqF,GAAA,GAAArF,EACA27B,GAAAvB,GAAAh9B,KAAAuI,GACAmC,GAAA1K,KAAAuI,OAEAmC,aAAAovB,GAAA,SAAA1tB,EAAAjS,EAAA21B,GACAplB,GAAA1K,KAAAuK,GAAAvK,KAAAoM,GAAA7B,GAAAvK,KAAA7F,GAAAiS,GAAA0jB,KAEAkN,gBAAAlD,GAAA,SAAA5xB,EAAAC,EAAA2nB,GACAkN,GAAAh9B,KAAAuK,GAAAvK,KAAAkI,GAAAC,GAAAoC,GAAAvK,KAAAmI,GAAA2nB,KAGApkB,aAAA,SAAAm8C,GAAqC,MAAA7nD,MAAAqI,SAAArI,KAAA+f,IAAA7X,KAAAlI,KAAA+f,IAAA5X,GAAA0/C,IACrCn+C,iBAAA,SAAAo6B,EAAAojB,EAAA39C,GACA2xB,GAAAl7B,MAAwBkI,KAAAlI,KAAA+f,IAAA7X,KAAAC,GAAAnI,KAAA+f,IAAA5X,GAAA3F,KAAAy4B,GAAA6I,GAAAv6B,UAA6E29C,GAAA,WAErGnI,KAAAjlB,GAAA,WAAmC2M,GAAAzmC,KAAA,UACnCg/C,KAAAllB,GAAA,WAAmC2M,GAAAzmC,KAAA,UAEnCkoD,aAAA,SAAAv7C,GAAiC3M,KAAA+f,IAAAwe,OAAA5xB,GAEjCw7C,YAAA,WACA,GAAAzhB,GAAA1mC,KAAAumC,OACA,QAAcwY,KAAArY,EAAAnuB,KAAAjb,OAAA0hD,KAAAtY,EAAAC,OAAArpC,SAEd6wC,aAAA,WAA8BnuC,KAAAumC,QAAA+P,GAAAt2C,KAAAumC,QAAAW,gBAE9BkhB,UAAA,WACApoD,KAAA4nD,gBAAA5nD,KAAA2I,kBAAA,IAEAA,iBAAA,SAAA0/C,GAGA,MAFAA,KACAroD,KAAAumC,QAAAmQ,OAAA12C,KAAAumC,QAAAoQ,WAAA,MACA32C,KAAAumC,QAAAU,YAEAz+B,QAAA,SAAAC,GACA,MAAAzI,MAAAumC,QAAAU,aAAAx+B,GAAAzI,KAAA4nD,kBAGAU,WAAA,WACA,OAAc/vC,KAAA2+B,GAAAl3C,KAAAumC,QAAAhuB,MACdouB,OAAAuQ,GAAAl3C,KAAAumC,QAAAI,UAEA4hB,WAAA,SAAAC,GACA,GAAA9hB,GAAA1mC,KAAAumC,QAAA+P,GAAAt2C,KAAAumC,QAAAW,cACAR,GAAAnuB,KAAAiwC,EAAAjwC,KAAApV,MAAA,GACAujC,EAAAC,OAAA6hB,EAAA7hB,OAAAxjC,MAAA,IAGAqL,SAAA,SAAAtG,EAAAC,EAAA7C,GACA,MAAAkJ,IAAAxO,KAAAuK,GAAAvK,KAAAkI,GAAAqC,GAAAvK,KAAAmI,GAAA7C,EAAA,UAEAmjD,YAAA,SAAAlgD,EAAAjD,GACA,GAAAojD,IAAsB3a,aAAAzoC,IAAA,MAAAA,EAAAivB,SAAAjvB,EAAAyN,OAAAzN,GACtB+pC,WAAA/pC,KAAA+pC,WACAvB,gBAAA,EAEA,OADAvlC,GAAAgC,GAAAvK,KAAAuI,GACAiG,GAAAxO,KAAAuI,IAAAmgD,EAAA,aAEAhrC,YAAA,SAAAnV,GACAA,EAAAgC,GAAAvK,KAAAuI,EACA,IAAA0lB,MAAAxQ,EAAA3R,GAAA9L,KAAAuI,EAAA3F,MAAAqwB,WACA,IAAAxV,EAAA,OAAAje,GAAA,EAAgCA,EAAAie,EAAAngB,SAAkBkC,EAAA,CAClD,GAAAqe,GAAAJ,EAAAje,IACA,MAAAqe,EAAA3V,MAAA2V,EAAA3V,MAAAK,EAAAN,MACA,MAAA4V,EAAA1V,IAAA0V,EAAA1V,IAAAI,EAAAN,KACAgmB,EAAAxwB,KAAAogB,EAAA7B,OAAA0yB,QAAA7wB,EAAA7B,QAEA,MAAAiS,IAEA06B,UAAA,SAAAzgD,EAAAC,GACAD,EAAAqC,GAAAvK,KAAAkI,GAAiCC,EAAAoC,GAAAvK,KAAAmI,EACjC,IAAA+F,MAAAZ,EAAApF,EAAAtF,IAYA,OAXA5C,MAAAolB,KAAAld,EAAAtF,KAAAuF,EAAAvF,KAAA,WAAAA,GACA,GAAA6a,GAAA7a,EAAAqwB,WACA,IAAAxV,EAAA,OAAAje,GAAA,EAAkCA,EAAAie,EAAAngB,OAAkBkC,IAAA,CACpD,GAAAqe,GAAAJ,EAAAje,EACA8N,IAAApF,EAAAtF,MAAAsF,EAAAD,GAAA4V,EAAA1V,IACA,MAAA0V,EAAA3V,MAAAoF,GAAApF,EAAAtF,MACA0K,GAAAnF,EAAAvF,MAAAib,EAAA3V,KAAAC,EAAAF,IACAiG,EAAAzQ,KAAAogB,EAAA7B,OAAA0yB,QAAA7wB,EAAA7B,UAEA1O,IAEAY,GAEA06C,YAAA,WACA,GAAA36B,KAMA,OALAjuB,MAAAolB,KAAA,SAAAxiB,GACA,GAAAsuC,GAAAtuC,EAAAqwB,WACA,IAAAie,EAAA,OAAA1xC,GAAA,EAAgCA,EAAA0xC,EAAA5zC,SAAgBkC,EAChD,MAAA0xC,EAAA1xC,GAAA0I,MAAA+lB,EAAAxwB,KAAAyzC,EAAA1xC,GAAAwc,UAEAiS,GAGA46B,aAAA,SAAArsD,GACA,GAAAyL,GAAAqF,EAAAtN,KAAAsgB,KAOA,OANAtgB,MAAAolB,KAAA,SAAAxiB,GACA,GAAAqzC,GAAArzC,EAAAJ,KAAAlF,OAAA,CACA,OAAA24C,GAAAz5C,GAAuByL,EAAAzL,GAAU,IACjCA,GAAAy5C,QACA3oC,KAEA/C,GAAAvK,KAAAwK,GAAA8C,EAAArF,KAEA6gD,aAAA,SAAAj5B,GACAA,EAAAtlB,GAAAvK,KAAA6vB,EACA,IAAAqjB,GAAArjB,EAAA5nB,EACA,OAAA4nB,GAAAjtB,KAAA5C,KAAAsgB,OAAAuP,EAAA5nB,GAAA,KACAjI,KAAAolB,KAAAplB,KAAAsgB,MAAAuP,EAAAjtB,KAAA,SAAAA,GACAswC,GAAAtwC,EAAAJ,KAAAlF,OAAA,IAEA41C,IAGAxe,KAAA,SAAAq0B,GACA,GAAAxnC,GAAA,GAAAC,IAAA00B,GAAAl2C,UAAAsgB,MAAAtgB,KAAAsgB,MAAAtgB,KAAAspB,MAAAtpB,KAAAklB,WAAAllB,KAAAsgB,MAQA,OAPAiB,GAAA9J,UAAAzX,KAAAyX,UAAqC8J,EAAAwH,WAAA/oB,KAAA+oB,WACrCxH,EAAAxB,KAAiB7X,KAAAlI,KAAA+f,IAAA7X,KAAAC,GAAAnI,KAAA+f,IAAA5X,GAAAhO,KAAA6F,KAAA+f,IAAA5lB,KAAAiS,OAAApM,KAAA+f,IAAA3T,OACjB5O,MAAAwC,KAAA+f,IAAAviB,MAAA+gC,QAAA,EAAAmK,WAAA1oC,KAAA+f,IAAA2oB,YACAqgB,IACAxnC,EAAAglB,QAAAiQ,UAAAx2C,KAAAumC,QAAAiQ,UACAj1B,EAAAgnC,WAAAvoD,KAAAsoD,eAEA/mC,GAGAynC,UAAA,SAAA1jD,GACAA,SACA,IAAA4C,GAAAlI,KAAAsgB,MAAAnY,EAAAnI,KAAAsgB,MAAAtgB,KAAAspB,IACA,OAAAhkB,EAAA4C,MAAA5C,EAAA4C,WAAA5C,EAAA4C,MACA,MAAA5C,EAAA6C,IAAA7C,EAAA6C,SAAA7C,EAAA6C,GACA,IAAAusB,GAAA,GAAAlT,IAAA00B,GAAAl2C,KAAAkI,EAAAC,GAAA7C,EAAAxB,MAAA9D,KAAAklB,WAAAhd,EAIA,OAHA5C,GAAAghC,aAAA5R,EAAA6R,QAAAvmC,KAAAumC,UACAvmC,KAAA2uC,SAAA3uC,KAAA2uC,YAAAlxC,MAAgD8jB,IAAAmT,EAAA4R,WAAAhhC,EAAAghC,aAChD5R,EAAAia,SAAsBptB,IAAAvhB,KAAA4uC,UAAA,EAAAtI,WAAAhhC,EAAAghC,aACtB5R,GAEAu0B,UAAA,SAAA15B,GAEA,GADAA,YAAAvqB,KAAAuqB,IAAAhO,KACAvhB,KAAA2uC,OAAA,OAAAnvC,GAAA,EAAsCA,EAAAQ,KAAA2uC,OAAArxC,SAAwBkC,EAAA,CAC9D,GAAA0pD,GAAAlpD,KAAA2uC,OAAAnvC,EACA,IAAA0pD,EAAA3nC,KAAAgO,EAAA,CACAvvB,KAAA2uC,OAAAjnB,OAAAloB,EAAA,GACA+vB,EAAA05B,UAAAjpD,KACA,QAGA,GAAAuvB,EAAAgX,SAAAvmC,KAAAumC,QAAA,CACA,GAAA4iB,IAAA55B,EAAA12B,GACAwtC,IAAA9W,EAAA,SAAAhO,GAAyC4nC,EAAA1rD,KAAA8jB,EAAA1oB,MAAuB,GAChE02B,EAAAgX,QAAA+P,KACA/mB,EAAAgX,QAAAhuB,KAAA2+B,GAAAl3C,KAAAumC,QAAAhuB,KAAA4wC,GACA55B,EAAAgX,QAAAI,OAAAuQ,GAAAl3C,KAAAumC,QAAAI,OAAAwiB,KAGAC,eAAA,SAAApsD,GAAiCqpC,GAAArmC,KAAAhD,IAEjCqU,QAAA,WAAyB,MAAArR,MAAA8D,MACzBulD,UAAA,WAA2B,MAAArpD,MAAA4E,MAG3B4c,GAAA9Q,UAAA44C,SAAA9nC,GAAA9Q,UAAA0U,IAGA,IAAAmkC,IAAA,oCAAA9mD,MAAA,IACA,QAAA3H,MAAA0mB,IAAA9Q,UAAA8Q,GAAA9Q,UAAArV,eAAAP,KAAAgF,GAAAypD,GAAAzuD,IAAA,IACAkK,EAAA0L,UAAA5V,IAAA,SAAA0uD,GACA,kBAAyB,MAAAA,GAAA3vB,MAAA75B,KAAAuhB,IAAAjd,aACpBkd,GAAA9Q,UAAA5V,KAEL29C,IAAAj3B,IA+SAxc,EAAAw3B,UACAx3B,EAAA83B,oBACA93B,EAAA8yC,oBAgDA,IAAApf,IAAAD,GAAA,CAgCAzzB,GAAAtJ,MAAqBsJ,EAAAxI,OAAsBwI,EAAA6S,SAU3C,IAAAqL,IAAA,GAIAhY,GAAAlG,EAAAkG,MAAgC8hC,SAAA,WAAqB,yBAGrD3rB,IAAA3Q,WAAuB0gB,IAAA,SAAAq4B,EAAAzsD,GAAsBga,aAAAhX,KAAAnH,IAAsBmH,KAAAnH,GAAA6E,WAAAV,EAAAysD,KAenEzkD,EAAAstB,cAEA,IAAAumB,KAAA,IAmDAQ,GAAA,4EAWAE,GAAA,44DAkCAv0C,GAAA0kD,eAAA,SAAA1sD,GAA2C4sB,GAAA5sB,EAK3C,IAAAmiC,IAAA,WAGA,GAAA9K,GAAA,QACA,IAAAs1B,GAAA50C,GAAA,MACA,oBAAA40C,IAAA,YAAAA,KAWAnoB,IACA+S,GAAA,SAAA9sC,EAAAjI,GACA,WAAAiI,EAAAqzB,WAAAt7B,EAAA,QAAAiI,EAAAqzB,WAAAt7B,IAEA4hC,KAAA,0BAAArmC,KAAAiU,UAAAC,WACAslC,GAAA,SAAA9sC,EAAAjI,GACA,8CAAkDzE,KAAA0M,EAAAtE,MAAA3D,EAAA,EAAAA,EAAA,KAElD0iB,IAAA,kCAAAnnB,KAAAiU,UAAAC,WACAslC,GAAA,SAAA9sC,EAAAjI,GACA,GAAAskC,GAAAr8B,EAAAqzB,WAAAt7B,EAAA,EACA,OAAAskC,IAAA,YAAAA,GAEA5hB,KACAqyB,GAAA,SAAA9sC,EAAAjI,GACA,GAAAA,EAAA,OAAAiI,EAAAqzB,WAAAt7B,EAAA,IACA,QAAAzE,KAAA0M,EAAAuE,OAAAxM,EAAA,gBAAAzE,KAAA0M,EAAAuE,OAAAxM,IAAA,QACA,IAAAA,EAAA,aAAAzE,KAAA0M,EAAAuE,OAAAxM,EAAA,eAAAzE,KAAA0M,EAAAuE,OAAAxM,IAAA,SAEA,4HAA6HzE,KAAA0M,EAAAtE,MAAA3D,EAAA,EAAAA,EAAA,KAG7H,IAAA08B,IAUAyd,GAcA1e,GAAA,WAAAx4B,MAAA,MAAAnF,OAAA,SAAAgU,GAEA,IADA,GAAA/I,GAAA,EAAAqxB,KAAAt6B,EAAAgS,EAAAhU,OACAgC,GAAAiJ,GAAA,CACA,GAAAqhD,GAAAt4C,EAAAxR,QAAA,KAAAyI,EACA,KAAAqhD,MAAAt4C,EAAAhU,OACA,IAAAsF,GAAA0O,EAAAnO,MAAAoF,EAAA,MAAA+I,EAAAtF,OAAA49C,EAAA,GAAAA,EAAA,EAAAA,GACAC,EAAAjnD,EAAA9C,QAAA,KACA,KAAA+pD,GACAjwB,EAAAn8B,KAAAmF,EAAAO,MAAA,EAAA0mD,IACAthD,GAAAshD,EAAA,IAEAjwB,EAAAn8B,KAAAmF,GACA2F,EAAAqhD,EAAA,GAGA,MAAAhwB,IACG,SAAAtoB,GAAoB,MAAAA,GAAA7O,MAAA,YACvBuC,GAAAi2B,aAEA,IAAAX,IAAAphC,OAAAwS,aAAA,SAAAo+C,GACA,IAAS,MAAAA,GAAAlsB,gBAAAksB,EAAAjsB,aACT,MAAA57B,GAAc,WACX,SAAA6nD,GACH,IAAS,GAAAh6C,GAAAg6C,EAAAC,cAAAt+C,UAAAu+C,cACT,MAAA/nD,IACA,MAAA6N,MAAAm6C,iBAAAH,EACA,GAAAh6C,EAAAo6C,iBAAA,aAAAp6C,IADA,GAIA4rB,GAAA,WACA,GAAAz5B,GAAA8S,GAAA,MACA,iBAAA9S,IAAA,GACAA,EAAAmD,aAAA,oBACA,kBAAAnD,GAAAkoD,WAKAld,IAAkBmd,EAAA,QAAAC,EAAA,YAAAC,EAAA,MAAAC,GAAA,QAAAC,GAAA,QAAAC,GAAA,OAAAC,GAAA,MAClBC,GAAA,QAAAC,GAAA,WAAAC,GAAA,MAAAC,GAAA,QAAAC,GAAA,SAAAC,GAAA,WAAAC,GAAA,MACAC,GAAA,OAAAC,GAAA,OAAAC,GAAA,KAAAC,GAAA,QAAAC,GAAA,OAAAC,GAAA,YAAAC,GAAA,SACAC,GAAA,SAAAC,GAAA,IAAsCC,GAAA,IAAAC,GAAA,MAAAC,GAAA,MAAAC,GAAA,MAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,SACtCC,IAAA,IAAAC,IAAA,IAAmCC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,IAAAC,IAAA,KACnCC,IAAA,IAAAC,IAAA,IAAAC,MAAA,KAAAC,MAAA,OAAAC,MAAA,OAAAC,MAAA,QAAAC,MAAA,SACAC,MAAA,OAAAC,MAAA,MAAAC,MAAA,SAAAC,MAAA,WAAAC,MAAA,SACAvoD,GAAAioC,YACA,WAEA,OAAAztC,GAAA,EAAmB,GAAAA,EAAQA,IAAAytC,GAAAztC,EAAA,IAAAytC,GAAAztC,EAAA,IAAAiqB,OAAAjqB,EAE3B,QAAAA,GAAA,GAAoB,IAAAA,EAASA,IAAAytC,GAAAztC,GAAAiqB,OAAA2a,aAAA5kC,EAE7B,QAAAA,GAAA,EAAmB,IAAAA,EAASA,IAAAytC,GAAAztC,EAAA,KAAAytC,GAAAztC,EAAA,WAAAA,IAmD5B,IAAA62B,IAsFAggB,GAAA,WAKA,QAAAmX,GAAA1pB,GACA,YAAAA,EAAA2pB,EAAAzhD,OAAA83B,GACAA,GAAA,YAAAA,EAAA,IACAA,GAAA,YAAAA,EAAA4pB,EAAA1hD,OAAA83B,EAAA,MACAA,GAAA,YAAAA,EAAA,IACA,IARA,GAAA2pB,GAAA,mQAEAC,EAAA,mQASAC,EAAA,4CACAC,EAAA,SAAAC,EAAA,QAAAC,EAAA,SAAAC,EAAA,OAEAC,EAAA,GAEA,iBAAAvmD,GACA,IAAAkmD,EAAA5yD,KAAA0M,GAAA,QAEA,QAAA3N,GADAstB,EAAA3f,EAAAnK,OAAA2wD,KACAzuD,EAAA,EAA2B4nB,EAAA5nB,IAASA,EACpCyuD,EAAAxwD,KAAA3D,EAAA0zD,EAAA/lD,EAAAqzB,WAAAt7B,IAMA,QAAAA,GAAA,EAAAwgB,EAAAguC,EAAuC5mC,EAAA5nB,IAASA,EAAA,CAChD,GAAA1F,GAAAm0D,EAAAzuD,EACA,MAAA1F,EAAAm0D,EAAAzuD,GAAAwgB,EACAA,EAAAlmB,EAQA,OAAA0F,GAAA,EAAA2L,EAAA6iD,EAAsC5mC,EAAA5nB,IAASA,EAAA,CAC/C,GAAA1F,GAAAm0D,EAAAzuD,EACA,MAAA1F,GAAA,KAAAqR,EAAA8iD,EAAAzuD,GAAA,IACAquD,EAAA9yD,KAAAjB,KAAuCqR,EAAArR,EAAY,KAAAA,IAAAm0D,EAAAzuD,GAAA,MAMnD,OAAAA,GAAA,EAAAwgB,EAAAiuC,EAAA,GAAsC7mC,EAAA,EAAA5nB,IAAaA,EAAA,CACnD,GAAA1F,GAAAm0D,EAAAzuD,EACA,MAAA1F,GAAA,KAAAkmB,GAAA,KAAAiuC,EAAAzuD,EAAA,GAAAyuD,EAAAzuD,GAAA,IACA,KAAA1F,GAAAkmB,GAAAiuC,EAAAzuD,EAAA,IACA,KAAAwgB,GAAA,KAAAA,IAAAiuC,EAAAzuD,GAAAwgB,GACAA,EAAAlmB,EAOA,OAAA0F,GAAA,EAAqB4nB,EAAA5nB,IAASA,EAAA,CAC9B,GAAA1F,GAAAm0D,EAAAzuD,EACA,SAAA1F,EAAAm0D,EAAAzuD,GAAA,QACA,SAAA1F,EAAA,CACA,OAAAwQ,GAAA9K,EAAA,EAA+B4nB,EAAA9c,GAAA,KAAA2jD,EAAA3jD,KAAgCA,GAE/D,OADAqH,GAAAnS,GAAA,KAAAyuD,EAAAzuD,EAAA,IAAA4nB,EAAA9c,GAAA,KAAA2jD,EAAA3jD,GAAA,QACAsT,EAAApe,EAAyB8K,EAAAsT,IAASA,EAAAqwC,EAAArwC,GAAAjM,CAClCnS,GAAA8K,EAAA,GAOA,OAAA9K,GAAA,EAAA2L,EAAA6iD,EAAsC5mC,EAAA5nB,IAASA,EAAA,CAC/C,GAAA1F,GAAAm0D,EAAAzuD,EACA,MAAA2L,GAAA,KAAArR,EAAAm0D,EAAAzuD,GAAA,IACAquD,EAAA9yD,KAAAjB,KAAAqR,EAAArR,GASA,OAAA0F,GAAA,EAAqB4nB,EAAA5nB,IAASA,EAC9B,GAAAouD,EAAA7yD,KAAAkzD,EAAAzuD,IAAA,CACA,OAAA8K,GAAA9K,EAAA,EAA+B4nB,EAAA9c,GAAAsjD,EAAA7yD,KAAAkzD,EAAA3jD,MAAyCA,GAIxE,OAHAwwC,GAAA,MAAAt7C,EAAAyuD,EAAAzuD,EAAA,GAAAwuD,GACA3mB,EAAA,MAAAjgB,EAAA9c,EAAA2jD,EAAA3jD,GAAA0jD,GACAr8C,EAAAmpC,GAAAzT,EAAA,QACAzpB,EAAApe,EAAyB8K,EAAAsT,IAASA,EAAAqwC,EAAArwC,GAAAjM,CAClCnS,GAAA8K,EAAA,EAUA,OADAiG,GAAAylB,KACAx2B,EAAA,EAAqB4nB,EAAA5nB,GACrB,GAAAsuD,EAAA/yD,KAAAkzD,EAAAzuD,IAAA,CACA,GAAA6K,GAAA7K,CACA,OAAAA,EAAmB4nB,EAAA5nB,GAAAsuD,EAAA/yD,KAAAkzD,EAAAzuD,MAAwCA,GAC3Dw2B,EAAAv4B,MAAsByK,KAAAmC,EAAAlC,GAAA3I,EAAAy2B,MAAA,QACb,CACT,GAAA1tB,GAAA/I,EAAAkzC,EAAA1c,EAAA14B,MACA,OAAAkC,EAAmB4nB,EAAA5nB,GAAA,KAAAyuD,EAAAzuD,KAA4BA,GAC/C,OAAAoe,GAAArV,EAA2B/I,EAAAoe,GAC3B,GAAAmwC,EAAAhzD,KAAAkzD,EAAArwC,IAAA,CACAA,EAAArV,GAAAytB,EAAAtO,OAAAgrB,EAAA,GAAgDxqC,KAAAK,EAAAJ,GAAAyV,EAAAqY,MAAA,GAChD,IAAAi4B,GAAAtwC,CACA,OAAAA,EAAuBpe,EAAAoe,GAAAmwC,EAAAhzD,KAAAkzD,EAAArwC,MAAqCA,GAC5DoY,EAAAtO,OAAAgrB,EAAA,GAAmCxqC,KAAAgmD,EAAA/lD,GAAAyV,EAAAqY,MAAA,IACnC1tB,EAAAqV,QACaA,CAEbpe,GAAA+I,GAAAytB,EAAAtO,OAAAgrB,EAAA,GAA4CxqC,KAAAK,EAAAJ,GAAA3I,EAAAy2B,MAAA,IAc5C,MAXA,IAAAD,EAAA,GAAAC,QAAA1lB,EAAA9I,EAAAzM,MAAA,WACAg7B,EAAA,GAAA9tB,KAAAqI,EAAA,GAAAjT,OACA04B,EAAAm4B,SAAuBjmD,KAAA,EAAAC,GAAAoI,EAAA,GAAAjT,OAAA24B,MAAA,KAEvB,GAAAiP,GAAAlP,GAAAC,QAAA1lB,EAAA9I,EAAAzM,MAAA,WACAkqC,GAAAlP,GAAA7tB,IAAAoI,EAAA,GAAAjT,OACA04B,EAAAv4B,MAAoByK,KAAAkf,EAAA7W,EAAA,GAAAjT,OAAA6K,GAAAif,EAAA6O,MAAA,KAEpBD,EAAA,GAAAC,OAAAiP,GAAAlP,GAAAC,OACAD,EAAAv4B,MAAoByK,KAAAkf,EAAAjf,GAAAif,EAAA6O,MAAAD,EAAA,GAAAC,QAEpBD,KAQA,OAFAhxB,GAAAopD,QAAA,SAEAppD,M9BwtDM,W+B/pPNA,WAAA04C,WAAA,sBAAA2Q,EAAAC,GAwDA,QAAAC,GAAAxvC,GAEA,IADA,GAAApM,GAAA67C,GAAA,EAAAC,GAAA,EACA,OAAA97C,EAAAoM,EAAApM,SAAA,CACA,IAAA67C,EAAA,CACA,QAAA77C,IAAA87C,EAAA,MACA,MAAA97C,EAAA87C,GAAA,EACAA,GAAA,KAAA97C,IAAA87C,GAAA,GAEAD,MAAA,MAAA77C,GAOA,QAAA+7C,GAAAC,EAAA/zD,EAAAg0D,GAEA,MADA90D,IAAA60D,EAAc10C,GAAA20C,EACdh0D,EAEA,QAAAi0D,GAAA9vC,EAAAjW,GACA,GAAAb,GAAA8W,EAAApM,MACA,SAAA1K,GAAA,KAAAA,EAEA,MADAa,GAAAgmD,SAAAC,EAAA9mD,GACAa,EAAAgmD,SAAA/vC,EAAAjW,EACK,SAAAb,GAAA8W,EAAA/jB,MAAA,0BACL,MAAA0zD,GAAA,kBACK,SAAAzmD,GAAA8W,EAAA/jB,MAAA,MACL,MAAA0zD,GAAA,gBACK,yBAAwB3zD,KAAAkN,GAC7B,MAAAymD,GAAAzmD,EACK,SAAAA,GAAA8W,EAAAqnC,IAAA,KACL,MAAAsI,GAAA,gBACK,SAAAzmD,GAAA8W,EAAAqnC,IAAA,MAEL,MADArnC,GAAAsnC,SAAA,YACAqI,EAAA,kBACK,SAAA3zD,KAAAkN,GAEL,MADA8W,GAAA/jB,MAAA,oCACA0zD,EAAA,kBACK,SAAAzmD,EACL,MAAA8W,GAAAqnC,IAAA,MACAt9C,EAAAgmD,SAAAE,EACAA,EAAAjwC,EAAAjW,IACOiW,EAAAqnC,IAAA,MACPrnC,EAAAI,YACAuvC,EAAA,sBACO,YAAA5lD,EAAAmmD,UAAA,aAAAnmD,EAAAmmD,UACP,OAAAnmD,EAAAmmD,UAAA,gBAAqDl0D,KAAA+N,EAAAmmD,WACrDV,EAAAxvC,GACAA,EAAAsnC,SAAA,UACAqI,EAAA,uBAEA3vC,EAAAsnC,SAAA6I,IACAR,EAAA,sBAAA3vC,EAAA87B,WAEK,SAAA5yC,EAEL,MADAa,GAAAgmD,SAAAK,EACAA,EAAApwC,EAAAjW,EACK,SAAAb,EAEL,MADA8W,GAAAI,YACAuvC,EAAA,gBACK,IAAAQ,GAAAn0D,KAAAkN,GAEL,MADA8W,GAAAsnC,SAAA6I,IACAR,EAAA,sBAAA3vC,EAAA87B,UAEA97B,GAAAsnC,SAAA,UACA,IAAAx2C,GAAAkP,EAAA87B,UAAAuU,EAAAp+C,GAAAgR,qBAAAnS,IAAAmB,GAAAnB,EACA,OAAAu/C,IAAA,KAAAtmD,EAAAmmD,SAAAP,EAAAU,EAAAt1D,KAAAs1D,EAAAx0D,MAAAiV,GACA6+C,EAAA,sBAAA7+C,GAIA,QAAAk/C,GAAAM,GACA,gBAAAtwC,EAAAjW,GACA,GAAA6J,GAAA67C,GAAA,CACA,IAAAc,IAAA,KAAAvwC,EAAAonC,QAAApnC,EAAA/jB,MAAAu0D,IAEA,MADAzmD,GAAAgmD,SAAAD,EACAH,EAAA,wBAEA,aAAA/7C,EAAAoM,EAAApM,UACAA,GAAA08C,GAAAb,IACAA,MAAA,MAAA77C,CAGA,OADA67C,KAAA1lD,EAAAgmD,SAAAD,GACAH,EAAA,oBAIA,QAAAM,GAAAjwC,EAAAjW,GAEA,IADA,GAAAb,GAAAunD,GAAA,EACAvnD,EAAA8W,EAAApM,QAAA,CACA,QAAA1K,GAAAunD,EAAA,CACA1mD,EAAAgmD,SAAAD,CACA,OAEAW,EAAA,KAAAvnD,EAEA,MAAAymD,GAAA,qBAGA,QAAAS,GAAApwC,EAAAjW,GAEA,IADA,GAAA6J,GAAA67C,GAAA,EACA,OAAA77C,EAAAoM,EAAApM,SAAA,CACA,IAAA67C,IAAA,KAAA77C,GAAA,KAAAA,GAAAoM,EAAAqnC,IAAA,MAAkE,CAClEt9C,EAAAgmD,SAAAD,CACA,OAEAL,MAAA,MAAA77C,EAEA,MAAA+7C,GAAA,mBAAA3vC,EAAA87B,WAWA,QAAA4U,GAAA1wC,EAAAjW,GACAA,EAAA4mD,aAAA5mD,EAAA4mD,WAAA,KACA,IAAAC,GAAA5wC,EAAAzN,OAAAxR,QAAA,KAAAif,EAAA1U,MACA,QAAAslD,GAAA,CAGA,OADAC,GAAA,EAAAC,GAAA,EACAtnD,EAAAonD,EAAA,EAA6BpnD,GAAA,IAAUA,EAAA,CACvC,GAAAN,GAAA8W,EAAAzN,OAAAtF,OAAAzD,GACAunD,EAAAC,GAAAjwD,QAAAmI,EACA,IAAA6nD,GAAA,KAAAA,EAAA,CACA,IAAAF,EAAA,GAAqBrnD,CAAO,OAC5B,QAAAqnD,EAAA,UACO,IAAAE,GAAA,KAAAA,IACPF,MACO,YAAA70D,KAAAkN,GACP4nD,GAAA,MACO,IAAAA,IAAAD,EAAA,GACPrnD,CACA,QAGAsnD,IAAAD,IAAA9mD,EAAA4mD,WAAAnnD,IAOA,QAAAynD,GAAA39B,EAAAm0B,EAAA1sD,EAAAm2D,EAAAjwC,EAAA2+B,GACA3+C,KAAAqyB,WACAryB,KAAAwmD,SACAxmD,KAAAlG,OACAkG,KAAAggB,OACAhgB,KAAA2+C,OACA,MAAAsR,IAAAjwD,KAAAiwD,SAGA,QAAAC,GAAApnD,EAAAqnD,GACA,OAAA19C,GAAA3J,EAAA4J,UAAiCD,EAAGA,IAAAE,KACpC,GAAAF,EAAArU,MAAA+xD,EAAA,QACA,QAAAC,GAAAtnD,EAAAhN,QAAgCs0D,EAAIA,IAAApwC,KACpC,OAAAvN,GAAA29C,EAAAC,KAA2B59C,EAAGA,IAAAE,KAC9B,GAAAF,EAAArU,MAAA+xD,EAAA,SAIA,QAAAG,GAAAxnD,EAAAlO,EAAAd,EAAAmgB,EAAA8E,GACA,GAAAwxC,GAAAznD,EAAAynD,EAQA,KALAH,GAAAtnD,QAAqBsnD,GAAArxC,SAAoBqxC,GAAAl1C,OAAA,KAAAk1C,GAAAG,KAEzCznD,EAAA0nD,QAAAn1D,eAAA,WACAyN,EAAA0nD,QAAAP,OAAA,KAEA,CACA,GAAAQ,GAAAF,EAAAjzD,OAAAizD,EAAAziD,MAAA4iD,GAAAC,EAAAC,CACA,IAAAH,EAAA32D,EAAAmgB,GAAA,CACA,KAAAs2C,EAAAjzD,QAAAizD,IAAAjzD,OAAA,GAAAuzD,KACAN,EAAAziD,OACA,OAAAsiD,IAAAl1C,OAAAk1C,GAAAl1C,OACA,YAAAphB,GAAAo2D,EAAApnD,EAAAmR,GAAA,aACArf,IAQA,QAAAk2D,KACA,OAAAtxD,GAAA8E,UAAAhH,OAAA,EAAsCkC,GAAA,EAAQA,IAAA4wD,GAAAG,GAAA9yD,KAAA6G,UAAA9E,IAE9C,QAAAovD,KAEA,MADAkC,GAAAj3B,MAAA,KAAAv1B,YACA,EAEA,QAAAysD,GAAAZ,GACA,QAAAa,GAAA/gD,GACA,OAAAwC,GAAAxC,EAAwBwC,EAAGA,IAAAE,KAC3B,GAAAF,EAAArU,MAAA+xD,EAAA,QACA,UAEA,GAAArnD,GAAAsnD,GAAAtnD,KACA,IAAAA,EAAAhN,QAAA,CAEA,GADAs0D,GAAAl1C,OAAA,MACA81C,EAAAloD,EAAA4J,WAAA,MACA5J,GAAA4J,WAAyBtU,KAAA+xD,EAAAx9C,KAAA7J,EAAA4J,eACpB,CACL,GAAAs+C,EAAAloD,EAAA8J,YAAA,MACA07C,GAAA17C,aACA9J,EAAA8J,YAA4BxU,KAAA+xD,EAAAx9C,KAAA7J,EAAA8J,cAO5B,QAAAq+C,KACAb,GAAAtnD,MAAAhN,SAAwBkkB,KAAAowC,GAAAtnD,MAAAhN,QAAAu0D,KAAAD,GAAAtnD,MAAA4J,WACxB09C,GAAAtnD,MAAA4J,UAAAw+C,GAEA,QAAAC,KACAf,GAAAtnD,MAAA4J,UAAA09C,GAAAtnD,MAAAhN,QAAAu0D,KACAD,GAAAtnD,MAAAhN,QAAAs0D,GAAAtnD,MAAAhN,QAAAkkB,KAEA,QAAAoxC,GAAAt3D,EAAA6kD,GACA,GAAA/kB,GAAA,WACA,GAAA9wB,GAAAsnD,GAAAtnD,MAAAhG,EAAAgG,EAAAupB,QACA,SAAAvpB,EAAA0nD,QAAA12D,OAAAgJ,EAAAgG,EAAA0nD,QAAAn+B,UACAvpB,EAAA0nD,QAAA,GAAAR,GAAAltD,EAAAstD,GAAArxC,OAAAynC,SAAA1sD,EAAA,KAAAgP,EAAA0nD,QAAA7R,GAGA,OADA/kB,GAAAi3B,KAAA,EACAj3B,EAEA,QAAAy3B,KACA,GAAAvoD,GAAAsnD,GAAAtnD,KACAA,GAAA0nD,QAAAxwC,OACA,KAAAlX,EAAA0nD,QAAA12D,OACAgP,EAAAupB,SAAAvpB,EAAA0nD,QAAAn+B,UACAvpB,EAAA0nD,QAAA1nD,EAAA0nD,QAAAxwC,MAKA,QAAAsxC,GAAAC,GACA,gBAAAz3D,GACA,MAAAA,IAAAy3D,EAAA3C,IACA,KAAA2C,EAA2BT,IAC3BlC,EAAAtqD,UAAAktD,SAIA,QAAAZ,GAAA92D,EAAAyL,GACA,aAAAzL,EAAA80D,EAAAwC,EAAA,SAAA7rD,EAAAjI,QAAAm0D,EAAAH,EAAA,KAAqFD,GACrF,aAAAv3D,EAAA80D,EAAAwC,EAAA,QAAAT,EAAAC,EAAAS,GACA,aAAAv3D,EAAA80D,EAAAwC,EAAA,QAAAR,EAAAS,GACA,KAAAv3D,EAAkB80D,EAAAwC,EAAA,KAAyBM,EAAAL,GAC3C,KAAAv3D,EAAkB80D,IAClB,MAAA90D,EAAA80D,EAAAwC,EAAA,QAAAT,EAAAC,EAAAS,EAAAM,GACA,YAAA73D,EAAA80D,EAAAgD,GACA,OAAA93D,EAAA80D,EAAAwC,EAAA,QAAAS,EAAAjB,EAAAS,GACA,YAAAv3D,EAAA80D,EAAAwC,EAAA,QAAAU,GACA,UAAAh4D,EAAA80D,EAAAwC,EAAA,QAAAT,EAAAS,EAAA,IAA6E,UAAAE,EAAA,KAC7EI,EAAAL,KACA,QAAAv3D,EAAA80D,EAAA+B,EAAAW,EAAA,MACA,WAAAx3D,EAAA80D,EAAA0C,EAAA,MACA,SAAAx3D,EAAA80D,EAAAwC,EAAA,QAAAH,EAAAK,EAAA,KAAAS,GAAAT,EAAA,KACAV,EAAAS,EAAAF,GACA,UAAAr3D,EAAA80D,EAAAwC,EAAA,QAAAH,EAAAe,GAAAb,EAAAE,GACA,SAAAv3D,EAAA80D,EAAAwC,EAAA,QAAA3iD,GAAAwjD,GAAAZ,GACA,UAAAv3D,EAAA80D,EAAAwC,EAAA,QAAAc,GAAAb,GACA,UAAAv3D,EAAA80D,EAAAwC,EAAA,QAAAe,GAAAd,GACAP,EAAAM,EAAA,QAAAT,EAAAW,EAAA,KAAsDD,GAEtD,QAAAV,GAAA72D,GACA,MAAAs4D,GAAAt4D,GAAA,GAEA,QAAAu4D,GAAAv4D,GACA,MAAAs4D,GAAAt4D,GAAA,GAEA,QAAAs4D,GAAAt4D,EAAAw4D,GACA,GAAAlC,GAAAtnD,MAAA4mD,YAAAU,GAAArxC,OAAA1U,MAAA,CACA,GAAA3P,GAAA43D,EAAAC,EAAAC,CACA,SAAA14D,EAAA,MAAA80D,GAAAqC,EAAAG,EAAA,KAAAqB,EAAAhM,EAAA,KAAA4K,EAAAC,EAAA,MAAA52D,EAAAy2D,EACA,gBAAAr3D,EAAA,MAAAg3D,GAAAG,EAAAxK,EAAA6K,EAAA,MAAA52D,EAAAy2D,GAGA,GAAAuB,GAAAJ,EAAAK,EAAAC,CACA,OAAAC,IAAAx3D,eAAAvB,GAAA80D,EAAA8D,GACA,YAAA54D,EAAA80D,EAAAgD,GACA,aAAA93D,EAAA80D,EAAA0D,EAAAQ,EAAAC,GACA,KAAAj5D,EAAA80D,EAAAwC,EAAA,KAAA2B,EAAAC,GAAA1B,EAAA,KAAAD,EAAAqB,GACA,YAAA54D,GAAA,UAAAA,EAAA80D,EAAA0D,EAAAD,EAAA1B,GACA,KAAA72D,EAAA80D,EAAAwC,EAAA,KAAA6B,GAAA5B,EAAAqB,GACA,KAAA54D,EAAkBo5D,EAAAC,EAAA,IAAkC,KAAAT,GACpD9D,IAEA,QAAAmE,GAAAj5D,GACA,MAAAA,GAAAkB,MAAA,cAAwB81D,IACxBA,EAAAH,GAEA,QAAAmC,GAAAh5D,GACA,MAAAA,GAAAkB,MAAA,cAAwB81D,IACxBA,EAAAuB,GAGA,QAAAO,GAAA94D,EAAAyL,GACA,WAAAzL,EAAA80D,EAAA+B,GACAgC,EAAA74D,EAAAyL,GAAA,GAEA,QAAAotD,GAAA74D,EAAAyL,EAAA+sD,GACA,GAAA7jB,GAAA,GAAA6jB,EAAAM,EAAAD,EACAS,EAAA,GAAAd,EAAA3B,EAAA0B,CACA,aAAA9sD,EAAAqpD,EAAAqC,EAAAqB,EAAAC,EAAAC,EAAArB,GACA,YAAAr3D,EACA,UAAAiB,KAAAwK,GAAAqpD,EAAAngB,GACA,KAAAlpC,EAAAqpD,EAAA+B,EAAAW,EAAA,KAAA8B,GACAxE,EAAAwE,GAEA,SAAAt5D,GAA0Bs2D,GAAAG,GAAA9yD,KAAAgxC,GAAgB4kB,EAAA9tD,IAC1C,KAAAzL,EACA,KAAAA,EAAAo5D,EAAAb,EAAA,WAAA5jB,GACA,KAAA30C,EAAA80D,EAAA0E,EAAA7kB,GACA,KAAA30C,EAAA80D,EAAAwC,EAAA,KAAA2B,EAAAzB,EAAA,KAAAD,EAAA5iB,GAAA,OAHA,OAKA,QAAA4kB,GAAA9tD,GACA,YAAAA,EAAApC,MAAAoC,EAAAjI,OAAA,GAA4CsxD,IAC5CA,EAAA+B,EAAA4C,GAEA,QAAAA,GAAAz5D,GACA,WAAAA,GACAs2D,GAAAl1C,OAAA,WACAk1C,GAAAtnD,MAAAgmD,SAAAK,EACAP,KAHA,OAMA,QAAA4D,GAAA14D,GAEA,MADA21D,GAAAW,GAAArxC,OAAAqxC,GAAAtnD,OACkBgoD,EAAlB,KAAAh3D,EAAkB82D,EAClBD,GAEA,QAAA4B,GAAAz4D,GAEA,MADA21D,GAAAW,GAAArxC,OAAAqxC,GAAAtnD,OACkBgoD,EAAlB,KAAAh3D,EAAkB82D,EAClByB,GAEA,QAAAP,GAAAh4D,GACA,WAAAA,EAAA80D,EAAAyC,EAAAT,GACAE,EAAA8B,EAAAtB,EAAA,KAA6CD,GAE7C,QAAAiC,GAAAx5D,GACA,kBAAAA,GAA6Bs2D,GAAAl1C,OAAA,WAAuB0zC,KAApD,OAEA,QAAAuE,GAAAr5D,EAAAyL,GACA,eAAAzL,GAEA,GADAs2D,GAAAl1C,OAAA,WACA,OAAA3V,GAAA,OAAAA,EAAA,MAAAqpD,GAAA4E,OACK,cAAA15D,GAAA,UAAAA,EACLs2D,GAAAl1C,OAAAo0C,GAAA,WAAAx1D,EAAA,gBACK,SAAAA,EACL,MAAA80D,GAAA+B,EAAAW,EAAA,KAAAmC,EAEA,OAAAZ,IAAAx3D,eAAAvB,GAAA80D,EAAA6E,GAAA,OAEA,QAAAD,GAAA15D,GACA,kBAAAA,EAAAg3D,EAAA2C,IACArD,GAAAl1C,OAAA,WACA0zC,EAAAgD,IAEA,QAAA6B,GAAA35D,GACA,WAAAA,EAAA80D,EAAAyD,GACA,KAAAv4D,EAAAg3D,EAAAc,GAAA,OAEA,QAAAa,GAAAiB,EAAAppD,GACA,QAAAqpD,GAAA75D,GACA,QAAAA,EAAA,CACA,GAAA+2D,GAAAT,GAAAtnD,MAAA0nD,OAEA,OADA,QAAAK,EAAAlS,OAAAkS,EAAAtoD,KAAAsoD,EAAAtoD,KAAA,MACAqmD,EAAA8E,EAAAC,GAEA,MAAA75D,IAAAwQ,EAAAskD,IACAA,EAAA0C,EAAAhnD,IAEA,gBAAAxQ,GACA,MAAAA,IAAAwQ,EAAAskD,IACAkC,EAAA4C,EAAAC,IAGA,QAAAT,GAAAQ,EAAAppD,EAAAq0C,GACA,OAAAn/C,GAAA,EAAmBA,EAAA8E,UAAAhH,OAAsBkC,IACzC4wD,GAAAG,GAAA9yD,KAAA6G,UAAA9E,GACA,OAAAovD,GAAAwC,EAAA9mD,EAAAq0C,GAAA8T,EAAAiB,EAAAppD,GAAA+mD,GAEA,QAAAK,GAAA53D,GACA,WAAAA,EAAkB80D,IAClBkC,EAAAF,EAAAc,GAEA,QAAAkC,GAAA95D,GACA,MAAA+5D,KAAA,KAAA/5D,EAAA80D,EAAAkF,GAAA,OAEA,QAAAA,GAAAh6D,GACA,kBAAAA,GAA4Bs2D,GAAAl1C,OAAA,aAAyB0zC,KAArD,OAEA,QAAA6C,KACA,MAAAX,GAAArK,EAAAmN,EAAAG,EAAAC,GAEA,QAAAvN,GAAA3sD,EAAAyL,GACA,kBAAAzL,GAA6Bi3D,EAAAxrD,GAAiBqpD,KAC9C,KAAA90D,EAAAo5D,EAAAzM,EAAA,KACA,KAAA3sD,EAAkBo5D,EAAAe,EAAA,KAAlB,OAEA,QAAAA,GAAAn6D,EAAAyL,GACA,kBAAAzL,GAAAs2D,GAAArxC,OAAA/jB,MAAA,aAIA,YAAAlB,IAAAs2D,GAAAl1C,OAAA,YACA0zC,EAAA0C,EAAA,KAAA7K,EAAAsN,KAJAhD,EAAAxrD,GACAqpD,EAAAmF,IAKA,QAAAA,GAAAG,EAAA3uD,GACA,WAAAA,EAAAqpD,EAAAyD,GAAA,OAEA,QAAA2B,GAAAl6D,GACA,WAAAA,EAAA80D,EAAA6C,GAAA,OAEA,QAAAE,GAAA73D,EAAAyL,GACA,mBAAAzL,GAAA,QAAAyL,EAAAqpD,EAAAwC,EAAA,QAAAR,EAAAS,GAAA,OAEA,QAAAQ,GAAA/3D,GACA,WAAAA,EAAA80D,EAAAwC,EAAA,KAAA+C,EAAA7C,EAAA,KAAAD,GAAA,OAEA,QAAA8C,GAAAr6D,GACA,aAAAA,EAAA80D,EAAA6C,EAAAH,EAAA,KAAoD8C,GACpD,KAAAt6D,EAAkB80D,EAAAwF,GAClB,YAAAt6D,EAAA80D,EAAAyF,GACAvD,EAAAH,EAAAW,EAAA,KAAqC8C,GAErC,QAAAC,GAAAH,EAAA3uD,GACA,YAAAA,GAAA,MAAAA,GAAyC6qD,GAAAl1C,OAAA,UAAuB0zC,EAAA+B,IAChE/B,EAAAgE,EAAAwB,GAEA,QAAAA,GAAAt6D,EAAAyL,GACA,WAAAzL,EAAkB80D,EAAA0F,GAClB,MAAA/uD,GAAA,MAAAA,GAAyC6qD,GAAAl1C,OAAA,UAAuB0zC,EAAA+B,IAChEG,EAAAH,EAAAW,EAAA,KAAqCgD,GAErC,QAAAA,GAAAx6D,GACA,KAAAA,GAAA80D,EAAA+B,GAEA,QAAAiB,GAAA93D,EAAAyL,GACA,WAAAA,GAAuB6qD,GAAAl1C,OAAA,UAAsB0zC,EAAAgD,IAC7C,YAAA93D,GAA6Bi3D,EAAAxrD,GAAgBqpD,EAAAgD,IAC7C,KAAA93D,EAAA80D,EAAAqC,EAAAG,EAAA,KAAAqB,EAAAV,GAAA,KAAAV,EAAAT,EAAAO,GAAA,OAEA,QAAAY,IAAAj4D,GACA,gBAAAA,EAAA80D,EAAAmD,IACAjB,EAAArK,EAAAmN,GAEA,QAAAnlD,IAAA3U,EAAAyL,GACA,kBAAAzL,GAA6Bi3D,EAAAxrD,GAAgBqpD,EAAA2F,KAA7C,OAEA,QAAAA,IAAAL,EAAA3uD,GACA,iBAAAA,EAAAqpD,EAAA+B,GAAA,OAEA,QAAAsB,IAAAn4D,GACA,WAAAA,EAAkBo5D,EAAAC,EAAA,KAAlB,OAEA,QAAAnB,IAAAl4D,EAAAyL,GACA,gBAAAzL,EAAA80D,EAAAgC,GACA,YAAA92D,GAA6Bi3D,EAAAxrD,GAAiBqpD,EAAA4F,KAA9C,OAEA,QAAAtC,IAAAgC,EAAA3uD,GACA,WAAAA,GAAuB6qD,GAAAl1C,OAAA,UAAuB0zC,EAAA4F,GAAAlD,EAAA,OAC9C,WAAA/rD,GAA6B6qD,GAAAl1C,OAAA,UAAuB0zC,EAAA+B,EAAAW,EAAA,OACpDR,EAAAF,GAEA,QAAAuB,IAAAr4D,GACA,gBAAAA,EAAA80D,IACAkC,EAAA2D,GAAAD,IAEA,QAAAC,IAAA36D,EAAAyL,GACA,WAAAzL,EAAkBo5D,EAAAuB,GAAA,MAClB,YAAA36D,GAAAi3D,EAAAxrD,GACAqpD,KAEA,QAAA4F,IAAAN,EAAA3uD,GACA,cAAAA,GAA0B6qD,GAAAl1C,OAAA,UAAuB0zC,EAAA+B,IAAjD,OAEA,QAAAsC,IAAAn5D,GACA,WAAAA,EAAA80D,IACAkC,EAAAuB,EAAAqC,IAEA,QAAAA,IAAA56D,GACA,aAAAA,EAAAg3D,EAAAkC,GAAA1B,EAAA,MACA,KAAAx3D,EAAA80D,EAAA6D,EAAAJ,EAAA,MACAvB,EAAA2B,EAAAJ,EAAA,MAEA,QAAAW,IAAAl5D,GACA,aAAAA,EAAA80D,EAAAiD,EAAAmB,IACA,MAAAl5D,EAAA80D,EAAA+B,EAAAqC,IAAA,OA1iBA,GAqEAl5D,IAAAmgB,GArEAgxB,GAAAojB,EAAApjB,WACA0pB,GAAArG,EAAAqG,gBACArF,GAAAhB,EAAAsG,OACAlE,GAAApC,EAAAuG,MAAAvF,GACAuE,GAAAvF,EAAAwG,WAIA9jD,GAAA,WACA,QAAA+jD,GAAAj7D,GAAuB,OAAQA,OAAAc,MAAA,WAC/B,GAAAo6D,GAAAD,EAAA,aAAAE,EAAAF,EAAA,aAAAG,EAAAH,EAAA,aACAI,EAAAJ,EAAA,YAAAK,GAA2Ct7D,KAAA,OAAAc,MAAA,QAE3Cy6D,GACAC,KAAAP,EAAA,MAAAQ,QAAAP,EAAAQ,OAAAR,EAAAS,OAAAR,EAAAS,KAAAT,EAAAU,MAAAV,EAAAW,UAAAX,EACAY,SAAAX,EAAAY,QAAAZ,EAAAa,WAAAb,EAAAc,MAAAd,EAAAe,SAAAf,EAAAgB,QAAAhB,EAAAiB,WAAAjB,EACAkB,MAAArB,EAAA,OAAAsB,QAAAtB,EAAA,OAAAuB,IAAAvB,EAAA,OACAwB,WAAAxB,EAAA,YAAAyB,QAAAzB,EAAA,SACA0B,MAAA1B,EAAA,OAAA2B,SAAA3B,EAAA,UAAA4B,OAAA5B,EAAA,QAAA6B,UAAA7B,EAAA,WACA8B,KAAA1B,EAAAtrD,SAAAsrD,EAAA2B,aAAA3B,EACA4B,OAAA3B,EAAA4B,QAAA5B,EAAA6B,OAAA7B,EAAAv6D,UAAAu6D,EAAAnvB,IAAAmvB,EAAA1qC,SAAA0qC,EACAp1D,OAAA+0D,EAAA,QAAAn8D,OAAAm8D,EAAA,UAAAmC,QAAAnC,EAAA,SAAAoC,QAAApC,EAAA,QACAqC,QAAAlC,EAAAmC,SAAAtC,EAAA,UAAAuC,SAAAvC,EAAA,UAAAwC,UAAArC,EAIA,IAAArB,GAAA,CACA,GAAA/5D,IAAkBA,KAAA,WAAAc,MAAA,cAClB48D,GAEAC,YAAA1C,EAAA,aACAwC,UAAAxC,EAAA,WACAva,YAAAua,EAAA,eAGA2C,SAAA3C,EAAA,UACA4C,UAAA5C,EAAA,WACA6C,YAAA7C,EAAA,aACA8C,SAAA9C,EAAA,UAGAzjD,OAAAxX,EAAAg+D,OAAAh+D,EAAAi+D,KAAAj+D,EAAAk+D,IAAAl+D,EAGA,QAAAm+D,KAAAT,GACAnC,EAAA4C,GAAAT,EAAAS,GAIA,MAAA5C,MAGAnG,GAAA,mBACAK,GAAA,wFAiHAQ,GAAA,SAkCA8C,IAAqBuC,MAAA,EAAA0C,QAAA,EAAAI,UAAA,EAAA5mD,QAAA,EAAA6mD,QAAA,EAAAn4D,QAAA,EAAAo4D,kBAAA,GA2CrBhI,IAAYtnD,MAAA,KAAA09C,OAAA,KAAAtrC,OAAA,KAAAq1C,GAAA,MA4BZW,IAAqB9yD,KAAA,OAAAuU,MAAqBvU,KAAA,aAgS1C,OAtQAizD,GAAAR,KAAA,GAuQA1/B,WAAA,SAAAknC,GACA,GAAAvvD,IACAgmD,SAAAD,EACAI,SAAA,MACAsB,MACAC,QAAA,GAAAR,IAAAqI,GAAA,GAAAptB,GAAA,cACAv4B,UAAA47C,EAAA57C,UACA5W,QAAAwyD,EAAA57C,YAA4C29C,KAAA/B,EAAA57C,WAC5C2f,SAAA,EAGA,OADAi8B,GAAA17C,aAAA9J,EAAA8J,WAAA07C,EAAA17C,YACA9J,GAGAoI,MAAA,SAAA6N,EAAAjW,GAOA,GANAiW,EAAAmnC,QACAp9C,EAAA0nD,QAAAn1D,eAAA,WACAyN,EAAA0nD,QAAAP,OAAA,GACAnnD,EAAAupB,SAAAtT,EAAAgsB,cACA0kB,EAAA1wC,EAAAjW,IAEAA,EAAAgmD,UAAAE,GAAAjwC,EAAAunC,WAAA,WACA,IAAA1rD,GAAAkO,EAAAgmD,SAAA/vC,EAAAjW,EACA,kBAAAhP,GAAAc,GACAkO,EAAAmmD,SAAA,YAAAn1D,IAAA,MAAAmgB,IAAA,MAAAA,GAAAngB,GAAA,SACAw2D,EAAAxnD,EAAAlO,EAAAd,GAAAmgB,GAAA8E,KAGAjc,OAAA,SAAAgG,EAAAwvD,GACA,GAAAxvD,EAAAgmD,UAAAE,EAAA,MAAAhqD,YAAAkG,IACA,IAAApC,EAAAgmD,UAAAD,EAAA,QAGA,QAFA0J,GAAAD,KAAAtsD,OAAA,GAAAwkD,EAAA1nD,EAAA0nD,QAEAhxD,EAAAsJ,EAAAynD,GAAAjzD,OAAA,EAAuCkC,GAAA,IAAQA,EAAA,CAC/C,GAAAg5D,GAAA1vD,EAAAynD,GAAA/wD,EACA,IAAAg5D,GAAAnH,EAAAb,IAAAxwC,SACA,IAAAw4C,GAAA7G,EAAA,MAEA,QAAAnB,EAAA12D,MAAA,KAAAy+D,IAAmD/H,IAAAxwC,MACnD20C,IAAA,KAAAnE,EAAA12D,MAAA,QAAA02D,EAAAxwC,KAAAlmB,OACA02D,IAAAxwC,KACA,IAAAlmB,GAAA02D,EAAA12D,KAAA2+D,EAAAF,GAAAz+D,CAEA,iBAAAA,EAAA02D,EAAAn+B,UAAA,YAAAvpB,EAAAmmD,UAAA,KAAAnmD,EAAAmmD,SAAAuB,EAAA7R,KAAA,KACA,QAAA7kD,GAAA,KAAAy+D,EAAgD/H,EAAAn+B,SAChD,QAAAv4B,EAAA02D,EAAAn+B,SAAA4Y,GACA,QAAAnxC,EACA02D,EAAAn+B,UAAA,YAAAvpB,EAAAmmD,UAAA,KAAAnmD,EAAAmmD,SAAA0F,IAAA1pB,GAAA,GACA,UAAAulB,EAAA7R,MAAA8Z,GAAA,GAAAnK,EAAAoK,mBAEAlI,EAAAP,MAAAO,EAAAhK,QAAAiS,EAAA,KACAjI,EAAAn+B,UAAAomC,EAAA,EAAAxtB,IAFAulB,EAAAn+B,UAAA,sBAAAt3B,KAAAu9D,GAAArtB,GAAA,EAAAA,KAKA9P,cAAA,MACAw9B,kBAAAjI,GAAA,UACAkI,gBAAAlI,GAAA,UACAmI,YAAAnI,GAAA,UACAoI,KAAA,QAEA7d,WAAAyV,GAAA,oBACApB,cACAoB,eAIA1rD,WAAA44C,WAAA,gCACA54C,WAAA44C,WAAA,gCACA54C,WAAA44C,WAAA,uCACA54C,WAAA44C,WAAA,uCACA54C,WAAA44C,WAAA,oBAA2Cx/C,KAAA,aAAAy2D,MAAA,IAC3C7vD,WAAA44C,WAAA,sBAA6Cx/C,KAAA,aAAAy2D,MAAA,IAC7C7vD,WAAA44C,WAAA,uBAA8Cx/C,KAAA,aAAAw2D,QAAA,IAC9C5vD,WAAA44C,WAAA,mBAA0Cx/C,KAAA,aAAA02D,YAAA,IAC1C9vD,WAAA44C,WAAA,0BAAiDx/C,KAAA,aAAA02D,YAAA,K/BwqP3C,SAASl8D,GgCryQfA,EAAAD,QAAA,2hBhC4yQM,SAASC,GiC5yQfA,EAAAD,QAAA,+qFjCmzQM,SAASC,GkCnzQfA,EAAAD,QAAA;ElC0zQM,SAASC,GmC1zQfA,EAAAD,QAAA,64BnCi0QM,SAASC,EAAQD,EAASH,GoCj0QhCI,EAAAD,QAAAH,EAAA,IAAAA,EAAA,4gDAAAA,EAAA,o7EpC00QM,SAASI,EAAQD,EAASH,GqC10QhCI,EAAAD,QAAA,mIAAAH,EAAA,yJAAAA,EAAA,mKAAAA,EAAA,gKAAAA,EAAA,6BrCi1QM,SAASI,EAAQD,EAASH,GsCj1QhCI,EAAAD,QAAA,uGAAAH,EAAA,+JAAAA,EAAA,6BtCw1QM,SAASI,IuCl1Qf,SAAAmgE,EAAAC,GAGApgE,EAAAD,QAAAqgE,KAQAh5D,KAAA,WACA,YAUA,SAAAi5D,GAAAzf,EAAA1+C,GACA,GACA+M,GADA0M,EAAAjb,SAAAO,cAAA2/C,GAAA,MAGA,KAAA3xC,IAAA/M,GAAAyZ,EAAA1M,GAAA/M,EAAA+M,EACA,OAAA0M,GAMA,QAAA2kD,GAAAxqB,GACA,OAAAlvC,GAAA,EAAAqI,EAAAvD,UAAAhH,OAAqCuK,EAAArI,EAAKA,IAC1CkvC,EAAAz0C,YAAAqK,UAAA9E,GAEA,OAAAkvC,GAiBA,QAAAyqB,GAAAC,EAAApyD,EAAAxH,EAAAyH,GACA,GAAA7I,IAAA,UAAA4I,KAAA,IAAAoyD,GAAA55D,EAAAyH,GAAA5D,KAAA,KACAgH,EAAA,IAAA7K,EAAAyH,EAAA,IACAoyD,EAAAr2D,KAAAoL,IAAA,KAAAgrD,GAAApyD,GAAA,IAAAqD,GAAA+uD,GACArvD,EAAAuvD,EAAA5+B,UAAA,EAAA4+B,EAAAx5D,QAAA,cAAAvE,cACAyyB,EAAAjkB,GAAA,IAAAA,EAAA,OAeA,OAbAwvD,GAAAn7D,KACAo7D,EAAAC,WACA,IAAAzrC,EAAA,aAAA5vB,EAAA,eACYi7D,EAAA,IACZhvD,EAAA,aAAmB+uD,EAAA,KACnB/uD,EAAA,qBACAA,EAAArD,GAAA,iBAAiCoyD,EAAA,iBACnBC,EAAA,KACJG,EAAAE,SAAAp8D,QAEVi8D,EAAAn7D,GAAA,GAGAA,EAMA,QAAAi8C,GAAA9lC,EAAAzZ,GACA,GACAU,GACAgE,EAFAm6D,EAAAplD,EAAA3Z,KAKA,KADAE,IAAAkR,OAAA,GAAAyI,cAAA3Z,EAAAqI,MAAA,GACA3D,EAAA,EAAYA,EAAAo6D,EAAAt8D,OAAmBkC,IAE/B,GADAhE,EAAAo+D,EAAAp6D,GAAA1E,EACAD,SAAA8+D,EAAAn+D,GAAA,MAAAA,EAEA,OAAAX,UAAA8+D,EAAA7+D,KAAA,OAMA,QAAA++D,GAAAtlD,EAAAzZ,GACA,OAAA+M,KAAA/M,GACAyZ,EAAA3Z,MAAAy/C,EAAA9lC,EAAA1M,OAAA/M,EAAA+M,EAEA,OAAA0M,GAMA,QAAAulD,GAAA9nD,GACA,OAAAxS,GAAA,EAAiBA,EAAA8E,UAAAhH,OAAsBkC,IAAA,CACvC,GAAAu6D,GAAAz1D,UAAA9E,EACA,QAAAqI,KAAAkyD,GACAl/D,SAAAmX,EAAAnK,KAAAmK,EAAAnK,GAAAkyD,EAAAlyD,IAEA,MAAAmK,GAMA,QAAAzJ,GAAAgM,GAEA,IADA,GAAAk+B,IAAahc,EAAAliB,EAAA0X,WAAAyK,EAAAniB,EAAA+E,WACb/E,IAAAylD,cACAvnB,EAAAhc,GAAAliB,EAAA0X,WAAAwmB,EAAA/b,GAAAniB,EAAA+E,SAEA,OAAAm5B,GAMA,QAAAwnB,GAAAtzD,EAAAuzD,GACA,sBAAAvzD,OAAAuzD,EAAAvzD,EAAArJ,QA0BA,QAAAoJ,GAAA+rC,GACA,yBAAAzyC,MAAA,GAAA0G,GAAA+rC,QACAzyC,KAAAm6D,KAAAL,EAAArnB,MAA6B/rC,EAAAyZ,aAwH7B,QAAAi6C,KAGA,QAAAC,GAAA7gB,EAAAye,GACA,MAAAgB,GAAA,IAAAzf,EAAA,2DAAAye,GAIAuB,EAAAc,QAAA,0CAEA5zD,EAAAgK,UAAAzJ,MAAA,SAAAsN,EAAAk+B,GAIA,QAAA8nB,KACA,MAAAV,GACAQ,EAAA,SACAG,UAAAb,EAAA,IAAAA,EACAc,aAAA3nC,EAAA,KAAAA,KAEW/rB,MAAA4yD,EAAAvjD,OAAAujD,IAQX,QAAAe,GAAAl7D,EAAAkiC,EAAAyF,GACA+xB,EAAAj5B,EACAi5B,EAAAW,EAAAU,KAA0BI,SAAA,IAAAloB,EAAAxrC,MAAAzH,EAAA,MAAA8L,OAAAo2B,IAC1Bw3B,EAAAW,EAAAQ,EAAA,aAAsCO,QAAAnoB,EAAAooB,WACtC9zD,MAAA+rB,EACA1c,OAAAq8B,EAAA1rC,MACAuE,KAAAmnC,EAAA3rC,OACAyO,KAAAk9B,EAAA1rC,OAAA,EACAogC,WAEAkzB,EAAA,QAA2B1zD,MAAAszD,EAAAxnB,EAAA9rC,MAAAnH,GAAA+a,QAAAk4B,EAAAl4B,UAC3B8/C,EAAA,UAA6B9/C,QAAA,OA5B7B,GAeA/a,GAfAszB,EAAA2f,EAAAn1C,OAAAm1C,EAAA1rC,MACA4yD,EAAA,EAAA7mC,EAYAqG,EAAA,IAAAsZ,EAAA1rC,MAAA0rC,EAAAn1C,QAAA,KACA2iC,EAAA45B,EAAAU,KAA0BrgD,SAAA,WAAA3E,IAAA4jB,EAAA7tB,KAAA6tB,GAoB1B,IAAAsZ,EAAA7rC,OACA,IAAApH,EAAA,EAAmBA,GAAAizC,EAAAxrC,MAAczH,IACjCk7D,EAAAl7D,EAAA,yFAEA,KAAAA,EAAA,EAAiBA,GAAAizC,EAAAxrC,MAAczH,IAAAk7D,EAAAl7D,EAC/B,OAAA05D,GAAA3kD,EAAA0rB,IAGAv5B,EAAAgK,UAAA6J,QAAA,SAAAhG,EAAA/U,EAAAmN,EAAA8lC,GACA,GAAA+lB,GAAAjkD,EAAAuD,UACA26B,KAAA7rC,QAAA6rC,EAAAxrC,OAAA,EACAuxD,GAAAh5D,EAAAizC,EAAA+lB,EAAAn4D,WAAA/C,SACAk7D,IAAAn4D,WAAAb,EAAAizC,GAA8B+lB,OAAA1gD,WAAuB0gD,OAAA1gD,WACrD0gD,MAAAj+C,QAAA5N,KAlUA,GAEA2sD,GAFAM,GAAA,yBACAL,KA4BAC,EAAA,WACA,GAAAjlD,GAAA0kD,EAAA,SAAgCn/D,KAAA,YAEhC,OADAo/D,GAAA5/D,SAAAc,qBAAA,WAAAma,GACAA,EAAAilD,OAAAjlD,EAAAxa,cAyFAomB,GACAlZ,MAAA,GACA3J,OAAA,EACAyJ,MAAA,EACAD,OAAA,GACAg0D,OAAA,EACAD,QAAA,EACAl0D,MAAA,OACAo0D,UAAA,EACAC,MAAA,EACAh0D,MAAA,IACAuT,QAAA,IACA0gD,IAAA,GACA53C,OAAA,IACA5U,UAAA,UACA8G,IAAA,OACAjK,KAAA,OACA4O,SAAA,WAUAxT,GAAAyZ,YAEA25C,EAAApzD,EAAAgK,WAOAxJ,KAAA,SAAAhF,GACAlC,KAAAsH,MAEA,IAIA4zD,GACAvM,EALAwM,EAAAn7D,KACAyyC,EAAA0oB,EAAAhB,KACA5lD,EAAA4mD,EAAA5mD,GAAAslD,EAAAZ,EAAA,GAA0CxqD,UAAAgkC,EAAAhkC,aAA2ByL,SAAAu4B,EAAAv4B,SAAAnT,MAAA,EAAAsc,OAAAovB,EAAApvB,SACrE03B,EAAAtI,EAAA3rC,OAAA2rC,EAAAn1C,OAAAm1C,EAAA1rC,KAiBA,IAbA7E,IACAA,EAAA0rB,aAAArZ,EAAArS,EAAA4V,YAAA,MACA62C,EAAApmD,EAAArG,GACAg5D,EAAA3yD,EAAAgM,GACAslD,EAAAtlD,GACAjJ,MAAA,QAAAmnC,EAAAnnC,KAAAqjD,EAAAl4B,EAAAykC,EAAAzkC,GAAAv0B,EAAA0T,aAAA,GAAAtT,SAAAmwC,EAAAnnC,KAAA,IAAAyvC,GAAA,KACAxlC,KAAA,QAAAk9B,EAAAl9B,IAAAo5C,EAAAj4B,EAAAwkC,EAAAxkC,GAAAx0B,EAAA8T,cAAA,GAAA1T,SAAAmwC,EAAAl9B,IAAA,IAAAwlC,GAAA,QAIAxmC,EAAAnP,aAAA,sBACA+1D,EAAAl0D,MAAAsN,EAAA4mD,EAAAhB,OAEAb,EAAA,CAEA,GAEAF,GAFA55D,EAAA,EACA6K,GAAAooC,EAAAxrC,MAAA,MAAAwrC,EAAAsoB,WAAA,EAEAE,EAAAxoB,EAAAwoB,IACAj+D,EAAAi+D,EAAAxoB,EAAAuoB,MACAI,GAAA,EAAA3oB,EAAAl4B,UAAAvd,EAAAy1C,EAAAzrC,MAAA,KACAq0D,EAAAr+D,EAAAy1C,EAAAxrC,OAES,QAAAq0D,KACT97D,GACA,QAAAoe,GAAA,EAAyBA,EAAA60B,EAAAxrC,MAAa2W,IACtCw7C,EAAAp2D,KAAAoL,IAAA,GAAA5O,GAAAizC,EAAAxrC,MAAA2W,GAAAy9C,GAAAr+D,EAAAo+D,EAAA3oB,EAAAl4B,SAEA4gD,EAAA5gD,QAAAhG,EAAAqJ,EAAA60B,EAAAsoB,UAAA1wD,EAAA+uD,EAAA3mB,EAEA0oB,GAAAhgD,QAAAggD,EAAA5mD,IAAA7W,WAAA49D,KAAA,IAAAL,OAGA,MAAAE,IAMA7zD,KAAA,WACA,GAAAiN,GAAAvU,KAAAuU,EAMA,OALAA,KACAyC,aAAAhX,KAAAmb,SACA5G,EAAA5Q,YAAA4Q,EAAA5Q,WAAAtJ,YAAAka,GACAvU,KAAAuU,GAAA1Z,QAEAmF,MAOAiH,MAAA,SAAAsN,EAAAk+B,GAKA,QAAA8oB,GAAA50D,EAAAC,GACA,MAAAizD,GAAAZ,KACA/+C,SAAA,WACAnT,MAAA0rC,EAAAn1C,OAAAm1C,EAAA1rC,MAAA,KACAqP,OAAAq8B,EAAA1rC,MAAA,KACAtN,WAAAkN,EACA60D,UAAA50D,EACA60D,gBAAA,OACAC,UAAA,iBAAAjpB,EAAAxrC,MAAAzH,EAAAizC,EAAAqoB,QAAA,kBAAAroB,EAAA3rC,OAAA,QACA60D,cAAAlpB,EAAAooB,QAAApoB,EAAA1rC,OAAA,UAIA,IAjBA,GAEA2zD,GAFAl7D,EAAA,EACA6K,GAAAooC,EAAAxrC,MAAA,MAAAwrC,EAAAsoB,WAAA,EAgBYv7D,EAAAizC,EAAAxrC,MAAazH,IACzBk7D,EAAAb,EAAAZ,KACA/+C,SAAA,WACA3E,IAAA,IAAAk9B,EAAA1rC,MAAA,QACA20D,UAAAjpB,EAAA5rC,QAAA,wBACA0T,QAAAk4B,EAAAl4B,QACAqhD,UAAAtC,GAAAH,EAAA1mB,EAAAl4B,QAAAk4B,EAAAzrC,MAAAqD,EAAA7K,EAAAizC,EAAAsoB,UAAAtoB,EAAAxrC,OAAA,MAAAwrC,EAAAuoB,MAAA,sBAGAvoB,EAAA7rC,QAAAsyD,EAAAwB,EAAAb,EAAA0B,EAAA,wBAAuEhmD,IAAA,SACvE2jD,EAAA3kD,EAAA2kD,EAAAwB,EAAAa,EAAAtB,EAAAxnB,EAAA9rC,MAAAnH,GAAA,2BAEA,OAAA+U,IAOAgG,QAAA,SAAAhG,EAAA/U,EAAAmN,GACAnN,EAAA+U,EAAAlU,WAAA/C,SAAAiX,EAAAlU,WAAAb,GAAA5E,MAAA2f,QAAA5N,KAqEA,IAAAkvD,GAAAhC,EAAAZ,EAAA,UAAsC6C,SAAA,qBAKtC,QAHAzhB,EAAAwhB,EAAA,cAAAA,EAAAE,IAAA3B,IACAd,EAAAjf,EAAAwhB,EAAA,aAEAn1D,KvCi2QM,SAAS9N,EAAQD,EAASH,GwChsRhCA,EAAA,GAEAA,EAAA,MxC2sRM,SAASI,EAAQD,EAASH,GyC7sRhCA,EAAA,GAEAA,EAAA,MzCwtRM,SAASI,EAAQD,EAASH,G0C1tRhCA,EAAA,GAEAA,EAAA,M1CquRM,SAASI,EAAQD,EAASH,G2CvuRhCA,EAAA,GAEAA,EAAA,M3CkvRM,SAASI,EAAQD,EAASH,G4CpvRhCA,EAAA,GAEAA,EAAA,M5C+vRM,SAASI,EAAQD,EAASH,I6ClwRhC,SAAAA,EAAAW,EAAA6iE,IAAA,SAAA7iE,GACA,YAeA,SAAA8iE,GAAA12D,GACA,OACA22D,cAAA,EACAC,YAAA,EACA52D,QACA62D,UAAA,GAKA,QAAAC,KACA,YAAAr5D,KAAAuW,MAAA,IAAAvW,KAAAs5D,UAAA,OAAA79B,EAAA,MAMA,QAAA89B,GAAAC,GACA,sBAAAA,gBAAAC,GAEA,QAAAC,GAAAjqD,GACA,MAAA8pD,GAAA9pD,GACA,eACAA,GAEA,QAAAkqD,GAAAC,GACA,GAAAr3D,GAAA,GAAAk3D,GAAAG,EACA,MAAA58D,eAAA28D,IACA,MAAAp3D,EACA,UAAAs3D,WAAA,2BAsBA,QAAAJ,GAAAG,GACA,GAAAp4D,GAAA63D,GACAS,GAAA98D,KAAA+8D,GAA+Cx3D,MAAAvF,OAC/C88D,EAAA98D,KAAAg9D,GAAmDz3D,MAAAf,IACnDs4D,EAAA98D,KAAAi9D,GAAsD13D,MAAAq3D,IACtDM,EAAAl9D,MACAm9D,EAAA34D,GAAAxE,KAaA,QAAA9E,GAAAkD,GACA,MAAAm+D,GAAAn+D,GACAA,EAAA4+D,GACA5+D,EAEA,QAAAg/D,GAAAC,GAGA,OAFAC,MACAC,EAAAC,EAAAH,GACA79D,EAAA,EAAmBA,EAAA+9D,EAAAjgE,OAAkBkC,IAAA,CACrC,GAAApB,GAAAm/D,EAAA/9D,EACA29D,GAAA/+D,IACAk/D,EAAA7/D,KAAAW,GAEA,MAAAk/D,GAEA,QAAAG,GAAAJ,EAAAj/D,GACA,MAAAs/D,GAAAL,EAAAniE,EAAAkD,IAEA,QAAAu/D,GAAAN,GAGA,OAFAC,MACAC,EAAAC,EAAAH,GACA79D,EAAA,EAAmBA,EAAA+9D,EAAAjgE,OAAkBkC,IAAA,CACrC,GAAAg9D,GAAAW,EAAAI,EAAA/9D,GACAg9D,IACAc,EAAA7/D,KAAA++D,GAEA,MAAAc,GAEA,QAAAjiE,GAAA+C,GACA,MAAAw/D,GAAA7kE,KAAAiH,KAAA9E,EAAAkD,IAEA,QAAA6M,GAAA7M,GACA,MAAAjF,GAAA0kE,SAAA1kE,EAAA0kE,QAAAv4D,QAAAlH,GAEA,QAAA3C,GAAA4hE,EAAAj/D,EAAAmH,GACA,GAAAu4D,GACAC,CAQA,OAPAxB,GAAAn+D,KACA0/D,EAAA1/D,EACAA,IAAA4+D,IAEAK,EAAAj/D,GAAAmH,EACAu4D,IAAAC,EAAAL,EAAAL,EAAAj/D,KACA0+D,EAAAO,EAAAj/D,GAAqC+9D,YAAA,IACrC52D,EAEA,QAAAy4D,GAAAX,EAAAj/D,EAAA6/D,GAQA,MAPA1B,GAAAn+D,KACA6/D,EAAA9B,aACA8B,EAAAC,EAAAD,GAA0C9B,YAAa52D,OAAA,MAEvDnH,IAAA4+D,IAEAF,EAAAO,EAAAj/D,EAAA6/D,GACAZ,EAEA,QAAAc,GAAA1tD,GAMA,QAAA2tD,GAAA9yD,EAAAC,GACA,MAAAD,KAAAC,EACA,IAAAD,GAAA,EAAAA,IAAA,EAAAC,EACAD,OAAAC,MAGA,QAAA8yD,GAAAn8D,EAAA/E,GACA,GACAlE,GADAigD,EAAAskB,EAAArgE,GAEAG,EAAA47C,EAAA57C,MACA,KAAArE,EAAA,EAAiBqE,EAAArE,EAAYA,IAC7BiJ,EAAAg3C,EAAAjgD,IAAAkE,EAAA+7C,EAAAjgD,GAEA,OAAAiJ,GAGA,QAAAo8D,GAAAp8D,EAAA/E,GACA,GACAlE,GACAglE,EAFA/kB,EAAAskB,EAAArgE,GAGAG,EAAA47C,EAAA57C,MACA,KAAArE,EAAA,EAAiBqE,EAAArE,EAAYA,IAC7BglE,EAAAP,EAAAvgE,EAAA+7C,EAAAjgD,IACA6jE,EAAA56D,EAAAg3C,EAAAjgD,GAAAglE,EAEA,OAAA/7D,GA9BA46D,EAAArsD,EAAA,kBAA+ClL,MAAAy4D,IAC/ClB,EAAArsD,EAAA,uBAAoDlL,MAAA63D,IACpDN,EAAArsD,EAAA,4BAAyDlL,MAAAk4D,IACzDX,EAAArsD,EAAAC,UAAA,kBAAyDnL,MAAAlK,IACzDoV,EAAAktD,wBAMAb,EAAArsD,EAAA,KAAA+4C,EAAA4U,IAUAtB,EAAArsD,EAAA,SAAA+4C,EAAA6U,IAYAvB,EAAArsD,EAAA,QAAA+4C,EAAA8U,IAEA,QAAAC,GAAAlB,GACA,OAAA79D,GAAA,EAAmBA,EAAA8E,UAAAhH,OAAsBkC,IAEzC,OADA+9D,GAAAC,EAAAl5D,UAAA9E,IACAoe,EAAA,EAAqBA,EAAA2/C,EAAAjgE,OAAkBsgB,KACvC,SAAAvc,EAAAjD,GACA0+D,EAAAO,EAAAj/D,GACAw3B,IAAA,WACA,MAAAv0B,GAAAjD,IAEA+9D,YAAA,KAES73D,UAAA9E,GAAA+9D,EAAA3/C,GAGT,OAAAy/C,GAEA,QAAAmB,GAAAj5D,GACA,SAAAA,EACA,KAAAk5D,IACA,OAAAC,GAAAn5D,GAEA,QAAAo5D,KAGA,OAFArB,MACA7uC,EAAA,EACAjvB,EAAA,EAAmBA,EAAA8E,UAAAhH,OAAsBkC,IAEzC,OADAo/D,GAAAJ,EAAAl6D,UAAA9E,IACAoe,EAAA,EAAqBA,EAAAghD,EAAAthE,OAA0BsgB,IAC/C0/C,EAAA7uC,KAAAmwC,EAAAhhD,EAGA,OAAA0/C,GAEA,QAAAuB,GAAAxB,EAAAj/D,GACA,YAAAi/D,GAAA,CACA,GAAAzjC,GAAA8jC,EAAAL,EAAAj/D,EACA,IAAAw7B,EACA,MAAAA,EACAyjC,GAAAyB,EAAAzB,GAEA,MAAAxiE,QAEA,QAAAkkE,GAAAC,EAAA5gE,GACA,GAAA6gE,GAAAH,EAAAE,EACA,KAAAC,EACA,KAAAR,GAAA,gBACA,OAAAI,GAAAI,EAAA7gE,GAEA,QAAA8gE,GAAA/D,EAAA6D,EAAA5gE,EAAA2F,GACA,GAAAk6D,GAAAc,EAAAC,EAAA5gE,EACA,IAAA6/D,EAAA,CACA,YAAAA,GACA,MAAAA,GAAA14D,MAAAs0B,MAAAshC,EAAAp3D,EACA,IAAAk6D,EAAAroC,IACA,MAAAqoC,GAAAroC,IAAA78B,KAAAoiE,GAAAthC,MAAAshC,EAAAp3D,GAEA,KAAA06D,GAAA,wBAAArgE,EAAA,MAEA,QAAA+gE,GAAAhE,EAAA6D,EAAA5gE,GACA,GAAA6/D,GAAAc,EAAAC,EAAA5gE,EACA,IAAA6/D,EAAA,CACA,GAAAA,EAAAroC,IACA,MAAAqoC,GAAAroC,IAAA78B,KAAAoiE,EACA,aAAA8C,GACA,MAAAA,GAAA14D,MAEA,MAAA1K,QAEA,QAAAukE,GAAAjE,EAAA6D,EAAA5gE,EAAAmH,GACA,GAAA04D,GAAAc,EAAAC,EAAA5gE,EACA,IAAA6/D,KAAA7sC,IAEA,WADA6sC,GAAA7sC,IAAAr4B,KAAAoiE,EAAA51D,EAGA,MAAAk5D,GAAA,wBAAArgE,EAAA,MAEA,QAAAihE,GAAAhC,GAIA,OAFAj/D,GADAkhE,KAEA/B,EAAAC,EAAAH,GACA79D,EAAA,EAAmBA,EAAA+9D,EAAAjgE,OAAkBkC,IAAA,CACrC,GAAApB,GAAAm/D,EAAA/9D,EACA8/D,GAAAlhE,GAAAs/D,EAAAL,EAAAj/D,GAEA,MAAAkhE,GAEA,QAAAC,GAAA7mB,EAAA2kB,EAAAmC,EAAAC,GAkBA,MAjBA3C,GAAAO,EAAA,eACA93D,MAAAmzC,EACAwjB,cAAA,EACAC,YAAA,EACAC,UAAA,IAEA93D,UAAAhH,OAAA,GACA,kBAAAmiE,KACA/mB,EAAAgnB,UAAAD,GACA/mB,EAAAhoC,UAAAwtD,EAAAyB,EAAAF,GAAAJ,EAAAhC,KAEA3kB,EAAAhoC,UAAA2sD,EAEAP,EAAApkB,EAAA,aACAwjB,cAAA,EACAE,UAAA,IAEAwD,EAAAlnB,EAAA2mB,EAAAG,IAEA,QAAAG,GAAAF,GACA,qBAAAA,GAAA,CACA,GAAA/uD,GAAA+uD,EAAA/uD,SACA,IAAAguD,EAAAhuD,QAAA,OAAAA,EACA,MAAA+uD,GAAA/uD,UAEA,UAAA+uD,EACA,WACA,UAAA5C,WAEA,QAAAgD,GAAA1E,EAAA6D,EAAAj7D,GACA,OAAA+6D,EAAAE,IACAE,EAAA/D,EAAA6D,EAAA,cAAAj7D,GAOA,QAAA+7D,GAAAzC,GACA,MAAAW,GAAAX,EAAAV,EAAAoD,SAAA9D,EAAA,WACA,MAAAj8D,SAGA,QAAAggE,KACAhgE,KAAA8I,MAAA,EACA9I,KAAAigE,OAAAC,EACAlgE,KAAAmgE,gBAAAtlE,OACAmF,KAAAogE,mBAAAvlE,OACAmF,KAAAqgE,KAAAxlE,OACAmF,KAAA6jC,YAAAhpC,OACAmF,KAAAsgE,aA2BA,QAAAC,GAAAC,EAAAC,EAAAC,GACA,gBAAAjqC,GACA,OAAA+pC,EAAAP,QACA,IAAAU,GACA,SAAAtiE,OAAA,IAAAqiE,EAAA,2BACA,KAAAE,IACA,SAAAviE,OAAA,IAAAqiE,EAAA,wBACA,KAAAR,GACA,aAAAQ,EAEA,KADAF,GAAAP,OAAAW,GACAnqC,CAEA,IAAA57B,SAAA47B,EACA,KAAAgoC,GAAA,kCACA,KAAAoC,IACAL,EAAAP,OAAAU,EACAH,EAAAE,SACAF,EAAAH,KAAA5pC,CACA,IAAAlxB,GAAAk7D,EAAAD,GACAjoD,EAAAhT,IAAAi7D,CAIA,OAHAjoD,KACAhT,EAAAi7D,EAAA38B,aACA28B,EAAAP,OAAA1nD,EAAAqoD,GAAAC,IAEAt7D,QACAgT,UAKA,QAAAuoD,GAAAC,EAAA5F,GACA,GAAAsF,GAAAO,EAAAD,EAAA5F,GACAqF,EAAA,GAAAR,EACA,OAAAF,IACAntD,KAAA4tD,EAAAC,EAAAC,EAAA,QACAvK,QAAAqK,EAAAC,EAAAC,EAAA,WAGA,QAAAQ,KACAjB,EAAAjnE,KAAAiH,MACAA,KAAAkhE,IAAArmE,MACA,IAAA2lE,GAAAxgE,IACAwgE,GAAA5mC,OAAA,GAAAunC,SAAA,SAAAziE,EAAA0iE,GACAZ,EAAA9hE,UACA8hE,EAAAY,WAIA,QAAAC,GAAAN,EAAA5F,GACA,GAAAsF,GAAAO,EAAAD,EAAA5F,GACAqF,EAAA,GAAAS,EAgBA,OAfAT,GAAAc,eAAA,SAAAC,GACA,gBAAAh8D,GACAi7D,EAAA13D,MAAAy4D,EACAf,EAAAj7D,QACAk7D,EAAAD,KAGAA,EAAAgB,cAAA,SAAAD,GACA,gBAAAL,GACAV,EAAA13D,MAAAy4D,EACAf,EAAAU,MACAT,EAAAD,KAGAC,EAAAD,GACAA,EAAA5mC,OAEA,QAAAonC,GAAAD,EAAA5F,GACA,gBAAAqF,GACA,OACA,IACA,MAAAO,GAAAhoE,KAAAoiE,EAAAqF,GACS,MAAAiB,GACTjB,EAAAL,gBAAAsB,CACA,IAAAr4C,GAAAo3C,EAAAF,UAAAE,EAAAF,UAAAhjE,OAAA,EACA,KAAA8rB,EAGA,KAFAo3C,GAAAP,OAAAW,GACAJ,EAAA13D,MAAA44D,GACAD,CAEAjB,GAAA13D,MAAAjO,SAAAuuB,EAAAotC,MAAAptC,EAAAotC,MAAAptC,EAAAwsC,QACA/6D,SAAAuuB,EAAAg3C,qBACAI,EAAAJ,mBAAAh3C,EAAAg3C,sBAKA,QAAAuB,GAAAxoE,GACAA,EAAAwjE,SACAwB,EAAAhlE,EAAAsX,QA5aA,IAAAtX,EAAA8B,gBAAA,CAGA,GAAAyjE,GAAAjuD,OACAguD,EAAA5B,UACAqB,EAAAQ,EAAAkD,OACAhC,EAAAlB,EAAAmD,iBACA/E,EAAA4B,EAAAV,eACAd,EAAAwB,EAAAoD,OACApE,EAAAgB,EAAAjB,yBACAD,EAAAkB,EAAAtB,oBACA0B,EAAAJ,EAAAqD,eACAnE,EAAAc,EAAAhuD,UAAArV,eAUAmuD,GATAkV,EAAAhuD,UAAAs8B,SASAivB,GACAx9B,EAAA,EAIAu+B,EAAAX,IACAY,EAAAZ,IACAU,EAAAV,IACAc,EAAAe,EAAA,KAeApB,GAAAH,EAAAjsD,UAAA,cAAAurD,EAAAU,IACAG,EAAAH,EAAAjsD,UAAA,WAAA84C,EAAA,WACA,GAAAwY,GAAAhiE,KAAA+8D,EACA,KAAA9xD,EAAA,WACA,MAAA+2D,GAAAhF,EACA,KAAAgF,EACA,KAAAnF,WAAA,mCACA,IAAAkB,GAAAiE,EAAA/E,EAGA,OAFApiE,UAAAkjE,IACAA,EAAA,IACA,UAAAA,EAAA,OAEAjB,EAAAH,EAAAjsD,UAAA,UAAA84C,EAAA,WACA,GAAAwY,GAAAhiE,KAAA+8D,EACA,KAAAiF,EACA,KAAAnF,WAAA,mCACA,OAAA5xD,GAAA,WAEA+2D,EADAA,EAAAhF,MAWAF,EAAAL,EAAA/rD,UAAA,cAAAurD,EAAAU,IACAG,EAAAL,EAAA/rD,UAAA,YACAnL,MAAAo3D,EAAAjsD,UAAAs8B,SACAmvB,YAAA,IAEAW,EAAAL,EAAA/rD,UAAA,WACAnL,MAAAo3D,EAAAjsD,UAAAuxD,QACA9F,YAAA,IAEAe,EAAAT,EAAA/rD,WACAisD,EAAAoD,SAAApD,GAmNA,IAAAuD,GAAA,EACAS,EAAA,EACAE,GAAA,EACAD,GAAA,EACAc,GAAA,EAeA1B,GAAAtvD,WACAwxD,QAAA,SAAAC,EAAAC,GACA,UAAAA,EAAA,CAEA,OADAhC,GAAA,KACA5gE,EAAAQ,KAAAsgE,UAAAhjE,OAAA,EAA+CkC,GAAA,EAAQA,IACvD,GAAA3E,SAAAmF,KAAAsgE,UAAA9gE,GAAAg3D,MAAA,CACA4J,EAAApgE,KAAAsgE,UAAA9gE,GAAAg3D,KACA,OAGA,OAAA4J,IACAA,EAAA,IACApgE,KAAAsgE,UAAA7iE,MACAm4D,UAAAwM,EACAhC,uBAGA,OAAA+B,GACAniE,KAAAsgE,UAAA7iE,MAA6B+4D,QAAA2L,KAG7BE,OAAA,WACAriE,KAAAsgE,UAAAxyD,QAkDAmzD,EAAAvwD,UAAAD,OAAAmxD,OAAA5B,EAAAtvD,WA6CAixD,EAAAxoE,GACAA,EAAA8B,iBACAomE,YACA9B,cACAM,mBACAtB,aACAuC,gBACArlE,cACAkmE,eACAhD,SACAO,YACAC,WACAC,WACAZ,WACAtjE,aACA2O,SAAA6yD,KAEC,mBAAAvjE,KAAA6G,MACD,WACA,QAAAsiE,GAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GACA,GAAAxjE,KAuBA,OAtBAkjE,IACAljE,EAAA5B,KAAA8kE,EAAA,KAEAE,IACApjE,EAAA5B,KAAA,MACA+kE,GACAnjE,EAAA5B,KAAA+kE,EAAA,KAEAnjE,EAAA5B,KAAAglE,GACAC,GACArjE,EAAA5B,KAAA,IAAAilE,IAGAC,GACAtjE,EAAA5B,KAAAklE,GAEAC,GACAvjE,EAAA5B,KAAA,IAAAmlE,GAEAC,GACAxjE,EAAA5B,KAAA,IAAAolE,GAEAxjE,EAAAgE,KAAA,IAaA,QAAAZ,GAAAqgE,GACA,MAAAA,GAAA9nE,MAAA+nE,GAEA,QAAAC,GAAA1kE,GACA,SAAAA,EACA,SAMA,QALA2kE,GAAA,MAAA3kE,EAAA,UACA4kE,EAAA,MAAA5kE,EAAA6E,MAAA,WACAggE,EAAA7kE,EAAAmE,MAAA,KACApD,KACAu/B,EAAA,EACAr2B,EAAA,EAAqBA,EAAA46D,EAAA7lE,OAAuBiL,IAAA,CAC5C,GAAA66D,GAAAD,EAAA56D,EACA,QAAA66D,GACA,OACA,QACA,KACA,UACA/jE,EAAA/B,OACA+B,EAAAyO,MAEA8wB,GACA,MACA,SACAv/B,EAAA5B,KAAA2lE,IAGA,IAAAH,EAAA,CACA,KAAArkC,IAAA,GACAv/B,EAAA8uD,QAAA,KAEA,KAAA9uD,EAAA/B,QACA+B,EAAA5B,KAAA,KAEA,MAAAwlE,GAAA5jE,EAAAgE,KAAA,KAAA6/D,EAEA,QAAAG,GAAA/yB,GACA,GAAAhyC,GAAAgyC,EAAAgzB,EAAAC,OAAA,EAGA,OAFAjlE,GAAA0kE,EAAA1kE,EAAAqT,QAAA,OAAAsuB,EAAA,MACAqQ,EAAAgzB,EAAAC,MAAAjlE,EACAgkE,EAAAhyB,EAAAgzB,EAAAE,QAAAlzB,EAAAgzB,EAAAG,WAAAnzB,EAAAgzB,EAAAI,QAAApzB,EAAAgzB,EAAAK,MAAArzB,EAAAgzB,EAAAC,MAAAjzB,EAAAgzB,EAAAM,YAAAtzB,EAAAgzB,EAAAO,WAEA,QAAAC,GAAAtgE,GACA,GAAA8sC,GAAA7tC,EAAAe,EACA,OAAA6/D,GAAA/yB,GAEA,QAAAyzB,GAAA1xD,EAAA7O,GACA,GAAA8sC,GAAA7tC,EAAAe,GACAwgE,EAAAvhE,EAAA4P,EACA,IAAAi+B,EAAAgzB,EAAAE,QACA,MAAAH,GAAA/yB,EAEAA,GAAAgzB,EAAAE,QAAAQ,EAAAV,EAAAE,OAEA,QAAAhkE,GAAA8jE,EAAAE,OAAuChkE,GAAA8jE,EAAAK,KAA0BnkE,IACjE8wC,EAAA9wC,KACA8wC,EAAA9wC,GAAAwkE,EAAAxkE,GAGA,SAAA8wC,EAAAgzB,EAAAC,MAAA,GACA,MAAAF,GAAA/yB,EAEA,IAAAhyC,GAAA0lE,EAAAV,EAAAC,MACArwB,EAAA50C,EAAAkS,YAAA,IAGA,OAFAlS,KAAA6E,MAAA,EAAA+vC,EAAA,GAAA5C,EAAAgzB,EAAAC,MACAjzB,EAAAgzB,EAAAC,MAAAjlE,EACA+kE,EAAA/yB,GAEA,QAAA2zB,GAAA7lE,GACA,IAAAA,EACA,QACA,UAAAA,EAAA,GACA,QACA,IAAAkyC,GAAA7tC,EAAArE,EACA,OAAAkyC,GAAAgzB,EAAAE,SACA,GACA,EAtFA,GAAAT,GAAA,GAAA5yD,QAAA,4HACAmzD,GACAE,OAAA,EACAC,UAAA,EACAC,OAAA,EACAC,KAAA,EACAJ,KAAA,EACAK,WAAA,EACAC,SAAA,EAgFA5oE,iBAAA6oE,kBACA7oE,gBAAAgpE,aACAhpE,gBAAA+nE,oBACA/nE,gBAAA8oE,gBAEA,SAAA5qE,GACA,YA0BA,SAAA+qE,GAAA9lE,GACA,GAAAA,EAAA,CAEA,GAAAoF,GAAA2gE,EAAAC,UAAAhmE,EACA,OAAAimE,GAAA7gE,IAKA,QAAA8gE,GAAAC,GACA,GAAAC,GAAAlgE,UAAA,GACAmgE,EAAAh0D,OAAAmxD,OAAA,KAqBA,OApBAnxD,QAAA2sD,oBAAAmH,GAAApkE,QAAA,SAAA/B,GACA,GAAAsmE,GACAn/D,CACA,IAAAi/D,IAAAG,EAAA,CACA,GAAAC,GAAAn0D,OAAAgtD,yBAAA8G,EAAAnmE,EACAwmE,GAAAhvC,MACA8uC,EAAAE,EAAAhvC,KAEA8uC,IACAn/D,EAAAg/D,EAAAnmE,GACAsmE,EAAA,WACA,MAAAn/D,KAGAkL,OAAAutD,eAAAyG,EAAArmE,GACAw3B,IAAA8uC,EACAvI,YAAA,MAGA1rD,OAAAo0D,kBAAAJ,GACAA,EAzDA,GAKAK,GALAC,EAAA9pE,gBACA6oE,EAAAiB,EAAAjB,gBACAC,EAAAgB,EAAAhB,WACAE,EAAAc,EAAAd,WACAI,EAAA5zD,OAAAmxD,OAAA,KAGAkD,GADA3rE,EAAA4H,UAAA5H,EAAA4H,SAAAsG,KACA08D,EAAA5qE,EAAA4H,SAAAsG,KAAA,MAEA,EACA,IAAA29D,GAAA,SAAAxhE,EAAA+gE,GACAvkE,KAAAwD,MACAxD,KAAAilE,OAAAV,EAEAtpE,iBAAA,YAAA+pE,QACA,IAAAE,GAAA,SAAA1hE,EAAA86C,GACArjD,gBAAAikE,UAAAl/D,KAAAmlE,EAAAz0D,UAAA,eAAAlN,EAAA,OACAxD,KAAAs+C,QAEA6mB,EAAAD,CACAjqE,iBAAA,YAAAiqE,GAA6DE,kBAAA,WAC7D,MAAAplE,MAAAilE,OACAjlE,KAAAilE,OACAjlE,KAAAilE,OAAAjlE,KAAAs+C,KAAAvlD,KAAAI,QACU6rE,EAQV,IAAAK,GAAA50D,OAAAmxD,OAAA,MACA+C,KA0BAR,GACAC,UAAA,SAAAhmE,EAAAknE,GACA,mBAAAlnE,GACA,SAAAy+D,WAAA,2CAAAz+D,GACA,IAAA6lE,EAAA7lE,GACA,MAAA0lE,GAAA1lE,EACA,oBAAArD,KAAAqD,GACA,SAAAC,OAAA,4BAAAD,EAEA,aAAAA,EAAA,IAAAknE,EACAvB,EAAAuB,EAAAlnE,GACA0lE,EAAA1lE,IAEAw3B,IAAA,SAAA2vC,GACA,GAAAh1D,GAAA2zD,EAAAqB,EACA,KAAAh1D,EACA,MAAA1V,OACA,IAAA2qE,GAAAH,EAAA90D,EAAA/M,IACA,OAAAgiE,GACAA,GACAA,EAAAlB,EAAA/zD,EAAA60D,oBAAAT,GACAU,EAAA90D,EAAA/M,KAAAgiE,IAEAp0C,IAAA,SAAAm0C,EAAA3sE,GACA2sE,EAAA97C,OAAA87C,GACAlB,EAAAkB,GAAA,GAAAL,GAAAK,EAAA,WACA,MAAA3sE,KAEAysE,EAAAE,GAAA3sE,GAEA6sE,GAAAX,WACA,MAAAA,IAEAW,GAAAX,SAAAryD,GACAqyD,EAAAr7C,OAAAhX,IAEAizD,eAAA,SAAAtnE,EAAAkgD,GACA,GAAAinB,GAAApB,EAAAC,UAAAhmE,EACA,IAAAimE,EAAAkB,GACA,SAAAlnE,OAAA,0BAAAknE,EACAlB,GAAAkB,GAAA,GAAAL,GAAAK,EAAAjnB,IAEAqnB,YAAAl1D,OAAAmxD,OAAA,MACA7Q,SAAA,SAAA3yD,EAAAwnE,EAAAtnB,GACAsnB,KAAAtoE,OAGA0C,KAAA2lE,YAAAvnE,IACAwnE,OACAC,QAAAvnB,GAJAt+C,KAAA0lE,eAAAtnE,EAAAkgD,IAQAwnB,mBAAA,SAAAxnB,GACA,UAAAgmB,GAAAhmB,EAAAvlD,KAAAI,GAAAwrE,IAEAoB,cAAA,SAAA3nE,GACA,GAAA2B,GAAAC,IAUA,OATAA,MAAAgmE,gBACAv1D,OAAAw1D,KAAAZ,GAAAa,KAAA,SAAA1hE,GACA,GAAA+L,GAAA,qBAAAlO,KAAAmC,EACA,OAAA+L,IACAxQ,EAAAimE,eAAAz1D,EAAA,IACA,GAFA,SAMAvQ,KAAA41B,IAAA51B,KAAAgmE,eAAA5nE,IAGA+lE,GAAA/yC,IAAA,sCAAAkzC,IAAkEH,gBAClE,IAAAxC,GAAA1mE,gBAAA0mE,YACA1mE,iBAAA0mE,aAAA,SAAAxoE,GACAwoE,EAAAxoE,IAEA8B,gBAAAkpE,cACAhrE,EAAAgtE,QACApV,SAAAoT,EAAApT,SAAAh1D,KAAAooE,GACAvuC,IAAAuuC,EAAAvuC,IACAxE,IAAA+yC,EAAA/yC,IACAgzC,UAAAD,EAAAC,WAEAnpE,gBAAAmrE,cAAA,SAAAhoE,GACA,GAAAioE,GAAAnC,EAAA9lE,EACA,OAAAioE,MAAAjB,sBAEC,mBAAAjsE,KAAA6G,MACDmmE,OAAApV,SAAA,mEACA,YAGA,SAAAuV,GAAA7vC,GACA,SAAAA,EAHA,GACA+nC,GAAAvjE,gBAAAujE,QAIA,QACAiH,GAAAjH,YACA,MAAAA,IAEAiH,GAAAa,YACA,MAAAA,OAIAH,OAAApV,SAAA,2EACA,YA0CA,SAAAwV,GAAAhvB,EAAAivB,GACA,GAAAnJ,GAAAmB,EAAAjnB,GACAwoB,EAAA,GAAA0G,EAIA,OAHA1G,GAAA2G,gBAAArJ,EACA0C,EAAA4G,wBAAA,EACA5G,EAAA6G,oBAAAJ,EACAzG,EAEA,QAAA8G,GAAAthE,EAAAgT,GACA,OACAhT,QACAgT,QAGA,QAAAuuD,KACA,MAAAP,GAAAvmE,KAAA+mE,GAEA,QAAAd,KACA,MAAAM,GAAAvmE,KAAAgnE,GAEA,QAAAC,KACA,MAAAV,GAAAvmE,KAAAknE,GA9DA,GAAAC,GAEAC,EAAAnsE,gBAAAmrE,cAAA,sDACA5H,EAAA4I,EAAA5I,SACA8H,EAAAc,EAAAd,SACAU,EAAA,EACAE,EAAA,EACAH,EAAA,EACAN,EAAA,YAwDA,OAvDAxrE,iBAAA,YAAAwrE,GAAAU,KAAyD12D,OAAAutD,eAAAmJ,EAAA,QACzD5hE,MAAA,WACA,GAAAw6D,GAAAvB,EAAAx+D,MACAu3C,EAAAwoB,EAAA2G,eACA,KAAAnvB,EACA,SAAAslB,WAAA,iCAEA,IAAA3pB,GAAA6sB,EAAA4G,wBACAU,EAAAtH,EAAA6G,oBACAtpE,EAAAgpE,EAAA/uB,EAAAj6C,OACA,OAAA41C,IAAA51C,GACAyiE,EAAA4G,wBAAAj8C,IACAm8C,EAAAhsE,QAAA,KAEAklE,EAAA4G,wBAAAzzB,EAAA,EACAm0B,GAAAH,EACAL,EAAAtvB,EAAArE,IAAA,GACAm0B,GAAAN,EACAF,GAAA3zB,EAAAqE,EAAArE,KAAA,GACA2zB,EAAA3zB,GAAA,KAEAgpB,cAAA,EACAC,YAAA,EACAC,UAAA,IACG3rD,OAAAutD,eAAAmJ,EAAAxK,OAAAoD,UACHx6D,MAAA,WACA,MAAAvF,OAEAk8D,cAAA,EACAC,YAAA,EACAC,UAAA,IACG+K,QAyBH1B,GAAAqB,WACA,MAAAA,IAEArB,GAAAQ,QACA,MAAAA,IAEAR,GAAAwB,UACA,MAAAA,OAIAd,OAAApV,SAAA,uEACA,YAUA,SAAAuW,KACA,kBACAtL,EAAAr/D,SAAA4qE,IAGA,QAAAC,KACA,GAAAC,GAAA,EACAC,EAAA,GAAAC,GAAAJ,GACAluD,EAAA/f,SAAAY,eAAA,GAEA,OADAwtE,GAAAE,QAAAvuD,GAA4BwuD,eAAA,IAC5B,WACAxuD,EAAAjc,KAAAqqE,MAAA,GAGA,QAAAK,KACA,kBACApqE,WAAA6pE,EAAA,IAIA,QAAAA,KACA,OAAA/nE,GAAA,EAAmBA,EAAAvC,EAAAK,OAAkBkC,IAAA,CACrC,GAAAuoE,GAAA9qE,EAAAuC,GACA2C,EAAA4lE,EAAA,GACArmE,EAAAqmE,EAAA,EACA5lE,GAAAT,GAEAzE,KApCA,GAsCA+qE,GArCAC,EAAA,SAAA9lE,EAAAT,GACA,GAAApE,GAAAL,EAAAQ,MAAA0E,EAAAT,GACA,KAAApE,GACA0qE,KAGAE,EAAA,mBAAAhvE,kBACAyuE,EAAAO,EAAAC,kBAAAD,EAAAE,uBAoBAnrE,IAkBA,OANA+qE,GADA,mBAAAhM,IAA0C,wBAAAhvB,SAAAj0C,KAAAijE,GAC1CsL,IACGK,EACHH,IAEAM,KAEUrC,GAAA,WACV,MAAAwC,OAGA9B,OAAApV,SAAA,qEACA,YAGA,SAAAsX,GAAA5xC,GACA,MAAAA,IAAA,gBAAAA,IAAA57B,SAAA47B,EAAA6xC,QAEA,QAAAC,GAAAC,GACA,GAAAC,GAAA,SAAAnkE,UAAA,GAAAA,UAAA,YAAAmyB,GACA,MAAAA,IAEAiyC,EAAA,SAAApkE,UAAA,GAAAA,UAAA,YAAArC,GACA,KAAAA,IAEA0mE,EAAAC,EAAAJ,EAAAhuB,YACA,QAAAguB,EAAAF,SACA,IAAAztE,QACA,KAAAgiE,UACA,eACA2L,EAAAK,WAAAprE,MAAAkrE,EAAAF,IACAD,EAAAM,UAAArrE,MAAAkrE,EAAAD,GACA,MACA,gBACAK,EAAAJ,EAAAF,EAAAD,EAAAvD,OACA,MACA,gBACA8D,EAAAJ,EAAAD,EAAAF,EAAAvD,QAGA,MAAA0D,GAAAH,QAEA,QAAAI,GAAA1T,GACA,GAAAt7B,KAKA,OAJAA,GAAA4uC,QAAA,GAAAtT,GAAA,SAAAx2D,EAAA0iE,GACAxnC,EAAAl7B,UACAk7B,EAAAwnC,WAEAxnC,EA0FA,QAAAovC,GAAAR,EAAA/xC,GACAwyC,EAAAT,EAAA,WAAA/xC,EAAA+xC,EAAAK,YAEA,QAAAK,GAAAV,EAAA11C,GACAm2C,EAAAT,EAAA,WAAA11C,EAAA01C,EAAAM,WAEA,QAAAG,GAAAT,EAAAW,EAAA5jE,EAAA6jE,GACA,eAAAZ,EAAAF,QAAA,CAEA,OAAA9oE,GAAA,EAAmBA,EAAA4pE,EAAA9rE,OAAsBkC,IACzCupE,EAAAK,EAAA5pE,GAAA,GAAA4pE,EAAA5pE,GAAA,GAAA+F,EAEAijE,GAAAF,QAAAa,EACAX,EAAAvD,OAAA1/D,EACAijE,EAAAK,WAAAL,EAAAM,UAAAjuE,QAEA,QAAAkuE,GAAAJ,EAAA9sE,EAAA46B,GACA1e,EAAA,WACA,IACA,GAAA2e,GAAA76B,EAAA46B,EACA,IAAAC,IAAAiyC,EAAAH,QACA,SAAA3L,UACAwL,GAAA3xC,GACA6xC,EAAA7xC,EAAAiyC,EAAAjqE,QAAAiqE,EAAAvH,QAEAuH,EAAAjqE,QAAAg4B,GACO,MAAAz0B,GACP0mE,EAAAvH,OAAAn/D,MAKA,QAAAonE,GAAA7uB,EAAA/jB,GACA,GAAA4xC,EAAA5xC,GACA,MAAAA,EACK,IAAAA,GAAA,kBAAAA,GAAA6yC,KAAA,CACL,GAAArwE,GAAAw9B,EAAA8yC,EACA,IAAAtwE,EACA,MAAAA,EAEA,IAAA0vE,GAAAC,EAAApuB,EACA/jB,GAAA8yC,GAAAZ,EAAAH,OACA,KACA/xC,EAAA6yC,KAAAX,EAAAjqE,QAAAiqE,EAAAvH,QACS,MAAAn/D,GACT0mE,EAAAvH,OAAAn/D,GAEA,MAAA0mE,GAAAH,QAGA,MAAA/xC,GA/KA,GACA1e,GAAA9c,gBAAAmrE,cAAA,0DAAAxP,QAoCAuK,EAAA,SAAAqI,GACA,GAAAC,GAAAzpE,IACAA,MAAAsoE,QAAA,UACAtoE,KAAA6oE,cACA7oE,KAAA8oE,aACAU,EAAA,SAAA/yC,GACAuyC,EAAAS,EAAAhzC,IACK,SAAA3D,GACLo2C,EAAAO,EAAA32C,KAGA73B,iBAAA,YAAAkmE,GACA3K,QAAA,SAAAkS,GACA,MAAA1oE,MAAAspE,KAAAzuE,OAAA6tE,IAEAY,KAAA,WACA,GAAAb,GAAA,SAAAnkE,UAAA,GAAAA,UAAA,YAAAmyB,GACA,MAAAA,IAEAiyC,EAAApkE,UAAA,GACAmlE,EAAAzpE,KACAw6C,EAAAx6C,KAAAw6C,WACA,OAAA+tB,GAAAvoE,KAAA,SAAAy2B,GAEA,MADAA,GAAA4yC,EAAA7uB,EAAA/jB,GACAA,IAAAgzC,EAAAf,EAAA,GAAA7L,YAAAwL,EAAA5xC,KAAA6yC,KAAAb,EAAAC,GAAAD,EAAAhyC,IACOiyC,MAGPhqE,QAAA,SAAA+3B,GACA,UAAAz2B,MAAA,SAAAtB,GACAA,EAAA+3B,MAGA2qC,OAAA,SAAAtuC,GACA,UAAA9yB,MAAA,SAAAtB,EAAA0iE,GACAA,EAAAtuC,MAGA42C,KAAA,SAAAjzC,GACA,GAAAA,YAAAz2B,MACA,MAAAy2B,EACA,IAAA4xC,EAAA5xC,GAAA,CACA,GAAAmD,GAAAgvC,EAAA5oE,KAEA,OADAuoE,GAAA9xC,EAAAmD,EAAAl7B,QAAAk7B,EAAAwnC,QACAxnC,EAAA4uC,QAEA,MAAAxoE,MAAAtB,QAAA+3B,IAEAkzC,IAAA,SAAA1C,GACA,GAAA0B,GAAAC,EAAA5oE,MACAy5C,EAAA,EACAmwB,IACA,KACA,OAAApqE,GAAA,EAAuBA,EAAAynE,EAAA3pE,OAAmBkC,MAC1Ci6C,EACAz5C,KAAA0pE,KAAAzC,EAAAznE,IAAA8pE,KAAA,SAAA9pE,EAAAi3B,GACAmzC,EAAApqE,GAAAi3B,EACA,MAAAgjB,GACAkvB,EAAAjqE,QAAAkrE,IACW7tE,KAAAlB,OAAA2E,GAAA,SAAAszB,GACX2mB,EAAA,IACAA,EAAA,GACAkvB,EAAAvH,OAAAtuC,IAGA,KAAA2mB,GACAkvB,EAAAjqE,QAAAkrE,GACO,MAAA3nE,GACP0mE,EAAAvH,OAAAn/D,GAEA,MAAA0mE,GAAAH,SAEAqB,KAAA,SAAA5C,GACA,GAAA0B,GAAAC,EAAA5oE,KACA,KACA,OAAAR,GAAA,EAAuBA,EAAAynE,EAAA3pE,OAAmBkC,IAC1CQ,KAAA0pE,KAAAzC,EAAAznE,IAAA8pE,KAAA,SAAA7yC,GACAkyC,EAAAjqE,QAAA+3B,IACW,SAAA3D,GACX61C,EAAAvH,OAAAtuC,KAGO,MAAA7wB,GACP0mE,EAAAvH,OAAAn/D,GAEA,MAAA0mE,GAAAH,UAkCA,IAAAe,GAAA,YAsBA,QAAU9D,GAAAtE,WACV,MAAAA,OAGAgF,OAAApV,SAAA,oEACA,YAKA,SAAA+Y,GAAAr8C,GACA,GAAAnc,GAAAmY,OAAAzpB,KACA,UAAAA,MAAA,mBAAA+pE,EAAAhxE,KAAA00B,GACA,KAAAovC,YAEA,IAAAmN,GAAA14D,EAAAhU,OACA2sE,EAAAxgD,OAAAgE,GAEAvT,GADA+vD,EAAA3sE,OACAgH,UAAAhH,OAAA,EAAAgH,UAAA,GAAAzJ,QACA0N,EAAA2R,EAAAjR,OAAAiR,GAAA,CACAgwD,OAAA3hE,KACAA,EAAA,EAEA,IAAA8B,GAAArH,KAAAL,IAAAK,KAAAoL,IAAA7F,EAAA,GAAAyhE,EACA,OAAAG,GAAApxE,KAAAuY,EAAA24D,EAAA1hE,IAAA8B,EAEA,QAAA+/D,GAAA38C,GACA,GAAAnc,GAAAmY,OAAAzpB,KACA,UAAAA,MAAA,mBAAA+pE,EAAAhxE,KAAA00B,GACA,KAAAovC,YAEA,IAAAmN,GAAA14D,EAAAhU,OACA2sE,EAAAxgD,OAAAgE,GACA48C,EAAAJ,EAAA3sE,OACAiL,EAAAyhE,CACA,IAAA1lE,UAAAhH,OAAA,GACA,GAAA4c,GAAA5V,UAAA,EACAzJ,UAAAqf,IACA3R,EAAA2R,EAAAjR,OAAAiR,GAAA,EACAgwD,MAAA3hE,KACAA,EAAA,IAIA,GAAA+B,GAAAtH,KAAAL,IAAAK,KAAAoL,IAAA7F,EAAA,GAAAyhE,GACA3/D,EAAAC,EAAA+/D,CACA,UAAAhgE,GACA,EAEAigE,EAAAvxE,KAAAuY,EAAA24D,EAAA5/D,MAEA,QAAA3J,GAAA+sB,GACA,SAAAztB,KACA,KAAA68D,YAEA,IAAAvrD,GAAAmY,OAAAzpB,MACAgqE,EAAA14D,EAAAhU,OACA2sE,EAAAxgD,OAAAgE,GAEAvT,GADA+vD,EAAA3sE,OACAgH,UAAAhH,OAAA,EAAAgH,UAAA,GAAAzJ,QACA0N,EAAA2R,EAAAjR,OAAAiR,GAAA,CACAgwD,OAAA3hE,KACAA,EAAA,EAEAvF,MAAAL,IAAAK,KAAAoL,IAAA7F,EAAA,GAAAyhE,EACA,WAAAG,EAAApxE,KAAAuY,EAAA24D,EAAA1hE,GAEA,QAAAgiE,GAAA9wB,GACA,SAAAz5C,KACA,KAAA68D,YAEA,IAAAvrD,GAAAmY,OAAAzpB,MACA6H,EAAA4xC,EAAAxwC,OAAAwwC,GAAA,CAIA,IAHAywB,MAAAriE,KACAA,EAAA,GAEA,EAAAA,GAAA6iB,KAAA7iB,EACA,KAAA2iE,aAEA,OAAA3iE,EACA,QAGA,KADA,GAAA+xB,GAAA,GACA/xB,KACA+xB,GAAAtoB,CAEA,OAAAsoB,GAEA,QAAA6wC,GAAAvwD,GACA,SAAAla,KACA,KAAA68D,YAEA,IAAAvrD,GAAAmY,OAAAzpB,MACAspB,EAAAhY,EAAAhU,OACA41C,EAAAh5B,EAAAjR,OAAAiR,GAAA,CAIA,IAHAgwD,MAAAh3B,KACAA,EAAA,GAEA,EAAAA,MAAA5pB,EACA,MAAAzuB,OAEA,IACA6vE,GADApqD,EAAAhP,EAAAwpB,WAAAoY,EAEA,OAAA5yB,IAAA,cAAAA,GAAAgJ,EAAA4pB,EAAA,IACAw3B,EAAAp5D,EAAAwpB,WAAAoY,EAAA,GACAw3B,GAAA,cAAAA,GACA,MAAApqD,EAAA,OAAAoqD,EAAA,YAGApqD,EAEA,QAAAqqD,GAAAC,GACA,GAAAD,GAAAC,EAAAD,IACAvjD,EAAAujD,EAAArtE,SAAA,CACA,QAAA8pB,EACA,QAGA,KAFA,GAAAuyC,GAAA,GACAn6D,EAAA,IACA,CAEA,GADAm6D,GAAAgR,EAAAnrE,GACAA,EAAA,IAAA4nB,EACA,MAAAuyC,EACAA,IAAAr1D,YAAA9E,IAGA,QAAAqrE,KACA,GAEAC,GACAC,EAHAC,KACAzxD,EAAAvW,KAAAuW,MAGA25B,EAAA,GACA51C,EAAAgH,UAAAhH,MACA,KAAAA,EACA,QAEA,QAAA41C,EAAA51C,GAAA,CACA,GAAA2tE,GAAAhiE,OAAA3E,UAAA4uC,GACA,KAAAg4B,SAAAD,IAAA,EAAAA,KAAA,SAAA1xD,EAAA0xD,MACA,KAAAT,YAAA,uBAAAS,EAEA,QAAAA,EACAD,EAAAvtE,KAAAwtE,IAEAA,GAAA,MACAH,GAAAG,GAAA,UACAF,EAAAE,EAAA,WACAD,EAAAvtE,KAAAqtE,EAAAC,IAGA,MAAAthD,QAAA2a,aAAAvK,MAAA,KAAAmxC,GA/IA,GACAjB,GAAAt5D,OAAAC,UAAAs8B,SACAm9B,EAAA1gD,OAAA/Y,UAAA5Q,QACAwqE,EAAA7gD,OAAA/Y,UAAAF,WA8IA,QACAi1D,GAAAqE,cACA,MAAAA,IAEArE,GAAA2E,YACA,MAAAA,IAEA3E,GAAA/kE,YACA,MAAAA,IAEA+kE,GAAA8E,UACA,MAAAA,IAEA9E,GAAAgF,eACA,MAAAA,IAEAhF,GAAAkF,OACA,MAAAA,IAEAlF,GAAAoF,iBACA,MAAAA,OAIA1E,OAAApV,SAAA,uEACA,YAeA,SAAAoa,GAAA9N,EAAAj/D,EAAAmH,GACAnH,IAAAi/D,IACA5sD,OAAAutD,eAAAX,EAAAj/D,GACAmH,QACA22D,cAAA,EACAC,YAAA,EACAC,UAAA,IAIA,QAAAgP,GAAA/N,EAAAgO,GACA,OAAA7rE,GAAA,EAAmBA,EAAA6rE,EAAA/tE,OAAsBkC,GAAA,GACzC,GAAApB,GAAAitE,EAAA7rE,GACA+F,EAAA8lE,EAAA7rE,EAAA,EACA2rE,GAAA9N,EAAAj/D,EAAAmH,IAGA,QAAA+lE,GAAAnyE,GACAA,EAAAgoE,UACAhoE,EAAAgoE,WAEA,QAAAoK,GAAA9hD,GACA2hD,EAAA3hD,EAAA/Y,WAAA,cAAA+5D,EAAA,WAAA/pE,EAAA,WAAA0pE,EAAA,aAAAN,EAAA,SAAAS,IACAa,EAAA3hD,GAAA,gBAAAohD,EAAA,MAAAF,IAEA,QAAAa,GAAA16D,EAAA6rD,GACAyO,EAAAt6D,EAAAJ,WAAA,UAAAo2D,EAAA,OAAAb,EAAA,SAAAgB,IACAtK,KAAAoD,UACAtvD,OAAAutD,eAAAltD,EAAAJ,UAAAisD,EAAAoD,UACAx6D,MAAA0hE,EACA/K,cAAA,EACAC,YAAA,EACAC,UAAA,IAIA,QAAAqP,GAAAtyE,GACAmyE,EAAAnyE,GACAoyE,EAAApyE,EAAAswB,QACA+hD,EAAAryE,EAAA2X,MAAA3X,EAAAwjE,QArDA,GACAwE,GAAAlmE,gBAAAmrE,cAAA,wDAAAjF,QACAuK,EAAAzwE,gBAAAmrE,cAAA,uDACAqE,EAAAiB,EAAAjB,YACA/pE,EAAAgrE,EAAAhrE,SACA0pE,EAAAsB,EAAAtB,SACAS,EAAAa,EAAAb,cACAN,EAAAmB,EAAAnB,OACAI,EAAAe,EAAAf,IACAb,EAAA4B,EAAA5B,WACA4B,EAAAzwE,gBAAAmrE,cAAA,8DACAU,EAAA4E,EAAA5E,QACAb,EAAAyF,EAAAzF,KACAgB,EAAAyE,EAAAzE,MA0CAwE,GAAAzrE,KACA,IAAA2hE,GAAA1mE,gBAAA0mE,YAKA,OAJA1mE,iBAAA0mE,aAAA,SAAAxoE,GACAwoE,EAAAxoE,GACAsyE,EAAAtyE,SAIAgtE,OAAApV,SAAA,mEACA,YAEA91D,iBAAAmrE,cAAA,yDACA,YAEAD,OAAAvwC,IAAA,wD7CswR8B78B,KAAKJ,EAASH,EAAU,WAAa,MAAOwH,SAAYxH,EAAQ,KAIxF,SAASI,EAAQD,EAASH,G8CrhUhCI,EAAAD,QAAAH,EAAAS,EAAA,wC9C2hUM,SAASL,EAAQD,EAASH,G+C3hUhCI,EAAAD,QAAAH,EAAAS,EAAA,wC/CiiUM,SAASL,EAAQD,EAASH,GgDjiUhCI,EAAAD,QAAAH,EAAAS,EAAA,wChDuiUM,SAASL,EAAQD,EAASH,GiDviUhCI,EAAAD,QAAAH,EAAAS,EAAA,wCjD6iUM,SAASL,EAAQD,EAASH,GkD7iUhCI,EAAAD,QAAAH,EAAAS,EAAA,wClDmjUM,SAASL,EAAQD,EAASH,GmDnjUhCI,EAAAD,QAAAH,EAAAS,EAAA,wCnDyjUM,SAASL,EAAQD,EAASH,GoDzjUhCI,EAAAD,QAAAH,EAAAS,EAAA,wCpD+jUM,SAASL,EAAQD,EAASH,GqD/jUhC,GAAAkE,GAAA/D,EAAA+D,aAAA,aACAivE,EAAAnzE,EAAA,IAWAozE,GAVApzE,EAAA,IAUA,GACAkE,GAAAgU,UAAAm7D,gBAAA,SAAAhkE,GACA7H,KAAA8rE,UAAA9rE,KAAA8rE,YACA9rE,KAAA+rE,cAAAlkE,GAIAnL,EAAAgU,UAAAs7D,KAAA,SAAAlyE,GAEA,aAAAA,KACAkG,KAAA8rE,UAAA9rE,KAAA8rE,QAAAG,OACAN,EAAA3rE,KAAA8rE,QAAAG,SAAAjsE,KAAA8rE,QAAAG,MAAA3uE,QAEA,KAAAgH,WAAA,YAAAjG,OACAiG,UAAA,GAEA,GAAAjG,OAAA,uCAMA,KAAA2B,KAAA8rE,QAAA,QACA,IAAAjwE,GAAAmE,KAAA8rE,QAAAhyE,EACA,KAAA+B,EAAA,QAEA,sBAAAA,GAAA,CACA,OAAAyI,UAAAhH,QAEA,OACAzB,EAAA9C,KAAAiH,KACA,MACA,QACAnE,EAAA9C,KAAAiH,KAAAsE,UAAA,GACA,MACA,QACAzI,EAAA9C,KAAAiH,KAAAsE,UAAA,GAAAA,UAAA,GACA,MAEA,SACA,GAAAP,GAAA+M,MAAAJ,UAAAvN,MAAApK,KAAAuL,UAAA,EACAzI,GAAAg+B,MAAA75B,KAAA+D,GAEA,SAEG,GAAA4nE,EAAA9vE,GAAA,CAIH,OAHAkI,GAAA+M,MAAAJ,UAAAvN,MAAApK,KAAAuL,UAAA,GAEA4nE,EAAArwE,EAAAsH,QACA3D,EAAA,EAAAF,EAAA4sE,EAAA5uE,OAAyCgC,EAAAE,EAAOA,IAChD0sE,EAAA1sE,GAAAq6B,MAAA75B,KAAA+D,EAEA,UAGA,UAMArH,EAAAgU,UAAAy7D,YAAA,SAAAryE,EAAAsyE,GACA,qBAAAA,GACA,SAAA/tE,OAAA,+CAsBA,IAnBA2B,KAAA8rE,UAAA9rE,KAAA8rE,YAIA9rE,KAAAgsE,KAAA,cAAAlyE,EAAAsyE,GACApsE,KAAA8rE,QAAAhyE,GAGG6xE,EAAA3rE,KAAA8rE,QAAAhyE,IAGHkG,KAAA8rE,QAAAhyE,GAAA2D,KAAA2uE,GAIApsE,KAAA8rE,QAAAhyE,IAAAkG,KAAA8rE,QAAAhyE,GAAAsyE,GARApsE,KAAA8rE,QAAAhyE,GAAAsyE,EAYAT,EAAA3rE,KAAA8rE,QAAAhyE,MAAAkG,KAAA8rE,QAAAhyE,GAAAuyE,OAAA,CACA,GAAA97D,EAEAA,GADA1V,SAAAmF,KAAA+rE,cACA/rE,KAAA+rE,cAEAH,EAGAr7D,KAAA,GAAAvQ,KAAA8rE,QAAAhyE,GAAAwD,OAAAiT,IACAvQ,KAAA8rE,QAAAhyE,GAAAuyE,QAAA,EACAjoE,QAAA6nE,MAAA,qIAGAjsE,KAAA8rE,QAAAhyE,GAAAwD,QACA8G,QAAAkoE,SAGA,MAAAtsE,OAGAtD,EAAAgU,UAAAhV,GAAAgB,EAAAgU,UAAAy7D,YAEAzvE,EAAAgU,UAAAzU,KAAA,SAAAnC,EAAAsyE,GAMA,QAAAnsC,KACAk7B,EAAAoR,eAAAzyE,EAAAmmC,GACAmsC,EAAAvyC,MAAA75B,KAAAsE,WAPA,qBAAA8nE,GACA,SAAA/tE,OAAA,yCAGA,IAAA88D,GAAAn7D,IASA,OAHAigC,GAAAmsC,WACAjR,EAAAz/D,GAAA5B,EAAAmmC,GAEAjgC,MAGAtD,EAAAgU,UAAA67D,eAAA,SAAAzyE,EAAAsyE,GACA,qBAAAA,GACA,SAAA/tE,OAAA,kDAIA,KAAA2B,KAAA8rE,UAAA9rE,KAAA8rE,QAAAhyE,GAAA,MAAAkG,KAEA,IAAAiQ,GAAAjQ,KAAA8rE,QAAAhyE,EAEA,IAAA6xE,EAAA17D,GAAA,CAEA,OADAiK,GAAA,GACA1a,EAAA,EAAAlC,EAAA2S,EAAA3S,OAAyCA,EAAAkC,EAAYA,IACrD,GAAAyQ,EAAAzQ,KAAA4sE,GACAn8D,EAAAzQ,GAAA4sE,UAAAn8D,EAAAzQ,GAAA4sE,aACA,CACAlyD,EAAA1a,CACA,OAIA,KAAA0a,EAAA,MAAAla,KACAiQ,GAAAyX,OAAAxN,EAAA,GACA,GAAAjK,EAAA3S,cACA0C,MAAA8rE,QAAAhyE,QACGmW,IAAAm8D,GACHn8D,EAAAm8D,UAAAn8D,EAAAm8D,qBACApsE,MAAA8rE,QAAAhyE,EAGA,OAAAkG,OAGAtD,EAAAgU,UAAA87D,mBAAA,SAAA1yE,GACA,WAAAwK,UAAAhH,QACA0C,KAAA8rE,WACA9rE,OAIAlG,GAAAkG,KAAA8rE,SAAA9rE,KAAA8rE,QAAAhyE,KAAAkG,KAAA8rE,QAAAhyE,GAAA,MACAkG,OAGAtD,EAAAgU,UAAAw7D,UAAA,SAAApyE,GAMA,MALAkG,MAAA8rE,UAAA9rE,KAAA8rE,YACA9rE,KAAA8rE,QAAAhyE,KAAAkG,KAAA8rE,QAAAhyE,OACA6xE,EAAA3rE,KAAA8rE,QAAAhyE,MACAkG,KAAA8rE,QAAAhyE,IAAAkG,KAAA8rE,QAAAhyE,KAEAkG,KAAA8rE,QAAAhyE,KrDukUM,SAASlB,EAAQD,EAASH,IsDjwUhC,SAAAA,EAAAwjE,GAOA,QAAAyQ,GAAAn8B,EAAAo8B,GAGA,OADA9tC,GAAA,EACAp/B,EAAA8wC,EAAAhzC,OAA4BkC,GAAA,EAAQA,IAAA,CACpC,GAAA4pB,GAAAknB,EAAA9wC,EACA,MAAA4pB,EACAknB,EAAA5oB,OAAAloB,EAAA,GACK,OAAA4pB,GACLknB,EAAA5oB,OAAAloB,EAAA,GACAo/B,KACKA,IACL0R,EAAA5oB,OAAAloB,EAAA,GACAo/B,KAKA,GAAA8tC,EACA,KAAU9tC,IAAMA,EAChB0R,EAAA6d,QAAA,KAIA,OAAA7d,GA9BA,GAAAnJ,GAAA3uC,EAAA,IAmCAm0E,EACA,+DAKAh0E,GAAA+F,QAAA,WAIA,OAHAkuE,GAAA,GACAC,GAAA,EAEArtE,EAAA8E,UAAAhH,OAA8BkC,GAAA,KAAAqtE,EAA8BrtE,IAAA,CAC5D,GAAAlB,GAAAkB,GAAA,EACA8E,UAAA9E,GACAw8D,EAAAz9D,KAGA,iBAAAD,QAIAsuE,EAAAtuE,EAAA,IAAAsuE,EACAC,EAAA,MAAAvuE,EAAA0N,OAAA,IAWA,MAJA4gE,GAAAH,EAAAtlC,EAAAylC,EAAAnqE,MAAA,cAAAxJ,GACA,QAAAA,KACG4zE,GAAAxpE,KAAA,MAEHwpE,EAAA,QAAAD,GAAA,KAKAj0E,EAAAyrE,UAAA,SAAA9lE,GACA,GAAA2lE,GAAA,MAAA3lE,EAAA0N,OAAA,GACAk3D,EAAA,MAAA5kE,EAAA6E,MAAA,GAcA,OAXA7E,GAAAmuE,EAAAtlC,EAAA7oC,EAAAmE,MAAA,cAAAxJ,GACA,QAAAA,KACGgrE,GAAA5gE,KAAA,KAEH/E,GAAA2lE,IACA3lE,EAAA,KAEAA,GAAA4kE,IACA5kE,GAAA,MAGA2lE,EAAA,QAAA3lE,GAKA3F,EAAA0K,KAAA,WACA,GAAAypE,GAAAh8D,MAAAJ,UAAAvN,MAAApK,KAAAuL,UAAA,EACA,OAAA3L,GAAAyrE,UAAAj9B,EAAA2lC,EAAA,SAAA7zE,GACA,MAAAA,IAAA,gBAAAA,KACGoK,KAAA,OAIH1K,EAAAo0E,QAAA,SAAAzuE,GACA,GAAAtD,GAAA2xE,EAAAtqE,KAAA/D,GACAy6D,EAAA/9D,EAAA,OACAyD,EAAAs6D,GAAA/9D,EAAA,QACAgyE,GAAA,CACA,OAAAvuE,GAGG,IAAAA,EAAAnB,QACH0vE,GAAAvuE,EAAAnB,QAAA,SAAAmB,EAAAuN,OAAA,GAEAvN,EAGAA,EAAAi8B,UAAA,EAAAj8B,EAAAnB,OAAA,GAPA,KAYA3E,EAAAs0E,SAAA,SAAA3uE,EAAA4uE,GACA,GAAAlwE,GAAA2vE,EAAAtqE,KAAA/D,GAAA,MAIA;MAHA4uE,IAAAlwE,EAAA6pD,OAAA,GAAAqmB,EAAA5vE,UAAA4vE,IACAlwE,IAAA6pD,OAAA,EAAA7pD,EAAAM,OAAA4vE,EAAA5vE,SAEAN,GAIArE,EAAAw0E,QAAA,SAAA7uE,GACA,MAAAquE,GAAAtqE,KAAA/D,GAAA,QAGA3F,EAAAy0E,SAAA,SAAAllE,EAAAC,GAIA,QAAAtF,GAAA8N,GAEA,IADA,GAAAtG,GAAA,EACUA,EAAAsG,EAAArT,QACV,KAAAqT,EAAAtG,GAD8BA,KAK9B,IADA,GAAAC,GAAAqG,EAAArT,OAAA,EACUgN,GAAA,GACV,KAAAqG,EAAArG,GADoBA,KAIpB,MAAAD,GAAAC,KACAqG,EAAAxN,MAAAkH,EAAAC,EAAAD,EAAA,GAfAnC,EAAAvP,EAAA+F,QAAAwJ,GAAA2+C,OAAA,GACA1+C,EAAAxP,EAAA+F,QAAAyJ,GAAA0+C,OAAA,EAsBA,QALAwmB,GAAAxqE,EAAAqF,EAAAzF,MAAA,MACA6qE,EAAAzqE,EAAAsF,EAAA1F,MAAA,MAEAnF,EAAA0F,KAAAL,IAAA0qE,EAAA/vE,OAAAgwE,EAAAhwE,QACAiwE,EAAAjwE,EACAkC,EAAA,EAAiBlC,EAAAkC,EAAYA,IAC7B,GAAA6tE,EAAA7tE,KAAA8tE,EAAA9tE,GAAA,CACA+tE,EAAA/tE,CACA,OAKA,OADAguE,MACAhuE,EAAA+tE,EAA+B/tE,EAAA6tE,EAAA/vE,OAAsBkC,IACrDguE,EAAA/vE,KAAA,KAKA,OAFA+vE,KAAA/lD,OAAA6lD,EAAAnqE,MAAAoqE,IAEAC,EAAAnqE,KAAA,MAGA1K,EAAA80E,IAAA,MtDowU8B10E,KAAKJ,EAASH,EAASA,EAAQ,KAIvD,SAASI,OAAQD,QAASH,SuDt7UhC,GAAAk1E,aAAA,SAAA17D,GACA,GAAAvB,OAAAw1D,KAAA,MAAAx1D,QAAAw1D,KAAAj0D,EAEA,IAAA27D,KACA,QAAAnpE,KAAAwN,GAAA27D,EAAAlwE,KAAA+G,EACA,OAAAmpE,IAIAxtE,QAAA,SAAAytE,EAAArwE,GACA,GAAAqwE,EAAAztE,QAAA,MAAAytE,GAAAztE,QAAA5C,EACA,QAAAiC,GAAA,EAAwBA,EAAAouE,EAAAtwE,OAAekC,IACvCjC,EAAAqwE,EAAApuE,KAAAouE,IAIAC,OAAAl1E,QAAAk1E,OAAA,SAAA/pC,GACA,MAAA9jC,gBAAA6tE,aACA7tE,KAAA8jC,QADA,GAAA+pC,QAAA/pC,GAIA+pC,QAAAn9D,UAAAo9D,gBAAA,SAAAhyE,GACAA,SAEA,IAAAiyE,GAAAz0E,SAAAO,cAAA,SACAk0E,GAAAnzE,QAAAmzE,EAAAnzE,UACAmzE,EAAAnzE,MAAAwM,QAAA,OAEA9N,SAAAoB,KAAAT,YAAA8zE,EAEA,IAAAC,GAAAD,EAAA/nE,aAEA7F,SAAAutE,YAAA5xE,GAAA,SAAA0I,GACAwpE,EAAAxpE,GAAA1I,EAAA0I,MAGAwpE,EAAAC,MAAAD,EAAAE,YAEAF,EAAAE,WAAA,OAGA,IAAAP,GAAAK,EAAAC,KAAAjuE,KAAA8jC,KAQA,OANA3jC,SAAAutE,YAAAM,GAAA,SAAAxpE,GACA1I,EAAA0I,GAAAwpE,EAAAxpE,KAGAlL,SAAAoB,KAAAL,YAAA0zE,GAEAJ,GAGAE,OAAAn9D,UAAAy9D,iBAAA,WACA,MAAAF,MAAAjuE,KAAA8jC,OAGA+pC,OAAAn9D,UAAA09D,aAAA,SAAAtyE,GAIA,MAAAkE,MAAA8tE,gBAAAhyE,IAGAqE,QAAAutE,YAAAG,OAAAn9D,WAAA,SAAAtS,GACAzF,QAAAyF,GAAAyvE,OAAAzvE,GAAA,SAAA0lC,GACA,GAAA61B,GAAAkU,OAAA/pC,EACA,OAAA61B,GAAAv7D,GAAAy7B,MAAA8/B,KAAAx2D,MAAApK,KAAAuL,UAAA,OAIA3L,QAAA01E,aAAA,SAAAvqC,GACA,MAAAnrC,SAAAk1E,OAAA/pC,IAGAnrC,QAAA21E,cAAAT,OAAAS,cAAA,SAAAxyE,GAGA,GAAA44B,KAMA,OALA,gBAAA54B,IACAqE,QAAAutE,YAAA5xE,GAAA,SAAA0I,GACAkwB,EAAAlwB,GAAA1I,EAAA0I,KAGAkwB,IvD87UM,SAAS97B,GwDjhVfA,EAAAD,QAAA,SAAAi1E,EAAArwE,GAEA,OADAowE,MACAnuE,EAAA,EAAmBA,EAAAouE,EAAAtwE,OAAekC,IAClCjC,EAAAqwE,EAAApuE,KAAAouE,IAAAD,EAAAlwE,KAAAmwE,EAAApuE,GAEA,OAAAmuE,KxDwhVM,SAAS/0E,GyD7hVfA,EAAAD,QAAA,SAAAi1E,EAAAn3C,GACA,GAAAm3C,EAAA9tE,QAAA,MAAA8tE,GAAA9tE,QAAA22B,EACA,QAAAj3B,GAAA,EAAmBA,EAAAouE,EAAAtwE,OAAekC,IAClC,GAAAi3B,IAAAm3C,EAAApuE,GAAA,MAAAA,EAEA,YzDqiVM,SAAS5G,G0D1iVfA,EAAAD,QAAA,kBAAAmY,OAAA66D,QACA76D,MAAA66D,QACA,SAAAiC,GACA,yBAAAn9D,OAAAC,UAAAs8B,SAAAj0C,KAAA60E,K1D8jVM,SAASh1E,G2D72Uf,QAAA21E,GAAAlR,EAAAvjE,EAAAqI,GACA,MAAAk7D,GAAArhE,qBACAqhE,GAAArhE,iBAAAlC,EAAAqI,GAAA,OAIAk7D,GAAAnlB,YAAA,KAAAp+C,EAAAqI,GASA,QAAAqsE,GAAAvsE,GAGA,eAAAA,EAAAnI,KAAA,CACA,GAAA20E,GAAAhlD,OAAA2a,aAAAniC,EAAAkiC,MAeA,OAJAliC,GAAA48B,WACA4vC,IAAAlzE,eAGAkzE,EAIA,MAAAC,GAAAzsE,EAAAkiC,OACAuqC,EAAAzsE,EAAAkiC,OAGAwqC,EAAA1sE,EAAAkiC,OACAwqC,EAAA1sE,EAAAkiC,OAQA1a,OAAA2a,aAAAniC,EAAAkiC,OAAA5oC,cAUA,QAAAqzE,GAAAC,EAAAC,GACA,MAAAD,GAAAzjD,OAAA/nB,KAAA,OAAAyrE,EAAA1jD,OAAA/nB,KAAA,KASA,QAAA0rE,GAAAC,GACAA,OAEA,IACAxqE,GADAyqE,GAAA,CAGA,KAAAzqE,IAAA0qE,GACAF,EAAAxqE,GACAyqE,GAAA,EAGAC,EAAA1qE,GAAA,CAGAyqE,KACAE,GAAA,GAgBA,QAAAC,GAAAX,EAAAY,EAAAptE,EAAAqtE,EAAAC,EAAAt5C,GACA,GAAAz2B,GACA2C,EACAqtE,KACA9O,EAAAz+D,EAAAnI,IAGA,KAAA21E,EAAAhB,GACA,QAUA,KANA,SAAA/N,GAAAgP,EAAAjB,KACAY,GAAAZ,IAKAjvE,EAAA,EAAaA,EAAAiwE,EAAAhB,GAAAnxE,SAAkCkC,EAK/C,GAJA2C,EAAAstE,EAAAhB,GAAAjvE,IAIA8vE,IAAAntE,EAAAwtE,KAAAT,EAAA/sE,EAAAwtE,MAAAxtE,EAAA8zB,QAMAyqC,GAAAv+D,EAAAu+D,SAWA,YAAAA,IAAAz+D,EAAA+hC,UAAA/hC,EAAAgiC,SAAA2qC,EAAAS,EAAAltE,EAAAktE,YAAA,CAOA,GAAAO,IAAAN,GAAAntE,EAAA0tE,OAAAN,EACAO,EAAAR,GAAAntE,EAAAwtE,KAAAL,GAAAntE,EAAA8zB,UACA25C,GAAAE,IACAL,EAAAhB,GAAA/mD,OAAAloB,EAAA,GAGAgwE,EAAA/xE,KAAA0E,GAIA,MAAAqtE,GASA,QAAAO,GAAA9tE,GACA,GAAAotE,KAkBA,OAhBAptE,GAAA48B,UACAwwC,EAAA5xE,KAAA,SAGAwE,EAAAmrC,QACAiiC,EAAA5xE,KAAA,OAGAwE,EAAAgiC,SACAorC,EAAA5xE,KAAA,QAGAwE,EAAA+hC,SACAqrC,EAAA5xE,KAAA,QAGA4xE,EASA,QAAAW,GAAA/tE,GACA,MAAAA,GAAA41C,mBACA51C,GAAA41C,sBAIA51C,EAAA4hC,aAAA,GASA,QAAAosC,GAAAhuE,GACA,MAAAA,GAAA5E,oBACA4E,GAAA5E,uBAIA4E,EAAA81C,cAAA,GAaA,QAAAm4B,GAAA/tE,EAAAF,EAAA4tE,EAAAM,GAGAC,EAAAC,aAAApuE,IAAAC,QAAAD,EAAA0V,WAAAk4D,EAAAM,IAIAhuE,EAAAF,EAAA4tE,MAAA,IACAG,EAAA/tE,GACAguE,EAAAhuE,IAYA,QAAAquE,GAAA7B,EAAAY,EAAAptE,GACA,GACAzC,GADA+wE,EAAAnB,EAAAX,EAAAY,EAAAptE,GAEA+sE,KACAwB,EAAA,EACAC,GAAA,CAGA,KAAAjxE,EAAA,EAAaA,EAAA+wE,EAAAjzE,SAAsBkC,EACnC+wE,EAAA/wE,GAAAmwE,MACAa,EAAAxtE,KAAAoL,IAAAoiE,EAAAD,EAAA/wE,GAAAy2B,OAKA,KAAAz2B,EAAA,EAAaA,EAAA+wE,EAAAjzE,SAAsBkC,EAOnC,GAAA+wE,EAAA/wE,GAAAmwE,IAAA,CAUA,GAAAY,EAAA/wE,GAAAy2B,OAAAu6C,EACA,QAGAC,IAAA,EAGAzB,EAAAuB,EAAA/wE,GAAAmwE,KAAA,EACAO,EAAAK,EAAA/wE,GAAA2C,SAAAF,EAAAsuE,EAAA/wE,GAAAqwE,MAAAU,EAAA/wE,GAAAmwE,SAMAc,IACAP,EAAAK,EAAA/wE,GAAA2C,SAAAF,EAAAsuE,EAAA/wE,GAAAqwE,MAyBA,IAAAa,GAAA,YAAAzuE,EAAAnI,MAAA62E,CACA1uE,GAAAnI,MAAAq1E,GAAAO,EAAAjB,IAAAiC,GACA3B,EAAAC,GAGA2B,EAAAF,GAAA,WAAAxuE,EAAAnI,KASA,QAAA82E,GAAA3uE,GAIA,gBAAAA,GAAAkiC,QACAliC,EAAAkiC,MAAAliC,EAAAyhC,QAGA,IAAA+qC,GAAAD,EAAAvsE,EAGA,IAAAwsE,EAKA,eAAAxsE,EAAAnI,MAAA+2E,IAAApC,OACAoC,GAAA,OAIAT,GAAAU,UAAArC,EAAAsB,EAAA9tE,MASA,QAAAytE,GAAAlrE,GACA,eAAAA,GAAA,QAAAA,GAAA,OAAAA,GAAA,QAAAA,EAWA,QAAAusE,KACA/5D,aAAAg6D,GACAA,EAAAtzE,WAAAqxE,EAAA,KASA,QAAAkC,KACA,IAAAC,EAAA,CACAA,IACA,QAAA1sE,KAAAkqE,GAIAlqE,EAAA,QAAAA,GAIAkqE,EAAArzE,eAAAmJ,KACA0sE,EAAAxC,EAAAlqE,OAIA,MAAA0sE,GAUA,QAAAC,GAAA3sE,EAAA6qE,EAAA3O,GAcA,MAVAA,KACAA,EAAAuQ,IAAAzsE,GAAA,sBAKA,YAAAk8D,GAAA2O,EAAA/xE,SACAojE,EAAA,WAGAA,EAYA,QAAA0Q,GAAAvB,EAAA5J,EAAA9jE,EAAAu+D,GAaA,QAAA2Q,GAAAC,GACA,kBACAnC,EAAAmC,IACApC,EAAAW,GACAkB,KAWA,QAAAQ,GAAAtvE,GACAiuE,EAAA/tE,EAAAF,EAAA4tE,GAKA,UAAAnP,IACAmQ,EAAArC,EAAAvsE,IAKAvE,WAAAqxE,EAAA,IApCAG,EAAAW,GAAA,CAgDA,QAAArwE,GAAA,EAAiBA,EAAAymE,EAAA3oE,SAAiBkC,EAAA,CAClC,GAAAgyE,GAAAhyE,EAAA,IAAAymE,EAAA3oE,OACAm0E,EAAAD,EAAAD,EAAAF,EAAA3Q,GAAAgR,EAAAzL,EAAAzmE,EAAA,IAAAkhE,OACAiR,GAAA1L,EAAAzmE,GAAAiyE,EAAA/Q,EAAAmP,EAAArwE,IAUA,QAAAoyE,GAAArC,GACA,YAAAA,GACA,KAGAA,EAAA9sE,MAAA,KAUA,QAAAivE,GAAAnC,EAAA7O,GACA,GAAAuF,GACAzhE,EACAhF,EACA6vE,IAMA,KAFApJ,EAAA2L,EAAArC,GAEA/vE,EAAA,EAAaA,EAAAymE,EAAA3oE,SAAiBkC,EAC9BgF,EAAAyhE,EAAAzmE,GAGAqyE,EAAArtE,KACAA,EAAAqtE,EAAArtE,IAMAk8D,GAAA,YAAAA,GAAAoR,EAAAttE,KACAA,EAAAstE,EAAAttE,GACA6qE,EAAA5xE,KAAA,UAIAiyE,EAAAlrE,IACA6qE,EAAA5xE,KAAA+G,EAQA,OAFAk8D,GAAAyQ,EAAA3sE,EAAA6qE,EAAA3O,IAGAl8D,MACA6qE,YACA3O,UAcA,QAAAiR,GAAApC,EAAAptE,EAAAu+D,EAAA4O,EAAAr5C,GAGA87C,EAAAxC,EAAA,IAAA7O,GAAAv+D,EAGAotE,IAAA59D,QAAA,WAEA,IACAgtC,GADAwxB,EAAAZ,EAAA9sE,MAAA,IAKA,OAAA0tE,GAAA7yE,OAAA,MACA8zE,GAAA7B,EAAAY,EAAAhuE,EAAAu+D,IAIA/hB,EAAA+yB,EAAAnC,EAAA7O,GAIA+O,EAAA9wB,EAAAn6C,KAAAirE,EAAA9wB,EAAAn6C,SAGA4qE,EAAAzwB,EAAAn6C,IAAAm6C,EAAA0wB,WAAyCv1E,KAAA6kD,EAAA+hB,QAAkB4O,EAAAC,EAAAt5C,OAQ3Dw5C,GAAA9wB,EAAAn6C,KAAA8qE,EAAA,mBACAntE,WACAktE,UAAA1wB,EAAA0wB,UACA3O,OAAA/hB,EAAA+hB,OACAiP,IAAAL,EACAr5C,QACA45C,MAAAN,KAYA,QAAAyC,GAAAC,EAAA9vE,EAAAu+D,GACA,OAAAlhE,GAAA,EAAiBA,EAAAyyE,EAAA30E,SAAyBkC,EAC1CmyE,EAAAM,EAAAzyE,GAAA2C,EAAAu+D,GAvoBA,OAzDAwQ,GA6BAF,EAtIAtC,GACArkB,EAAA,YACAC,EAAA,MACAC,GAAA,QACAC,GAAA,QACAC,GAAA,OACAC,GAAA,MACAE,GAAA,WACAC,GAAA,MACAC,GAAA,QACAC,GAAA,SACAC,GAAA,WACAC,GAAA,MACAC,GAAA,OACAC,GAAA,OACAC,GAAA,KACAC,GAAA,QACAC,GAAA,OACAE,GAAA,MACAC,GAAA,MACAG,GAAA,OACAE,GAAA,OACAomB,IAAA,QAWAvD,GACAwD,IAAA,IACApmB,IAAA,IACAC,IAAA,IACAomB,IAAA,IACAC,IAAA,IACAlmB,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,KACAC,IAAA,IACAC,IAAA,KAaAilB,GACAQ,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,EAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACA3jE,IAAA,IACAC,IAAA,IACAoD,EAAA,IACAugE,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,IACAC,IAAA,MASAxB,GACAtlC,OAAA,MACA+mC,QAAA,OACAzd,SAAA,QACA0d,OAAA,MACAlyE,IAAA,uBAAAtG,KAAAiU,UAAArR,UAAA,eAiBA8xE,KAOAsC,KAQA7C,KAcA2B,GAAA,EAOAF,GAAA,EAQAxB,GAAA,EAMA3vE,EAAA,EAAe,GAAAA,IAAQA,EACvBkvE,EAAA,IAAAlvE,GAAA,IAAAA,CAMA,KAAAA,EAAA,EAAW,GAAAA,IAAQA,EACnBkvE,EAAAlvE,EAAA,IAAAA,CAooBA+uE,GAAAj1E,SAAA,WAAAs3E,GACArC,EAAAj1E,SAAA,UAAAs3E,GACArC,EAAAj1E,SAAA,QAAAs3E,EAEA,IAAAR,IAgBAr0E,KAAA,SAAAkqE,EAAA9jE,EAAAu+D,GAGA,MAFAuF,eAAAn1D,OAAAm1D,MACA+L,EAAA/L,EAAA9jE,EAAAu+D,GACA1gE,MAoBAwzE,OAAA,SAAAvN,EAAAvF,GACA,MAAA0P,GAAAr0E,KAAAkqE,EAAA,aAA6CvF,IAU7C+S,QAAA,SAAAxN,EAAAvF,GAIA,MAHAqR,GAAA9L,EAAA,IAAAvF,IACAqR,EAAA9L,EAAA,IAAAvF,MAAwCuF,GAExCjmE,MAUA4kC,MAAA,WAGA,MAFA6qC,MACAsC,KACA/xE,MAUAqwE,aAAA,SAAApuE,EAAAyxE,GAGA,WAAAA,EAAAjlE,UAAA,KAAA3O,QAAA,mBACA,EAIA,SAAA4zE,EAAAC,SAAA,UAAAD,EAAAC,SAAA,YAAAD,EAAAC,SAAAD,EAAAE,mBAMA9C,UAAAR,EAGA13E,GAAAD,QAAAy3E","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction require(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/ \t\t\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, require);\n/******/ \t\t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/******/ \t\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \trequire.modules = modules;\n/******/ \t\n/******/ \t// expose the module cache\n/******/ \trequire.cache = installedModules;\n/******/ \t\n/******/ \t// __webpack_public_path__\n/******/ \trequire.p = \"build/\";\n/******/ \t\n/******/ \t\n/******/ \t// Load entry module and return exports\n/******/ \treturn require(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, require) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\twindow.global = window;\n\trequire(33);\n\trequire(32);\n\tvar Deck = require(4);\n\twindow.deck = new Deck(document.getElementById(\"slides\"), {\n\t  \"editor\": require(7),\n\t  \"background\": require(6),\n\t  \"image\": require(9)\n\t});\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, require) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tmodule.exports = function addStyle(cssCode) {\r\n\t\tif(false) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = cssCode;\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(document.createTextNode(cssCode));\r\n\t\t}\r\n\t\tvar head = document.getElementsByTagName(\"head\")[0];\r\n\t\thead.appendChild(styleElement);\r\n\t\treturn function() {\r\n\t\t\thead.removeChild(styleElement);\r\n\t\t};\r\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, require) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\tvar cachedPrefix = null;\n\tfunction getPrefix() {\n\t  if (cachedPrefix)\n\t    return cachedPrefix;\n\t  var regex = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/;\n\t  var elem = document.body;\n\t  for (var $prop in elem.style) {\n\t    try {\n\t      throw undefined;\n\t    } catch (prop) {\n\t      prop = $prop;\n\t      if (regex.test(prop)) {\n\t        return cachedPrefix = prop.match(regex)[$traceurRuntime.toProperty(0)];\n\t      }\n\t    }\n\t  }\n\t  if ($traceurRuntime.toProperty(\"WebkitOpacity\") in elem.style) {\n\t    return cachedPrefix = \"Webkit\";\n\t  }\n\t  if ($traceurRuntime.toProperty(\"KhtmlOpacity\") in elem.style) {\n\t    return cachedPrefix = \"Khtml\";\n\t  }\n\t  return cachedPrefix = \"\";\n\t}\n\tvar cachedEvents = {};\n\tfunction vendorPrefix(prop) {\n\t  if (cachedEvents.hasOwnProperty(prop))\n\t    return cachedEvents[$traceurRuntime.toProperty(prop)];\n\t  var vp = getPrefix().toLowerCase();\n\t  var pp = (vp) ? (vp + prop) : prop.toLowerCase();\n\t  $traceurRuntime.setProperty(cachedEvents, prop, pp);\n\t  return pp;\n\t}\n\tfunction on(emitter, eventName, handler, context) {\n\t  handler = context ? handler.bind(context) : handler;\n\t  emitter.addEventListener(eventName, handler);\n\t  return handler;\n\t}\n\tfunction once(emitter, eventName, handler, context) {\n\t  handler = context ? handler.bind(context) : handler;\n\t  var wrapper = function onceHandler(event) {\n\t    emitter.removeEventListener(eventName, onceHandler);\n\t    handler(event);\n\t  };\n\t  emitter.addEventListener(eventName, wrapper);\n\t  return wrapper;\n\t}\n\tfunction until(emitter, eventName, handler, context) {\n\t  handler = context ? handler.bind(context) : handler;\n\t  var wrapper = function untilHandler(event) {\n\t    if (handler(event))\n\t      emitter.removeEventListener(eventName, untilHandler);\n\t  };\n\t  emitter.addEventListener(eventName, wrapper);\n\t  return wrapper;\n\t}\n\tfunction off(emitter, eventName, handler) {\n\t  emitter.removeEventListener(eventName, handler);\n\t}\n\tmodule.exports = {\n\t  on: on,\n\t  once: once,\n\t  until: until,\n\t  off: off,\n\t  vendorPrefix: vendorPrefix\n\t};\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, require) {\n\n\tvar events = require(41);\n\t\n\texports = module.exports = new events.EventEmitter();\n\t\n\texports.nextTick = (function () {\n\t    var canSetImmediate = typeof window !== 'undefined'\n\t        && window.setImmediate;\n\t    var canPost = typeof window !== 'undefined'\n\t        && window.postMessage && window.addEventListener\n\t    ;\n\t\n\t    if (canSetImmediate) {\n\t        return function (f) { return window.setImmediate(f) };\n\t    }\n\t\n\t    if (canPost) {\n\t        var queue = [];\n\t        window.addEventListener('message', function (ev) {\n\t            if (ev.source === window && ev.data === 'browserify-tick') {\n\t                ev.stopPropagation();\n\t                if (queue.length > 0) {\n\t                    var fn = queue.shift();\n\t                    fn();\n\t                }\n\t            }\n\t        }, true);\n\t\n\t        return function nextTick(fn) {\n\t            queue.push(fn);\n\t            window.postMessage('browserify-tick', '*');\n\t        };\n\t    }\n\t\n\t    return function nextTick(fn) {\n\t        setTimeout(fn, 0);\n\t    };\n\t})();\n\t\n\texports.platform = exports.arch = \n\texports.execPath = exports.title = 'browser';\n\texports.pid = 1;\n\texports.browser = true;\n\texports.env = {};\n\texports.argv = [];\n\t\n\texports.binding = function (name) {\n\t    if (name === 'evals') return (require)(43)\n\t    else throw new Error('No such module. (Possibly not yet loaded)')\n\t};\n\t\n\t(function () {\n\t    var cwd = '/';\n\t    var path;\n\t    exports.cwd = function () { return cwd };\n\t    exports.chdir = function (dir) {\n\t        if (!path) path = require(42);\n\t        cwd = path.resolve(dir, cwd);\n\t    };\n\t})();\n\t\n\texports.exit = exports.kill = \n\texports.umask = exports.dlopen = \n\texports.uptime = exports.memoryUsage = \n\texports.uvCounters = function() {};\n\texports.features = {};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, require) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\tvar events = require(2);\n\tvar mousetrap = require(47);\n\tfunction toArray(indexable) {\n\t  var out = [],\n\t      l = indexable.length;\n\t  {\n\t    try {\n\t      throw undefined;\n\t    } catch ($i) {\n\t      $i = 0;\n\t      for (; $i < l; $i++) {\n\t        try {\n\t          throw undefined;\n\t        } catch (i) {\n\t          i = $i;\n\t          try {\n\t            out.push(indexable[$traceurRuntime.toProperty(i)]);\n\t          } finally {\n\t            $i = i;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return out;\n\t}\n\tfunction Deck(container, deckModules) {\n\t  var $__0 = this;\n\t  var slides = toArray(container.querySelectorAll(\"section\"));\n\t  this.currentSlide = null;\n\t  slides.forEach((function(slide) {\n\t    var children = toArray(slide.childNodes);\n\t    var container = document.createElement(\"div\");\n\t    container.classList.add(\"slideContainer\");\n\t    children.forEach((function(child) {\n\t      slide.removeChild(child);\n\t      container.appendChild(child);\n\t    }));\n\t    slide.appendChild(container);\n\t  }));\n\t  function slideIndex(slide) {\n\t    return slides.indexOf(slide);\n\t  }\n\t  this.deactivateSlide = (function(slide) {\n\t    if (slide.classList.contains(\"current\")) {\n\t      slide.classList.add(\"out\");\n\t      slide.classList.remove(\"current\");\n\t    }\n\t    $__0.currentSlide = null;\n\t  });\n\t  this.activateSlide = (function(slide) {\n\t    if (slide.classList.contains(\"out\")) {\n\t      $__0.cleanupModules(slide);\n\t      slide.classList.remove(\"out\");\n\t    }\n\t    if ($__0.currentSlide !== null)\n\t      $__0.deactivateSlide(slides[$traceurRuntime.toProperty($__0.currentSlide)]);\n\t    $__0.currentSlide = slideIndex(slide);\n\t    $__0.activateModules(slide);\n\t    slide.classList.add(\"current\");\n\t    slide.classList.add(\"in\");\n\t    window.location.hash = \"\" + $__0.currentSlide;\n\t  });\n\t  this.nextSlide = (function() {\n\t    var nextSlide = $__0.currentSlide !== null ? $__0.currentSlide + 1 : 0;\n\t    if (nextSlide >= slides.length)\n\t      nextSlide = slides.length - 1;\n\t    if (nextSlide !== $__0.currentSlide)\n\t      $__0.activateSlide(slides[$traceurRuntime.toProperty(nextSlide)]);\n\t  });\n\t  this.previousSlide = (function() {\n\t    var prevSlide = $__0.currentSlide !== null ? $__0.currentSlide - 1 : 0;\n\t    if (prevSlide < 0)\n\t      prevSlide = 0;\n\t    if (prevSlide !== $__0.currentSlide)\n\t      $__0.activateSlide(slides[$traceurRuntime.toProperty(prevSlide)]);\n\t  });\n\t  this.initModules = (function(slide) {\n\t    var slideData = slide.dataset,\n\t        deckData = container.dataset;\n\t    var mods = [],\n\t        mod;\n\t    for (mod in deckModules) {\n\t      if (deckModules.hasOwnProperty(mod)) {\n\t        try {\n\t          throw undefined;\n\t        } catch (arg) {\n\t          arg = slideData.hasOwnProperty(mod) ? slideData[$traceurRuntime.toProperty(mod)] : deckData.hasOwnProperty(mod) ? deckData[$traceurRuntime.toProperty(mod)] : null;\n\t          if (arg)\n\t            mods.push(new deckModules[$traceurRuntime.toProperty(mod)](slide, arg));\n\t        }\n\t      }\n\t    }\n\t    slide._deck_modules = mods;\n\t  });\n\t  this.activateModules = (function(slide) {\n\t    slide._deck_modules.forEach((function(mod) {\n\t      return mod.activate && mod.activate();\n\t    }));\n\t  });\n\t  this.stabiliseModules = (function(slide) {\n\t    slide._deck_modules.forEach((function(mod) {\n\t      return mod.stabilise && mod.stabilise();\n\t    }));\n\t  });\n\t  this.cleanupModules = (function(slide) {\n\t    slide._deck_modules.forEach((function(mod) {\n\t      return mod.cleanup && mod.cleanup();\n\t    }));\n\t  });\n\t  this.transitionEnd = (function(e) {\n\t    var slide = e.target;\n\t    if (slide.classList.contains(\"out\")) {\n\t      slide.classList.remove(\"out\");\n\t      $__0.cleanupModules(slide);\n\t    } else if (slide.classList.contains(\"in\")) {\n\t      slide.classList.remove(\"in\");\n\t      $__0.stabiliseModules(slide);\n\t    }\n\t  });\n\t  slides.forEach(((function(slide) {\n\t    return $__0.initModules(slide);\n\t  })).bind(this));\n\t  events.on(container, events.vendorPrefix(\"TransitionEnd\"), this.transitionEnd, this);\n\t  this.bind = (function(binding, callback) {\n\t    mousetrap.bind(binding, callback.bind($__0));\n\t  });\n\t  this.bind([\"pageup\", \"left\"], this.previousSlide);\n\t  this.bind([\"pagedown\", \"space\", \"right\"], this.nextSlide);\n\t  setTimeout((function() {\n\t    var match = /^#(\\d+)$/.exec(window.location.hash);\n\t    if (match) {\n\t      $__0.activateSlide(slides[$traceurRuntime.toProperty(parseInt(match[$traceurRuntime.toProperty(1)], 10))]);\n\t    } else {\n\t      $__0.nextSlide();\n\t    }\n\t  }), 1);\n\t}\n\tmodule.exports = Deck;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, require) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\tfunction minIndent(text) {\n\t  return text.split(\"\\n\").reduce(function(min, line) {\n\t    if (line.trim().length === 0)\n\t      return min;\n\t    var indent = line.length - line.trimLeft().length;\n\t    return min === null ? indent : Math.min(min, indent);\n\t  }, null);\n\t}\n\tfunction alignIndents(text) {\n\t  var indent = minIndent(text);\n\t  return text.split(\"\\n\").map(function(line) {\n\t    return line.slice(indent).trimRight();\n\t  }).join(\"\\n\");\n\t}\n\tfunction cleanText(text) {\n\t  text = alignIndents(text);\n\t  while (text[$traceurRuntime.toProperty(0)] === \"\\n\")\n\t    text = text.slice(1);\n\t  while (text[$traceurRuntime.toProperty(text.length - 1)] === \"\\n\")\n\t    text = text.slice(0, text.length - 1);\n\t  return text + \"\\n\";\n\t}\n\tmodule.exports = {cleanText: cleanText};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, require) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\tvar events = require(2);\n\tfunction Background(slide, url) {\n\t  var $__0 = this;\n\t  var preload = document.createElement(\"img\");\n\t  preload.src = url;\n\t  this.activate = (function() {\n\t    if ($__0.background)\n\t      $__0.background.parentNode.removeChild($__0.background);\n\t    $__0.background = document.createElement(\"div\");\n\t    $__0.background.classList.add(\"background\");\n\t    $__0.background.style.backgroundImage = \"url(\" + url + \")\";\n\t    slide.parentNode.appendChild($__0.background);\n\t    setTimeout(((function() {\n\t      $__0.background.classList.add(\"active\");\n\t    })).bind($__0), 1);\n\t  });\n\t  this.cleanup = (function() {\n\t    events.once($__0.background, events.vendorPrefix(\"TransitionEnd\"), (function() {\n\t      $__0.background.parentNode.removeChild($__0.background);\n\t      $__0.background = null;\n\t    }), $__0);\n\t    $__0.background.classList.remove(\"active\");\n\t  });\n\t}\n\tmodule.exports = Background;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, require) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\trequire(18);\n\trequire(30);\n\trequire(11);\n\trequire(10);\n\trequire(14);\n\trequire(28);\n\trequire(13);\n\trequire(12);\n\trequire(16);\n\trequire(15);\n\trequire(29);\n\trequire(17);\n\trequire(19);\n\trequire(31);\n\tvar CodeMirror = window.CodeMirror;\n\tvar events = require(2);\n\tvar text = require(5);\n\tvar emacs = require(8);\n\tvar Spinner = require(27);\n\tfunction Editor(slide, mode) {\n\t  var $__0 = this;\n\t  var args = slide.dataset;\n\t  var target = slide.querySelector(\".slideContainer\");\n\t  var initialCode = target.innerHTML;\n\t  var keymap = {};\n\t  $traceurRuntime.setProperty(keymap, \"Ctrl-Space\", (function() {\n\t    console.log(arguments);\n\t    this.send({key: \"Ctrl-Space\"});\n\t  }).bind(this));\n\t  $traceurRuntime.setProperty(keymap, \"Ctrl-K\", emacs.kill);\n\t  $traceurRuntime.setProperty(keymap, \"Ctrl-Y\", emacs.yank);\n\t  keymap.Tab = (function(cm) {\n\t    return cm.indentLine(cm.getDoc().getCursor().line);\n\t  });\n\t  $traceurRuntime.setProperty(keymap, \"Ctrl-\\\\\", (function(cm) {\n\t    return CodeMirror.showHint(cm);\n\t  }));\n\t  keymap.Esc = (function(cm) {\n\t    var input = document.createElement(\"input\");\n\t    input.setAttribute(\"type\", \"text\");\n\t    document.body.appendChild(input);\n\t    input.focus();\n\t    input.parentNode.removeChild(input);\n\t  });\n\t  var options = {\n\t    value: text.cleanText(initialCode),\n\t    mode: mode,\n\t    extraKeys: keymap,\n\t    lineWrapping: true,\n\t    matchBrackets: true,\n\t    autoCloseBrackets: true,\n\t    styleActiveLine: true,\n\t    theme: \"xq-light\"\n\t  };\n\t  this.send = (function(message) {\n\t    $__0.targetFrame.contentWindow.postMessage(JSON.stringify(message), \"*\");\n\t  });\n\t  this.activate = (function() {\n\t    slide.classList.add(\"editor\");\n\t    target.innerHTML = \"\";\n\t    $__0.editorFrame = document.createElement(\"div\");\n\t    $__0.editorFrame.classList.add(\"editorFrame\");\n\t    target.appendChild($__0.editorFrame);\n\t    $__0.targetContainer = document.createElement(\"div\");\n\t    $__0.targetContainer.classList.add(\"targetFrame\");\n\t    $__0.targetFrame = document.createElement(\"iframe\");\n\t    $__0.loaderFrame = document.createElement(\"div\");\n\t    $__0.loaderFrame.classList.add(\"loaderFrame\");\n\t    $__0.targetContainer.appendChild($__0.loaderFrame);\n\t    target.appendChild($__0.targetContainer);\n\t    var factor = Math.min($__0.loaderFrame.clientWidth, $__0.loaderFrame.clientHeight) / 13.25;\n\t    $__0.spinner = new Spinner({\n\t      color: \"white\",\n\t      shadow: true,\n\t      hwaccel: true,\n\t      length: factor * 2,\n\t      radius: factor * 2,\n\t      width: factor,\n\t      trail: 40,\n\t      lines: 12\n\t    }).spin($__0.loaderFrame);\n\t    $__0.cm = CodeMirror($__0.editorFrame, options);\n\t    $__0.cm.setSize(\"100%\", \"100%\");\n\t  });\n\t  this.stabilise = (function() {\n\t    $__0.targetFrame.style.display = \"none\";\n\t    $__0.targetFrame.setAttribute(\"src\", args.href);\n\t    $__0.targetContainer.appendChild($__0.targetFrame);\n\t    events.until($__0.targetFrame.contentWindow, \"message\", function(e) {\n\t      if (e.data === \"rdy lol\") {\n\t        this.spinner.stop();\n\t        this.targetFrame.style.display = \"\";\n\t        this.targetContainer.removeChild(this.loaderFrame);\n\t        this.loaderFrame = this.spinner = null;\n\t        return true;\n\t      }\n\t    }, $__0);\n\t    $__0.cm.refresh();\n\t  });\n\t  this.cleanup = (function() {\n\t    $__0.cm = null;\n\t    target.innerHTML = initialCode;\n\t    target.classList.remove(\"editor\");\n\t  });\n\t}\n\tmodule.exports = Editor;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, require) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\tvar killRing = [];\n\tfunction addToRing(str) {\n\t  killRing.push(str);\n\t  if (killRing.length > 50)\n\t    killRing.shift();\n\t}\n\tfunction growRingTop(str) {\n\t  var $__0;\n\t  if (!killRing.length)\n\t    return addToRing(str);\n\t  ($__0 = killRing.length - 1, $traceurRuntime.setProperty(killRing, $__0, killRing[$traceurRuntime.toProperty($__0)] + str));\n\t}\n\tfunction getFromRing(n) {\n\t  return killRing[$traceurRuntime.toProperty(killRing.length - (n ? Math.min(n, 1) : 1))] || \"\";\n\t}\n\tfunction popFromRing() {\n\t  if (killRing.length > 1)\n\t    killRing.pop();\n\t  return getFromRing();\n\t}\n\tvar lastKill = null;\n\tfunction posEq(a, b) {\n\t  return a.line == b.line && a.ch == b.ch;\n\t}\n\tfunction kill(cm, from, to, mayGrow, text) {\n\t  if (text == null)\n\t    text = cm.getRange(from, to);\n\t  if (mayGrow && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n\t    growRingTop(text);\n\t  else\n\t    addToRing(text);\n\t  cm.replaceRange(\"\", from, to, \"+delete\");\n\t  if (mayGrow)\n\t    lastKill = {\n\t      cm: cm,\n\t      pos: from,\n\t      gen: cm.changeGeneration()\n\t    };\n\t  else\n\t    lastKill = null;\n\t}\n\tfunction getPrefix(cm, precise) {\n\t  var digits = cm.state.emacsPrefix;\n\t  if (!digits)\n\t    return precise ? null : 1;\n\t  clearPrefix(cm);\n\t  return digits == \"-\" ? -1 : Number(digits);\n\t}\n\tvar prefixPreservingKeys = {\n\t  \"Alt-G\": true,\n\t  \"Ctrl-X\": true,\n\t  \"Ctrl-Q\": true,\n\t  \"Ctrl-U\": true\n\t};\n\tfunction maybeClearPrefix(cm, arg) {\n\t  if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n\t    clearPrefix(cm);\n\t}\n\tfunction clearPrefix(cm) {\n\t  cm.state.emacsPrefix = null;\n\t  cm.off(\"keyHandled\", maybeClearPrefix);\n\t  cm.off(\"inputRead\", maybeDuplicateInput);\n\t}\n\tfunction maybeDuplicateInput(cm, event) {\n\t  var dup = getPrefix(cm);\n\t  if (dup > 1 && event.origin == \"+input\") {\n\t    var one = event.text.join(\"\\n\"),\n\t        txt = \"\";\n\t    for (var i = 1; i < dup; ++i)\n\t      txt += one;\n\t    cm.replaceSelection(txt, \"end\", \"+input\");\n\t  }\n\t}\n\tfunction repeated(cmd) {\n\t  var f = (typeof cmd === 'undefined' ? 'undefined' : $traceurRuntime.typeof(cmd)) == \"string\" ? function(cm) {\n\t    cm.execCommand(cmd);\n\t  } : cmd;\n\t  return function(cm) {\n\t    var prefix = getPrefix(cm);\n\t    f(cm);\n\t    for (var i = 1; i < prefix; ++i)\n\t      f(cm);\n\t  };\n\t}\n\tvar killKey = repeated((function(cm) {\n\t  var start = cm.getCursor(),\n\t      end = cm.clipPos(CodeMirror.Pos(start.line));\n\t  var text = cm.getRange(start, end);\n\t  if (!/\\S/.test(text)) {\n\t    text += \"\\n\";\n\t    end = CodeMirror.Pos(start.line + 1, 0);\n\t  }\n\t  kill(cm, start, end, true, text);\n\t}));\n\tvar yankKey = (function(cm) {\n\t  var start = cm.getCursor();\n\t  cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n\t  cm.setSelection(start, cm.getCursor());\n\t});\n\tmodule.exports = {\n\t  kill: killKey,\n\t  yank: yankKey\n\t};\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, require) {\n\n\t\"use strict\";\n\tvar __moduleName = (void 0);\n\tfunction Image(slide, url) {\n\t  slide.style.backgroundImage = \"url(\" + url + \")\";\n\t}\n\tmodule.exports = Image;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, require) {\n\n\t(function() {\n\t  var DEFAULT_BRACKETS = \"()[]{}''\\\"\\\"\";\n\t  var DEFAULT_EXPLODE_ON_ENTER = \"[]{}\";\n\t  var SPACE_CHAR_REGEX = /\\s/;\n\t\n\t  CodeMirror.defineOption(\"autoCloseBrackets\", false, function(cm, val, old) {\n\t    if (old != CodeMirror.Init && old)\n\t      cm.removeKeyMap(\"autoCloseBrackets\");\n\t    if (!val) return;\n\t    var pairs = DEFAULT_BRACKETS, explode = DEFAULT_EXPLODE_ON_ENTER;\n\t    if (typeof val == \"string\") pairs = val;\n\t    else if (typeof val == \"object\") {\n\t      if (val.pairs != null) pairs = val.pairs;\n\t      if (val.explode != null) explode = val.explode;\n\t    }\n\t    var map = buildKeymap(pairs);\n\t    if (explode) map.Enter = buildExplodeHandler(explode);\n\t    cm.addKeyMap(map);\n\t  });\n\t\n\t  function charsAround(cm, pos) {\n\t    var str = cm.getRange(CodeMirror.Pos(pos.line, pos.ch - 1),\n\t                          CodeMirror.Pos(pos.line, pos.ch + 1));\n\t    return str.length == 2 ? str : null;\n\t  }\n\t\n\t  function buildKeymap(pairs) {\n\t    var map = {\n\t      name : \"autoCloseBrackets\",\n\t      Backspace: function(cm) {\n\t        if (cm.somethingSelected() || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n\t        var cur = cm.getCursor(), around = charsAround(cm, cur);\n\t        if (around && pairs.indexOf(around) % 2 == 0)\n\t          cm.replaceRange(\"\", CodeMirror.Pos(cur.line, cur.ch - 1), CodeMirror.Pos(cur.line, cur.ch + 1));\n\t        else\n\t          return CodeMirror.Pass;\n\t      }\n\t    };\n\t    var closingBrackets = \"\";\n\t    for (var i = 0; i < pairs.length; i += 2) (function(left, right) {\n\t      if (left != right) closingBrackets += right;\n\t      function surround(cm) {\n\t        var selection = cm.getSelection();\n\t        cm.replaceSelection(left + selection + right);\n\t      }\n\t      function maybeOverwrite(cm) {\n\t        var cur = cm.getCursor(), ahead = cm.getRange(cur, CodeMirror.Pos(cur.line, cur.ch + 1));\n\t        if (ahead != right || cm.somethingSelected()) return CodeMirror.Pass;\n\t        else cm.execCommand(\"goCharRight\");\n\t      }\n\t      map[\"'\" + left + \"'\"] = function(cm) {\n\t        if (left == \"'\" && cm.getTokenAt(cm.getCursor()).type == \"comment\" ||\n\t            cm.getOption(\"disableInput\"))\n\t          return CodeMirror.Pass;\n\t        if (cm.somethingSelected()) return surround(cm);\n\t        if (left == right && maybeOverwrite(cm) != CodeMirror.Pass) return;\n\t        var cur = cm.getCursor(), ahead = CodeMirror.Pos(cur.line, cur.ch + 1);\n\t        var line = cm.getLine(cur.line), nextChar = line.charAt(cur.ch), curChar = cur.ch > 0 ? line.charAt(cur.ch - 1) : \"\";\n\t        if (left == right && CodeMirror.isWordChar(curChar))\n\t          return CodeMirror.Pass;\n\t        if (line.length == cur.ch || closingBrackets.indexOf(nextChar) >= 0 || SPACE_CHAR_REGEX.test(nextChar))\n\t          cm.replaceSelection(left + right, {head: ahead, anchor: ahead});\n\t        else\n\t          return CodeMirror.Pass;\n\t      };\n\t      if (left != right) map[\"'\" + right + \"'\"] = maybeOverwrite;\n\t    })(pairs.charAt(i), pairs.charAt(i + 1));\n\t    return map;\n\t  }\n\t\n\t  function buildExplodeHandler(pairs) {\n\t    return function(cm) {\n\t      var cur = cm.getCursor(), around = charsAround(cm, cur);\n\t      if (!around || pairs.indexOf(around) % 2 != 0 || cm.getOption(\"disableInput\"))\n\t        return CodeMirror.Pass;\n\t      cm.operation(function() {\n\t        var newPos = CodeMirror.Pos(cur.line + 1, 0);\n\t        cm.replaceSelection(\"\\n\\n\", {anchor: newPos, head: newPos}, \"+input\");\n\t        cm.indentLine(cur.line + 1, null, true);\n\t        cm.indentLine(cur.line + 2, null, true);\n\t      });\n\t    };\n\t  }\n\t})();\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, require) {\n\n\t(function() {\n\t  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n\t    (document.documentMode == null || document.documentMode < 8);\n\t\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n\t  function findMatchingBracket(cm, where, strict) {\n\t    var state = cm.state.matchBrackets;\n\t    var maxScanLen = (state && state.maxScanLineLength) || 10000;\n\t    var maxScanLines = (state && state.maxScanLines) || 100;\n\t\n\t    var cur = where || cm.getCursor(), line = cm.getLineHandle(cur.line), pos = cur.ch - 1;\n\t    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n\t    if (!match) return null;\n\t    var forward = match.charAt(1) == \">\", d = forward ? 1 : -1;\n\t    if (strict && forward != (pos == cur.ch)) return null;\n\t    var style = cm.getTokenTypeAt(Pos(cur.line, pos + 1));\n\t\n\t    var stack = [line.text.charAt(pos)], re = /[(){}[\\]]/;\n\t    function scan(line, lineNo, start) {\n\t      if (!line.text) return;\n\t      var pos = forward ? 0 : line.text.length - 1, end = forward ? line.text.length : -1;\n\t      if (line.text.length > maxScanLen) return null;\n\t      if (start != null) pos = start + d;\n\t      for (; pos != end; pos += d) {\n\t        var ch = line.text.charAt(pos);\n\t        if (re.test(ch) && cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style) {\n\t          var match = matching[ch];\n\t          if (match.charAt(1) == \">\" == forward) stack.push(ch);\n\t          else if (stack.pop() != match.charAt(0)) return {pos: pos, match: false};\n\t          else if (!stack.length) return {pos: pos, match: true};\n\t        }\n\t      }\n\t    }\n\t    for (var i = cur.line, found, e = forward ? Math.min(i + maxScanLines, cm.lineCount()) : Math.max(-1, i - maxScanLines); i != e; i+=d) {\n\t      if (i == cur.line) found = scan(line, i, pos);\n\t      else found = scan(cm.getLineHandle(i), i);\n\t      if (found) break;\n\t    }\n\t    return {from: Pos(cur.line, pos), to: found && Pos(i, found.pos),\n\t            match: found && found.match, forward: forward};\n\t  }\n\t\n\t  function matchBrackets(cm, autoclear) {\n\t    // Disable brace matching in long lines, since it'll cause hugely slow updates\n\t    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n\t    var found = findMatchingBracket(cm);\n\t    if (!found || cm.getLine(found.from.line).length > maxHighlightLen ||\n\t       found.to && cm.getLine(found.to.line).length > maxHighlightLen)\n\t      return;\n\t\n\t    var style = found.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n\t    var one = cm.markText(found.from, Pos(found.from.line, found.from.ch + 1), {className: style});\n\t    var two = found.to && cm.markText(found.to, Pos(found.to.line, found.to.ch + 1), {className: style});\n\t    // Kludge to work around the IE bug from issue #1193, where text\n\t    // input stops going to the textarea whenever this fires.\n\t    if (ie_lt8 && cm.state.focused) cm.display.input.focus();\n\t    var clear = function() {\n\t      cm.operation(function() { one.clear(); two && two.clear(); });\n\t    };\n\t    if (autoclear) setTimeout(clear, 800);\n\t    else return clear;\n\t  }\n\t\n\t  var currentlyHighlighted = null;\n\t  function doMatchBrackets(cm) {\n\t    cm.operation(function() {\n\t      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n\t      if (!cm.somethingSelected()) currentlyHighlighted = matchBrackets(cm, false);\n\t    });\n\t  }\n\t\n\t  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n\t    if (old && old != CodeMirror.Init)\n\t      cm.off(\"cursorActivity\", doMatchBrackets);\n\t    if (val) {\n\t      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n\t      cm.on(\"cursorActivity\", doMatchBrackets);\n\t    }\n\t  });\n\t\n\t  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n\t  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, strict){\n\t    return findMatchingBracket(this, pos, strict);\n\t  });\n\t})();\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, require) {\n\n\t(function() {\n\t  \"use strict\";\n\t\n\t  var WORD = /[\\w$]+/, RANGE = 500;\n\t\n\t  CodeMirror.registerHelper(\"hint\", \"anyword\", function(editor, options) {\n\t    var word = options && options.word || WORD;\n\t    var range = options && options.range || RANGE;\n\t    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\n\t    var start = cur.ch, end = start;\n\t    while (end < curLine.length && word.test(curLine.charAt(end))) ++end;\n\t    while (start && word.test(curLine.charAt(start - 1))) --start;\n\t    var curWord = start != end && curLine.slice(start, end);\n\t\n\t    var list = [], seen = {};\n\t    var re = new RegExp(word.source, \"g\");\n\t    for (var dir = -1; dir <= 1; dir += 2) {\n\t      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\n\t      for (; line != endLine; line += dir) {\n\t        var text = editor.getLine(line), m;\n\t        while (m = re.exec(text)) {\n\t          if (line == cur.line && m[0] === curWord) continue;\n\t          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\n\t            seen[m[0]] = true;\n\t            list.push(m[0]);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};\n\t  });\n\t})();\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, require) {\n\n\t(function () {\n\t  var Pos = CodeMirror.Pos;\n\t\n\t  function forEach(arr, f) {\n\t    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\n\t  }\n\t\n\t  function arrayContains(arr, item) {\n\t    if (!Array.prototype.indexOf) {\n\t      var i = arr.length;\n\t      while (i--) {\n\t        if (arr[i] === item) {\n\t          return true;\n\t        }\n\t      }\n\t      return false;\n\t    }\n\t    return arr.indexOf(item) != -1;\n\t  }\n\t\n\t  function scriptHint(editor, keywords, getToken, options) {\n\t    // Find the token at the cursor\n\t    var cur = editor.getCursor(), token = getToken(editor, cur), tprop = token;\n\t    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n\t    token.state = CodeMirror.innerMode(editor.getMode(), token.state).state;\n\t\n\t    // If it's not a 'word-style' token, ignore the token.\n\t    if (!/^[\\w$_]*$/.test(token.string)) {\n\t      token = tprop = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\n\t                       type: token.string == \".\" ? \"property\" : null};\n\t    }\n\t    // If it is a property, find out what it is a property of.\n\t    while (tprop.type == \"property\") {\n\t      tprop = getToken(editor, Pos(cur.line, tprop.start));\n\t      if (tprop.string != \".\") return;\n\t      tprop = getToken(editor, Pos(cur.line, tprop.start));\n\t      if (!context) var context = [];\n\t      context.push(tprop);\n\t    }\n\t    return {list: getCompletions(token, context, keywords, options),\n\t            from: Pos(cur.line, token.start),\n\t            to: Pos(cur.line, token.end)};\n\t  }\n\t\n\t  function javascriptHint(editor, options) {\n\t    return scriptHint(editor, javascriptKeywords,\n\t                      function (e, cur) {return e.getTokenAt(cur);},\n\t                      options);\n\t  };\n\t  CodeMirror.javascriptHint = javascriptHint; // deprecated\n\t  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\t\n\t  function getCoffeeScriptToken(editor, cur) {\n\t  // This getToken, it is for coffeescript, imitates the behavior of\n\t  // getTokenAt method in javascript.js, that is, returning \"property\"\n\t  // type and treat \".\" as indepenent token.\n\t    var token = editor.getTokenAt(cur);\n\t    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n\t      token.end = token.start;\n\t      token.string = '.';\n\t      token.type = \"property\";\n\t    }\n\t    else if (/^\\.[\\w$_]*$/.test(token.string)) {\n\t      token.type = \"property\";\n\t      token.start++;\n\t      token.string = token.string.replace(/\\./, '');\n\t    }\n\t    return token;\n\t  }\n\t\n\t  function coffeescriptHint(editor, options) {\n\t    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n\t  }\n\t  CodeMirror.coffeescriptHint = coffeescriptHint; // deprecated\n\t  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n\t\n\t  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\n\t                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n\t  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\n\t                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n\t  var funcProps = \"prototype apply call bind\".split(\" \");\n\t  var javascriptKeywords = (\"break case catch continue debugger default delete do else false finally for function \" +\n\t                  \"if in instanceof new null return switch throw true try typeof var void while with\").split(\" \");\n\t  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\n\t                  \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\t\n\t  function getCompletions(token, context, keywords, options) {\n\t    var found = [], start = token.string;\n\t    function maybeAdd(str) {\n\t      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n\t    }\n\t    function gatherCompletions(obj) {\n\t      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\n\t      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\n\t      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n\t      for (var name in obj) maybeAdd(name);\n\t    }\n\t\n\t    if (context && context.length) {\n\t      // If this is a property, see if it belongs to some object we can\n\t      // find in the current environment.\n\t      var obj = context.pop(), base;\n\t      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n\t        if (options && options.additionalContext)\n\t          base = options.additionalContext[obj.string];\n\t        base = base || window[obj.string];\n\t      } else if (obj.type == \"string\") {\n\t        base = \"\";\n\t      } else if (obj.type == \"atom\") {\n\t        base = 1;\n\t      } else if (obj.type == \"function\") {\n\t        if (window.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\n\t            (typeof window.jQuery == 'function'))\n\t          base = window.jQuery();\n\t        else if (window._ != null && (obj.string == '_') && (typeof window._ == 'function'))\n\t          base = window._();\n\t      }\n\t      while (base != null && context.length)\n\t        base = base[context.pop().string];\n\t      if (base != null) gatherCompletions(base);\n\t    } else {\n\t      // If not, just look in the window object and any local scope\n\t      // (reading into JS mode internals to get at the local and global variables)\n\t      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\n\t      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\n\t      gatherCompletions(window);\n\t      forEach(keywords, maybeAdd);\n\t    }\n\t    return found;\n\t  }\n\t})();\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, require) {\n\n\t(function() {\n\t  \"use strict\";\n\t\n\t  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n\t  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\t\n\t  CodeMirror.showHint = function(cm, getHints, options) {\n\t    // We want a single cursor position.\n\t    if (cm.somethingSelected()) return;\n\t    if (getHints == null) {\n\t      if (options && options.async) return;\n\t      else getHints = CodeMirror.hint.auto;\n\t    }\n\t\n\t    if (cm.state.completionActive) cm.state.completionActive.close();\n\t\n\t    var completion = cm.state.completionActive = new Completion(cm, getHints, options || {});\n\t    CodeMirror.signal(cm, \"startCompletion\", cm);\n\t    if (completion.options.async)\n\t      getHints(cm, function(hints) { completion.showHints(hints); }, completion.options);\n\t    else\n\t      return completion.showHints(getHints(cm, completion.options));\n\t  };\n\t\n\t  function Completion(cm, getHints, options) {\n\t    this.cm = cm;\n\t    this.getHints = getHints;\n\t    this.options = options;\n\t    this.widget = this.onClose = null;\n\t  }\n\t\n\t  Completion.prototype = {\n\t    close: function() {\n\t      if (!this.active()) return;\n\t      this.cm.state.completionActive = null;\n\t\n\t      if (this.widget) this.widget.close();\n\t      if (this.onClose) this.onClose();\n\t      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n\t    },\n\t\n\t    active: function() {\n\t      return this.cm.state.completionActive == this;\n\t    },\n\t\n\t    pick: function(data, i) {\n\t      var completion = data.list[i];\n\t      if (completion.hint) completion.hint(this.cm, data, completion);\n\t      else this.cm.replaceRange(getText(completion), completion.from||data.from, completion.to||data.to);\n\t      CodeMirror.signal(data, \"pick\", completion);\n\t      this.close();\n\t    },\n\t\n\t    showHints: function(data) {\n\t      if (!data || !data.list.length || !this.active()) return this.close();\n\t\n\t      if (this.options.completeSingle != false && data.list.length == 1)\n\t        this.pick(data, 0);\n\t      else\n\t        this.showWidget(data);\n\t    },\n\t\n\t    showWidget: function(data) {\n\t      this.widget = new Widget(this, data);\n\t      CodeMirror.signal(data, \"shown\");\n\t\n\t      var debounce = 0, completion = this, finished;\n\t      var closeOn = this.options.closeCharacters || /[\\s()\\[\\]{};:>,]/;\n\t      var startPos = this.cm.getCursor(), startLen = this.cm.getLine(startPos.line).length;\n\t\n\t      var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n\t        return setTimeout(fn, 1000/60);\n\t      };\n\t      var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\t\n\t      function done() {\n\t        if (finished) return;\n\t        finished = true;\n\t        completion.close();\n\t        completion.cm.off(\"cursorActivity\", activity);\n\t        if (data) CodeMirror.signal(data, \"close\");\n\t      }\n\t\n\t      function update() {\n\t        if (finished) return;\n\t        CodeMirror.signal(data, \"update\");\n\t        if (completion.options.async)\n\t          completion.getHints(completion.cm, finishUpdate, completion.options);\n\t        else\n\t          finishUpdate(completion.getHints(completion.cm, completion.options));\n\t      }\n\t      function finishUpdate(data_) {\n\t        data = data_;\n\t        if (finished) return;\n\t        if (!data || !data.list.length) return done();\n\t        completion.widget = new Widget(completion, data);\n\t      }\n\t\n\t      function clearDebounce() {\n\t        if (debounce) {\n\t          cancelAnimationFrame(debounce);\n\t          debounce = 0;\n\t        }\n\t      }\n\t\n\t      function activity() {\n\t        clearDebounce();\n\t        var pos = completion.cm.getCursor(), line = completion.cm.getLine(pos.line);\n\t        if (pos.line != startPos.line || line.length - pos.ch != startLen - startPos.ch ||\n\t            pos.ch < startPos.ch || completion.cm.somethingSelected() ||\n\t            (pos.ch && closeOn.test(line.charAt(pos.ch - 1)))) {\n\t          completion.close();\n\t        } else {\n\t          debounce = requestAnimationFrame(update);\n\t          if (completion.widget) completion.widget.close();\n\t        }\n\t      }\n\t      this.cm.on(\"cursorActivity\", activity);\n\t      this.onClose = done;\n\t    }\n\t  };\n\t\n\t  function getText(completion) {\n\t    if (typeof completion == \"string\") return completion;\n\t    else return completion.text;\n\t  }\n\t\n\t  function buildKeyMap(options, handle) {\n\t    var baseMap = {\n\t      Up: function() {handle.moveFocus(-1);},\n\t      Down: function() {handle.moveFocus(1);},\n\t      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n\t      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n\t      Home: function() {handle.setFocus(0);},\n\t      End: function() {handle.setFocus(handle.length - 1);},\n\t      Enter: handle.pick,\n\t      Tab: handle.pick,\n\t      Esc: handle.close\n\t    };\n\t    var ourMap = options.customKeys ? {} : baseMap;\n\t    function addBinding(key, val) {\n\t      var bound;\n\t      if (typeof val != \"string\")\n\t        bound = function(cm) { return val(cm, handle); };\n\t      // This mechanism is deprecated\n\t      else if (baseMap.hasOwnProperty(val))\n\t        bound = baseMap[val];\n\t      else\n\t        bound = val;\n\t      ourMap[key] = bound;\n\t    }\n\t    if (options.customKeys)\n\t      for (var key in options.customKeys) if (options.customKeys.hasOwnProperty(key))\n\t        addBinding(key, options.customKeys[key]);\n\t    if (options.extraKeys)\n\t      for (var key in options.extraKeys) if (options.extraKeys.hasOwnProperty(key))\n\t        addBinding(key, options.extraKeys[key]);\n\t    return ourMap;\n\t  }\n\t\n\t  function getHintElement(hintsElement, el) {\n\t    while (el && el != hintsElement) {\n\t      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n\t      el = el.parentNode;\n\t    }\n\t  }\n\t\n\t  function Widget(completion, data) {\n\t    this.completion = completion;\n\t    this.data = data;\n\t    var widget = this, cm = completion.cm, options = completion.options;\n\t\n\t    var hints = this.hints = document.createElement(\"ul\");\n\t    hints.className = \"CodeMirror-hints\";\n\t    this.selectedHint = options.getDefaultSelection ? options.getDefaultSelection(cm,options,data) : 0;\n\t\n\t    var completions = data.list;\n\t    for (var i = 0; i < completions.length; ++i) {\n\t      var elt = hints.appendChild(document.createElement(\"li\")), cur = completions[i];\n\t      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n\t      if (cur.className != null) className = cur.className + \" \" + className;\n\t      elt.className = className;\n\t      if (cur.render) cur.render(elt, data, cur);\n\t      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));\n\t      elt.hintId = i;\n\t    }\n\t\n\t    var pos = cm.cursorCoords(options.alignWithWord !== false ? data.from : null);\n\t    var left = pos.left, top = pos.bottom, below = true;\n\t    hints.style.left = left + \"px\";\n\t    hints.style.top = top + \"px\";\n\t    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n\t    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);\n\t    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);\n\t    (options.container || document.body).appendChild(hints);\n\t    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;\n\t    if (overlapY > 0) {\n\t      var height = box.bottom - box.top, curTop = box.top - (pos.bottom - pos.top);\n\t      if (curTop - height > 0) { // Fits above cursor\n\t        hints.style.top = (top = curTop - height) + \"px\";\n\t        below = false;\n\t      } else if (height > winH) {\n\t        hints.style.height = (winH - 5) + \"px\";\n\t        hints.style.top = (top = pos.bottom - box.top) + \"px\";\n\t        var cursor = cm.getCursor();\n\t        if (data.from.ch != cursor.ch) {\n\t          pos = cm.cursorCoords(cursor);\n\t          hints.style.left = (left = pos.left) + \"px\";\n\t          box = hints.getBoundingClientRect();\n\t        }\n\t      }\n\t    }\n\t    var overlapX = box.left - winW;\n\t    if (overlapX > 0) {\n\t      if (box.right - box.left > winW) {\n\t        hints.style.width = (winW - 5) + \"px\";\n\t        overlapX -= (box.right - box.left) - winW;\n\t      }\n\t      hints.style.left = (left = pos.left - overlapX) + \"px\";\n\t    }\n\t\n\t    cm.addKeyMap(this.keyMap = buildKeyMap(options, {\n\t      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n\t      setFocus: function(n) { widget.changeActive(n); },\n\t      menuSize: function() { return widget.screenAmount(); },\n\t      length: completions.length,\n\t      close: function() { completion.close(); },\n\t      pick: function() { widget.pick(); },\n\t      data: data\n\t    }));\n\t\n\t    if (options.closeOnUnfocus !== false) {\n\t      var closingOnBlur;\n\t      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n\t      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n\t    }\n\t\n\t    var startScroll = cm.getScrollInfo();\n\t    cm.on(\"scroll\", this.onScroll = function() {\n\t      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n\t      var newTop = top + startScroll.top - curScroll.top;\n\t      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);\n\t      if (!below) point += hints.offsetHeight;\n\t      if (point <= editor.top || point >= editor.bottom) return completion.close();\n\t      hints.style.top = newTop + \"px\";\n\t      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n\t    });\n\t\n\t    CodeMirror.on(hints, \"dblclick\", function(e) {\n\t      var t = getHintElement(hints, e.target || e.srcElement);\n\t      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n\t    });\n\t\n\t    CodeMirror.on(hints, \"click\", function(e) {\n\t      var t = getHintElement(hints, e.target || e.srcElement);\n\t      if (t && t.hintId != null) {\n\t        widget.changeActive(t.hintId);\n\t        if (options.completeOnSingleClick) widget.pick();\n\t      }\n\t    });\n\t\n\t    CodeMirror.on(hints, \"mousedown\", function() {\n\t      setTimeout(function(){cm.focus();}, 20);\n\t    });\n\t\n\t    CodeMirror.signal(data, \"select\", completions[0], hints.firstChild);\n\t    return true;\n\t  }\n\t\n\t  Widget.prototype = {\n\t    close: function() {\n\t      if (this.completion.widget != this) return;\n\t      this.completion.widget = null;\n\t      this.hints.parentNode.removeChild(this.hints);\n\t      this.completion.cm.removeKeyMap(this.keyMap);\n\t\n\t      var cm = this.completion.cm;\n\t      if (this.completion.options.closeOnUnfocus !== false) {\n\t        cm.off(\"blur\", this.onBlur);\n\t        cm.off(\"focus\", this.onFocus);\n\t      }\n\t      cm.off(\"scroll\", this.onScroll);\n\t    },\n\t\n\t    pick: function() {\n\t      this.completion.pick(this.data, this.selectedHint);\n\t    },\n\t\n\t    changeActive: function(i, avoidWrap) {\n\t      if (i >= this.data.list.length)\n\t        i = avoidWrap ? this.data.list.length - 1 : 0;\n\t      else if (i < 0)\n\t        i = avoidWrap ? 0  : this.data.list.length - 1;\n\t      if (this.selectedHint == i) return;\n\t      var node = this.hints.childNodes[this.selectedHint];\n\t      node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n\t      node = this.hints.childNodes[this.selectedHint = i];\n\t      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n\t      if (node.offsetTop < this.hints.scrollTop)\n\t        this.hints.scrollTop = node.offsetTop - 3;\n\t      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n\t        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;\n\t      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n\t    },\n\t\n\t    screenAmount: function() {\n\t      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n\t    }\n\t  };\n\t\n\t  CodeMirror.registerHelper(\"hint\", \"auto\", function(cm, options) {\n\t    var helpers = cm.getHelpers(cm.getCursor(), \"hint\"), words;\n\t    if (helpers.length) {\n\t      for (var i = 0; i < helpers.length; i++) {\n\t        var cur = helpers[i](cm, options);\n\t        if (cur && cur.list.length) return cur;\n\t      }\n\t    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n\t      if (words) return CodeMirror.hint.fromList(cm, {words: words});\n\t    } else if (CodeMirror.hint.anyword) {\n\t      return CodeMirror.hint.anyword(cm, options);\n\t    }\n\t  });\n\t\n\t  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n\t    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n\t    var found = [];\n\t    for (var i = 0; i < options.words.length; i++) {\n\t      var word = options.words[i];\n\t      if (word.slice(0, token.string.length) == token.string)\n\t        found.push(word);\n\t    }\n\t\n\t    if (found.length) return {\n\t      list: found,\n\t      from: CodeMirror.Pos(cur.line, token.start),\n\t            to: CodeMirror.Pos(cur.line, token.end)\n\t    };\n\t  });\n\t\n\t  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n\t})();\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, require) {\n\n\t(function() {\n\t  \"use strict\";\n\t  var GUTTER_ID = \"CodeMirror-lint-markers\";\n\t  var SEVERITIES = /^(?:error|warning)$/;\n\t\n\t  function showTooltip(e, content) {\n\t    var tt = document.createElement(\"div\");\n\t    tt.className = \"CodeMirror-lint-tooltip\";\n\t    tt.appendChild(content.cloneNode(true));\n\t    document.body.appendChild(tt);\n\t\n\t    function position(e) {\n\t      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n\t      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + \"px\";\n\t      tt.style.left = (e.clientX + 5) + \"px\";\n\t    }\n\t    CodeMirror.on(document, \"mousemove\", position);\n\t    position(e);\n\t    if (tt.style.opacity != null) tt.style.opacity = 1;\n\t    return tt;\n\t  }\n\t  function rm(elt) {\n\t    if (elt.parentNode) elt.parentNode.removeChild(elt);\n\t  }\n\t  function hideTooltip(tt) {\n\t    if (!tt.parentNode) return;\n\t    if (tt.style.opacity == null) rm(tt);\n\t    tt.style.opacity = 0;\n\t    setTimeout(function() { rm(tt); }, 600);\n\t  }\n\t\n\t  function showTooltipFor(e, content, node) {\n\t    var tooltip = showTooltip(e, content);\n\t    function hide() {\n\t      CodeMirror.off(node, \"mouseout\", hide);\n\t      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n\t    }\n\t    var poll = setInterval(function() {\n\t      if (tooltip) for (var n = node;; n = n.parentNode) {\n\t        if (n == document.body) return;\n\t        if (!n) { hide(); break; }\n\t      }\n\t      if (!tooltip) return clearInterval(poll);\n\t    }, 400);\n\t    CodeMirror.on(node, \"mouseout\", hide);\n\t  }\n\t\n\t  function LintState(cm, options, hasGutter) {\n\t    this.marked = [];\n\t    this.options = options;\n\t    this.timeout = null;\n\t    this.hasGutter = hasGutter;\n\t    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n\t  }\n\t\n\t  function parseOptions(cm, options) {\n\t    if (options instanceof Function) return {getAnnotations: options};\n\t    if (!options || options === true) options = {};\n\t    if (!options.getAnnotations) options.getAnnotations = cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n\t    if (!options.getAnnotations) throw new Error(\"Required option 'getAnnotations' missing (lint addon)\");\n\t    return options;\n\t  }\n\t\n\t  function clearMarks(cm) {\n\t    var state = cm.state.lint;\n\t    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n\t    for (var i = 0; i < state.marked.length; ++i)\n\t      state.marked[i].clear();\n\t    state.marked.length = 0;\n\t  }\n\t\n\t  function makeMarker(labels, severity, multiple, tooltips) {\n\t    var marker = document.createElement(\"div\"), inner = marker;\n\t    marker.className = \"CodeMirror-lint-marker-\" + severity;\n\t    if (multiple) {\n\t      inner = marker.appendChild(document.createElement(\"div\"));\n\t      inner.className = \"CodeMirror-lint-marker-multiple\";\n\t    }\n\t\n\t    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n\t      showTooltipFor(e, labels, inner);\n\t    });\n\t\n\t    return marker;\n\t  }\n\t\n\t  function getMaxSeverity(a, b) {\n\t    if (a == \"error\") return a;\n\t    else return b;\n\t  }\n\t\n\t  function groupByLine(annotations) {\n\t    var lines = [];\n\t    for (var i = 0; i < annotations.length; ++i) {\n\t      var ann = annotations[i], line = ann.from.line;\n\t      (lines[line] || (lines[line] = [])).push(ann);\n\t    }\n\t    return lines;\n\t  }\n\t\n\t  function annotationTooltip(ann) {\n\t    var severity = ann.severity;\n\t    if (!SEVERITIES.test(severity)) severity = \"error\";\n\t    var tip = document.createElement(\"div\");\n\t    tip.className = \"CodeMirror-lint-message-\" + severity;\n\t    tip.appendChild(document.createTextNode(ann.message));\n\t    return tip;\n\t  }\n\t\n\t  function startLinting(cm) {\n\t    var state = cm.state.lint, options = state.options;\n\t    if (options.async)\n\t      options.getAnnotations(cm, updateLinting, options);\n\t    else\n\t      updateLinting(cm, options.getAnnotations(cm.getValue(), options.options));\n\t  }\n\t\n\t  function updateLinting(cm, annotationsNotSorted) {\n\t    clearMarks(cm);\n\t    var state = cm.state.lint, options = state.options;\n\t\n\t    var annotations = groupByLine(annotationsNotSorted);\n\t\n\t    for (var line = 0; line < annotations.length; ++line) {\n\t      var anns = annotations[line];\n\t      if (!anns) continue;\n\t\n\t      var maxSeverity = null;\n\t      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\t\n\t      for (var i = 0; i < anns.length; ++i) {\n\t        var ann = anns[i];\n\t        var severity = ann.severity;\n\t        if (!SEVERITIES.test(severity)) severity = \"error\";\n\t        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\t\n\t        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n\t        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\t\n\t        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n\t          className: \"CodeMirror-lint-mark-\" + severity,\n\t          __annotation: ann\n\t        }));\n\t      }\n\t\n\t      if (state.hasGutter)\n\t        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,\n\t                                                       state.options.tooltips));\n\t    }\n\t    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n\t  }\n\t\n\t  function onChange(cm) {\n\t    var state = cm.state.lint;\n\t    clearTimeout(state.timeout);\n\t    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);\n\t  }\n\t\n\t  function popupSpanTooltip(ann, e) {\n\t    var target = e.target || e.srcElement;\n\t    showTooltipFor(e, annotationTooltip(ann), target);\n\t  }\n\t\n\t  // When the mouseover fires, the cursor might not actually be over\n\t  // the character itself yet. These pairs of x,y offsets are used to\n\t  // probe a few nearby points when no suitable marked range is found.\n\t  var nearby = [0, 0, 0, 5, 0, -5, 5, 0, -5, 0];\n\t\n\t  function onMouseOver(cm, e) {\n\t    if (!/\\bCodeMirror-lint-mark-/.test((e.target || e.srcElement).className)) return;\n\t    for (var i = 0; i < nearby.length; i += 2) {\n\t      var spans = cm.findMarksAt(cm.coordsChar({left: e.clientX + nearby[i],\n\t                                                top: e.clientY + nearby[i + 1]}));\n\t      for (var j = 0; j < spans.length; ++j) {\n\t        var span = spans[j], ann = span.__annotation;\n\t        if (ann) return popupSpanTooltip(ann, e);\n\t      }\n\t    }\n\t  }\n\t\n\t  function optionHandler(cm, val, old) {\n\t    if (old && old != CodeMirror.Init) {\n\t      clearMarks(cm);\n\t      cm.off(\"change\", onChange);\n\t      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n\t      delete cm.state.lint;\n\t    }\n\t\n\t    if (val) {\n\t      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n\t      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n\t      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);\n\t      cm.on(\"change\", onChange);\n\t      if (state.options.tooltips != false)\n\t        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\t\n\t      startLinting(cm);\n\t    }\n\t  }\n\t\n\t  CodeMirror.defineOption(\"lintWith\", false, optionHandler); // deprecated\n\t  CodeMirror.defineOption(\"lint\", false, optionHandler); // deprecated\n\t})();\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, require) {\n\n\t// Highlighting text that matches the selection\n\t//\n\t// Defines an option highlightSelectionMatches, which, when enabled,\n\t// will style strings that match the selection throughout the\n\t// document.\n\t//\n\t// The option can be set to true to simply enable it, or to a\n\t// {minChars, style, showToken} object to explicitly configure it.\n\t// minChars is the minimum amount of characters that should be\n\t// selected for the behavior to occur, and style is the token style to\n\t// apply to the matches. This will be prefixed by \"cm-\" to create an\n\t// actual CSS class name. showToken, when enabled, will cause the\n\t// current token to be highlighted when nothing is selected.\n\t\n\t(function() {\n\t  var DEFAULT_MIN_CHARS = 2;\n\t  var DEFAULT_TOKEN_STYLE = \"matchhighlight\";\n\t  var DEFAULT_DELAY = 100;\n\t\n\t  function State(options) {\n\t    if (typeof options == \"object\") {\n\t      this.minChars = options.minChars;\n\t      this.style = options.style;\n\t      this.showToken = options.showToken;\n\t      this.delay = options.delay;\n\t    }\n\t    if (this.style == null) this.style = DEFAULT_TOKEN_STYLE;\n\t    if (this.minChars == null) this.minChars = DEFAULT_MIN_CHARS;\n\t    if (this.delay == null) this.delay = DEFAULT_DELAY;\n\t    this.overlay = this.timeout = null;\n\t  }\n\t\n\t  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\n\t    if (old && old != CodeMirror.Init) {\n\t      var over = cm.state.matchHighlighter.overlay;\n\t      if (over) cm.removeOverlay(over);\n\t      clearTimeout(cm.state.matchHighlighter.timeout);\n\t      cm.state.matchHighlighter = null;\n\t      cm.off(\"cursorActivity\", cursorActivity);\n\t    }\n\t    if (val) {\n\t      cm.state.matchHighlighter = new State(val);\n\t      highlightMatches(cm);\n\t      cm.on(\"cursorActivity\", cursorActivity);\n\t    }\n\t  });\n\t\n\t  function cursorActivity(cm) {\n\t    var state = cm.state.matchHighlighter;\n\t    clearTimeout(state.timeout);\n\t    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.delay);\n\t  }\n\t\n\t  function highlightMatches(cm) {\n\t    cm.operation(function() {\n\t      var state = cm.state.matchHighlighter;\n\t      if (state.overlay) {\n\t        cm.removeOverlay(state.overlay);\n\t        state.overlay = null;\n\t      }\n\t      if (!cm.somethingSelected() && state.showToken) {\n\t        var re = state.showToken === true ? /[\\w$]/ : state.showToken;\n\t        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\n\t        while (start && re.test(line.charAt(start - 1))) --start;\n\t        while (end < line.length && re.test(line.charAt(end))) ++end;\n\t        if (start < end)\n\t          cm.addOverlay(state.overlay = makeOverlay(line.slice(start, end), re, state.style));\n\t        return;\n\t      }\n\t      if (cm.getCursor(\"head\").line != cm.getCursor(\"anchor\").line) return;\n\t      var selection = cm.getSelection().replace(/^\\s+|\\s+$/g, \"\");\n\t      if (selection.length >= state.minChars)\n\t        cm.addOverlay(state.overlay = makeOverlay(selection, false, state.style));\n\t    });\n\t  }\n\t\n\t  function boundariesAround(stream, re) {\n\t    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\n\t      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n\t  }\n\t\n\t  function makeOverlay(query, hasBoundary, style) {\n\t    return {token: function(stream) {\n\t      if (stream.match(query) &&\n\t          (!hasBoundary || boundariesAround(stream, hasBoundary)))\n\t        return style;\n\t      stream.next();\n\t      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n\t    }};\n\t  }\n\t})();\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, require) {\n\n\t// Because sometimes you need to style the cursor's line.\n\t//\n\t// Adds an option 'styleActiveLine' which, when enabled, gives the\n\t// active line's wrapping <div> the CSS class \"CodeMirror-activeline\",\n\t// and gives its background <div> the class \"CodeMirror-activeline-background\".\n\t\n\t(function() {\n\t  \"use strict\";\n\t  var WRAP_CLASS = \"CodeMirror-activeline\";\n\t  var BACK_CLASS = \"CodeMirror-activeline-background\";\n\t\n\t  CodeMirror.defineOption(\"styleActiveLine\", false, function(cm, val, old) {\n\t    var prev = old && old != CodeMirror.Init;\n\t    if (val && !prev) {\n\t      updateActiveLine(cm, cm.getCursor().line);\n\t      cm.on(\"beforeSelectionChange\", selectionChange);\n\t    } else if (!val && prev) {\n\t      cm.off(\"beforeSelectionChange\", selectionChange);\n\t      clearActiveLine(cm);\n\t      delete cm.state.activeLine;\n\t    }\n\t  });\n\t\n\t  function clearActiveLine(cm) {\n\t    if (\"activeLine\" in cm.state) {\n\t      cm.removeLineClass(cm.state.activeLine, \"wrap\", WRAP_CLASS);\n\t      cm.removeLineClass(cm.state.activeLine, \"background\", BACK_CLASS);\n\t    }\n\t  }\n\t\n\t  function updateActiveLine(cm, selectedLine) {\n\t    var line = cm.getLineHandleVisualStart(selectedLine);\n\t    if (cm.state.activeLine == line) return;\n\t    cm.operation(function() {\n\t      clearActiveLine(cm);\n\t      cm.addLineClass(line, \"wrap\", WRAP_CLASS);\n\t      cm.addLineClass(line, \"background\", BACK_CLASS);\n\t      cm.state.activeLine = line;\n\t    });\n\t  }\n\t\n\t  function selectionChange(cm, sel) {\n\t    updateActiveLine(cm, sel.head.line);\n\t  }\n\t})();\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, require) {\n\n\t// CodeMirror is the only global var we claim\n\twindow.CodeMirror = (function() {\n\t  \"use strict\";\n\t\n\t  // BROWSER SNIFFING\n\t\n\t  // Crude, but necessary to handle a number of hard-to-feature-detect\n\t  // bugs and behavior differences.\n\t  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\n\t  // IE11 currently doesn't count as 'ie', since it has almost none of\n\t  // the same bugs as earlier versions. Use ie_gt10 to handle\n\t  // incompatibilities in that version.\n\t  var old_ie = /MSIE \\d/.test(navigator.userAgent);\n\t  var ie_lt8 = old_ie && (document.documentMode == null || document.documentMode < 8);\n\t  var ie_lt9 = old_ie && (document.documentMode == null || document.documentMode < 9);\n\t  var ie_lt10 = old_ie && (document.documentMode == null || document.documentMode < 10);\n\t  var ie_gt10 = /Trident\\/([7-9]|\\d{2,})\\./.test(navigator.userAgent);\n\t  var ie = old_ie || ie_gt10;\n\t  var webkit = /WebKit\\//.test(navigator.userAgent);\n\t  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\n\t  var chrome = /Chrome\\//.test(navigator.userAgent);\n\t  var opera = /Opera\\//.test(navigator.userAgent);\n\t  var safari = /Apple Computer/.test(navigator.vendor);\n\t  var khtml = /KHTML\\//.test(navigator.userAgent);\n\t  var mac_geLion = /Mac OS X 1\\d\\D([7-9]|\\d\\d)\\D/.test(navigator.userAgent);\n\t  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\n\t  var phantom = /PhantomJS/.test(navigator.userAgent);\n\t\n\t  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n\t  // This is woefully incomplete. Suggestions for alternative methods welcome.\n\t  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\n\t  var mac = ios || /Mac/.test(navigator.platform);\n\t  var windows = /win/i.test(navigator.platform);\n\t\n\t  var opera_version = opera && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n\t  if (opera_version) opera_version = Number(opera_version[1]);\n\t  if (opera_version && opera_version >= 15) { opera = false; webkit = true; }\n\t  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n\t  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));\n\t  var captureMiddleClick = gecko || (ie && !ie_lt9);\n\t\n\t  // Optimize some code when these features are not used\n\t  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\t\n\t  // CONSTRUCTOR\n\t\n\t  function CodeMirror(place, options) {\n\t    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\t\n\t    this.options = options = options || {};\n\t    // Determine effective options based on given values and defaults.\n\t    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))\n\t      options[opt] = defaults[opt];\n\t    setGuttersForLineNumbers(options);\n\t\n\t    var docStart = typeof options.value == \"string\" ? 0 : options.value.first;\n\t    var display = this.display = makeDisplay(place, docStart);\n\t    display.wrapper.CodeMirror = this;\n\t    updateGutters(this);\n\t    if (options.autofocus && !mobile) focusInput(this);\n\t\n\t    this.state = {keyMaps: [],\n\t                  overlays: [],\n\t                  modeGen: 0,\n\t                  overwrite: false, focused: false,\n\t                  suppressEdits: false,\n\t                  pasteIncoming: false, cutIncoming: false,\n\t                  draggingText: false,\n\t                  highlight: new Delayed()};\n\t\n\t    themeChanged(this);\n\t    if (options.lineWrapping)\n\t      this.display.wrapper.className += \" CodeMirror-wrap\";\n\t\n\t    var doc = options.value;\n\t    if (typeof doc == \"string\") doc = new Doc(options.value, options.mode);\n\t    operation(this, attachDoc)(this, doc);\n\t\n\t    // Override magic textarea content restore that IE sometimes does\n\t    // on our hidden textarea on reload\n\t    if (old_ie) setTimeout(bind(resetInput, this, true), 20);\n\t\n\t    registerEventHandlers(this);\n\t    // IE throws unspecified error in certain cases, when\n\t    // trying to access activeElement before onload\n\t    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }\n\t    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);\n\t    else onBlur(this);\n\t\n\t    operation(this, function() {\n\t      for (var opt in optionHandlers)\n\t        if (optionHandlers.propertyIsEnumerable(opt))\n\t          optionHandlers[opt](this, options[opt], Init);\n\t      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n\t    })();\n\t  }\n\t\n\t  // DISPLAY CONSTRUCTOR\n\t\n\t  function makeDisplay(place, docStart) {\n\t    var d = {};\n\t\n\t    var input = d.input = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n\t    if (webkit) input.style.width = \"1000px\";\n\t    else input.setAttribute(\"wrap\", \"off\");\n\t    // if border: 0; -- iOS fails to open keyboard (issue #1287)\n\t    if (ios) input.style.border = \"1px solid black\";\n\t    input.setAttribute(\"autocorrect\", \"off\"); input.setAttribute(\"autocapitalize\", \"off\"); input.setAttribute(\"spellcheck\", \"false\");\n\t\n\t    // Wraps and hides input textarea\n\t    d.inputDiv = elt(\"div\", [input], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n\t    // The actual fake scrollbars.\n\t    d.scrollbarH = elt(\"div\", [elt(\"div\", null, null, \"height: 1px\")], \"CodeMirror-hscrollbar\");\n\t    d.scrollbarV = elt(\"div\", [elt(\"div\", null, null, \"width: 1px\")], \"CodeMirror-vscrollbar\");\n\t    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n\t    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n\t    // DIVs containing the selection and the actual code\n\t    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n\t    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n\t    // Blinky cursor, and element used to ensure cursor fits at the end of a line\n\t    d.cursor = elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\");\n\t    // Secondary cursor, shown when on a 'jump' in bi-directional text\n\t    d.otherCursor = elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\");\n\t    // Used to measure text size\n\t    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n\t    d.lineSpace = elt(\"div\", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],\n\t                         null, \"position: relative; outline: none\");\n\t    // Moved around its parent to cover visible view\n\t    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n\t    // Set to the height of the text, causes scrolling\n\t    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n\t    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers\n\t    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerCutOff + \"px; width: 1px;\");\n\t    // Will contain the gutters, if any\n\t    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n\t    d.lineGutter = null;\n\t    // Provides scrolling\n\t    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n\t    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n\t    // The element in which the editor lives.\n\t    d.wrapper = elt(\"div\", [d.inputDiv, d.scrollbarH, d.scrollbarV,\n\t                            d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\t    // Work around IE7 z-index bug\n\t    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n\t    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);\n\t\n\t    // Needed to hide big blue blinking cursor on Mobile Safari\n\t    if (ios) input.style.width = \"0px\";\n\t    if (!webkit) d.scroller.draggable = true;\n\t    // Needed to handle Tab key in KHTML\n\t    if (khtml) { d.inputDiv.style.height = \"1px\"; d.inputDiv.style.position = \"absolute\"; }\n\t    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n\t    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = \"18px\";\n\t\n\t    // Current visible range (may be bigger than the view window).\n\t    d.viewOffset = d.lastSizeC = 0;\n\t    d.showingFrom = d.showingTo = docStart;\n\t\n\t    // Used to only resize the line number gutter when necessary (when\n\t    // the amount of lines crosses a boundary that makes its width change)\n\t    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n\t    // See readInput and resetInput\n\t    d.prevInput = \"\";\n\t    // Set to true when a non-horizontal-scrolling widget is added. As\n\t    // an optimization, widget aligning is skipped when d is false.\n\t    d.alignWidgets = false;\n\t    // Flag that indicates whether we currently expect input to appear\n\t    // (after some event like 'keypress' or 'input') and are polling\n\t    // intensively.\n\t    d.pollingFast = false;\n\t    // Self-resetting timeout for the poller\n\t    d.poll = new Delayed();\n\t\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t    d.measureLineCache = [];\n\t    d.measureLineCachePos = 0;\n\t\n\t    // Tracks when resetInput has punted to just putting a short\n\t    // string instead of the (large) selection.\n\t    d.inaccurateSelection = false;\n\t\n\t    // Tracks the maximum line length so that the horizontal scrollbar\n\t    // can be kept static when scrolling.\n\t    d.maxLine = null;\n\t    d.maxLineLength = 0;\n\t    d.maxLineChanged = false;\n\t\n\t    // Used for measuring wheel scrolling granularity\n\t    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\t\n\t    return d;\n\t  }\n\t\n\t  // STATE UPDATES\n\t\n\t  // Used to get the editor into a consistent state again when options change.\n\t\n\t  function loadMode(cm) {\n\t    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n\t    resetModeState(cm);\n\t  }\n\t\n\t  function resetModeState(cm) {\n\t    cm.doc.iter(function(line) {\n\t      if (line.stateAfter) line.stateAfter = null;\n\t      if (line.styles) line.styles = null;\n\t    });\n\t    cm.doc.frontier = cm.doc.first;\n\t    startWorker(cm, 100);\n\t    cm.state.modeGen++;\n\t    if (cm.curOp) regChange(cm);\n\t  }\n\t\n\t  function wrappingChanged(cm) {\n\t    if (cm.options.lineWrapping) {\n\t      cm.display.wrapper.className += \" CodeMirror-wrap\";\n\t      cm.display.sizer.style.minWidth = \"\";\n\t    } else {\n\t      cm.display.wrapper.className = cm.display.wrapper.className.replace(\" CodeMirror-wrap\", \"\");\n\t      computeMaxLength(cm);\n\t    }\n\t    estimateLineHeights(cm);\n\t    regChange(cm);\n\t    clearCaches(cm);\n\t    setTimeout(function(){updateScrollbars(cm);}, 100);\n\t  }\n\t\n\t  function estimateHeight(cm) {\n\t    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n\t    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n\t    return function(line) {\n\t      if (lineIsHidden(cm.doc, line))\n\t        return 0;\n\t      else if (wrapping)\n\t        return (Math.ceil(line.text.length / perLine) || 1) * th;\n\t      else\n\t        return th;\n\t    };\n\t  }\n\t\n\t  function estimateLineHeights(cm) {\n\t    var doc = cm.doc, est = estimateHeight(cm);\n\t    doc.iter(function(line) {\n\t      var estHeight = est(line);\n\t      if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t    });\n\t  }\n\t\n\t  function keyMapChanged(cm) {\n\t    var map = keyMap[cm.options.keyMap], style = map.style;\n\t    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, \"\") +\n\t      (style ? \" cm-keymap-\" + style : \"\");\n\t  }\n\t\n\t  function themeChanged(cm) {\n\t    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n\t      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n\t    clearCaches(cm);\n\t  }\n\t\n\t  function guttersChanged(cm) {\n\t    updateGutters(cm);\n\t    regChange(cm);\n\t    setTimeout(function(){alignHorizontally(cm);}, 20);\n\t  }\n\t\n\t  function updateGutters(cm) {\n\t    var gutters = cm.display.gutters, specs = cm.options.gutters;\n\t    removeChildren(gutters);\n\t    for (var i = 0; i < specs.length; ++i) {\n\t      var gutterClass = specs[i];\n\t      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n\t      if (gutterClass == \"CodeMirror-linenumbers\") {\n\t        cm.display.lineGutter = gElt;\n\t        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n\t      }\n\t    }\n\t    gutters.style.display = i ? \"\" : \"none\";\n\t  }\n\t\n\t  function lineLength(doc, line) {\n\t    if (line.height == 0) return 0;\n\t    var len = line.text.length, merged, cur = line;\n\t    while (merged = collapsedSpanAtStart(cur)) {\n\t      var found = merged.find();\n\t      cur = getLine(doc, found.from.line);\n\t      len += found.from.ch - found.to.ch;\n\t    }\n\t    cur = line;\n\t    while (merged = collapsedSpanAtEnd(cur)) {\n\t      var found = merged.find();\n\t      len -= cur.text.length - found.from.ch;\n\t      cur = getLine(doc, found.to.line);\n\t      len += cur.text.length - found.to.ch;\n\t    }\n\t    return len;\n\t  }\n\t\n\t  function computeMaxLength(cm) {\n\t    var d = cm.display, doc = cm.doc;\n\t    d.maxLine = getLine(doc, doc.first);\n\t    d.maxLineLength = lineLength(doc, d.maxLine);\n\t    d.maxLineChanged = true;\n\t    doc.iter(function(line) {\n\t      var len = lineLength(doc, line);\n\t      if (len > d.maxLineLength) {\n\t        d.maxLineLength = len;\n\t        d.maxLine = line;\n\t      }\n\t    });\n\t  }\n\t\n\t  // Make sure the gutters options contains the element\n\t  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n\t  function setGuttersForLineNumbers(options) {\n\t    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n\t    if (found == -1 && options.lineNumbers) {\n\t      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n\t    } else if (found > -1 && !options.lineNumbers) {\n\t      options.gutters = options.gutters.slice(0);\n\t      options.gutters.splice(found, 1);\n\t    }\n\t  }\n\t\n\t  // SCROLLBARS\n\t\n\t  // Re-synchronize the fake scrollbars with the actual size of the\n\t  // content. Optionally force a scrollTop.\n\t  function updateScrollbars(cm) {\n\t    var d = cm.display, docHeight = cm.doc.height;\n\t    var totalHeight = docHeight + paddingVert(d);\n\t    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + \"px\";\n\t    d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + \"px\";\n\t    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);\n\t    var needsH = d.scroller.scrollWidth > (d.scroller.clientWidth + 1);\n\t    var needsV = scrollHeight > (d.scroller.clientHeight + 1);\n\t    if (needsV) {\n\t      d.scrollbarV.style.display = \"block\";\n\t      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + \"px\" : \"0\";\n\t      // A bug in IE8 can cause this value to be negative, so guard it.\n\t      d.scrollbarV.firstChild.style.height =\n\t        Math.max(0, scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + \"px\";\n\t    } else {\n\t      d.scrollbarV.style.display = \"\";\n\t      d.scrollbarV.firstChild.style.height = \"0\";\n\t    }\n\t    if (needsH) {\n\t      d.scrollbarH.style.display = \"block\";\n\t      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + \"px\" : \"0\";\n\t      d.scrollbarH.firstChild.style.width =\n\t        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + \"px\";\n\t    } else {\n\t      d.scrollbarH.style.display = \"\";\n\t      d.scrollbarH.firstChild.style.width = \"0\";\n\t    }\n\t    if (needsH && needsV) {\n\t      d.scrollbarFiller.style.display = \"block\";\n\t      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + \"px\";\n\t    } else d.scrollbarFiller.style.display = \"\";\n\t    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n\t      d.gutterFiller.style.display = \"block\";\n\t      d.gutterFiller.style.height = scrollbarWidth(d.measure) + \"px\";\n\t      d.gutterFiller.style.width = d.gutters.offsetWidth + \"px\";\n\t    } else d.gutterFiller.style.display = \"\";\n\t\n\t    if (mac_geLion && scrollbarWidth(d.measure) === 0) {\n\t      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? \"18px\" : \"12px\";\n\t      d.scrollbarV.style.pointerEvents = d.scrollbarH.style.pointerEvents = \"none\";\n\t    }\n\t  }\n\t\n\t  function visibleLines(display, doc, viewPort) {\n\t    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;\n\t    if (typeof viewPort == \"number\") top = viewPort;\n\t    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}\n\t    top = Math.floor(top - paddingTop(display));\n\t    var bottom = Math.ceil(top + height);\n\t    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};\n\t  }\n\t\n\t  // LINE NUMBERS\n\t\n\t  function alignHorizontally(cm) {\n\t    var display = cm.display;\n\t    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n\t    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n\t    var gutterW = display.gutters.offsetWidth, l = comp + \"px\";\n\t    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {\n\t      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;\n\t    }\n\t    if (cm.options.fixedGutter)\n\t      display.gutters.style.left = (comp + gutterW) + \"px\";\n\t  }\n\t\n\t  function maybeUpdateLineNumberWidth(cm) {\n\t    if (!cm.options.lineNumbers) return false;\n\t    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n\t    if (last.length != display.lineNumChars) {\n\t      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n\t                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n\t      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n\t      display.lineGutter.style.width = \"\";\n\t      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\n\t      display.lineNumWidth = display.lineNumInnerWidth + padding;\n\t      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n\t      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function lineNumberFor(options, i) {\n\t    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n\t  }\n\t  function compensateForHScroll(display) {\n\t    return getRect(display.scroller).left - getRect(display.sizer).left;\n\t  }\n\t\n\t  // DISPLAY DRAWING\n\t\n\t  function updateDisplay(cm, changes, viewPort, forced) {\n\t    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;\n\t    var visible = visibleLines(cm.display, cm.doc, viewPort);\n\t    for (var first = true;; first = false) {\n\t      var oldWidth = cm.display.scroller.clientWidth;\n\t      if (!updateDisplayInner(cm, changes, visible, forced)) break;\n\t      updated = true;\n\t      changes = [];\n\t      updateSelection(cm);\n\t      updateScrollbars(cm);\n\t      if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {\n\t        forced = true;\n\t        continue;\n\t      }\n\t      forced = false;\n\t\n\t      // Clip forced viewport to actual scrollable area\n\t      if (viewPort)\n\t        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight,\n\t                            typeof viewPort == \"number\" ? viewPort : viewPort.top);\n\t      visible = visibleLines(cm.display, cm.doc, viewPort);\n\t      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)\n\t        break;\n\t    }\n\t\n\t    if (updated) {\n\t      signalLater(cm, \"update\", cm);\n\t      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)\n\t        signalLater(cm, \"viewportChange\", cm, cm.display.showingFrom, cm.display.showingTo);\n\t    }\n\t    return updated;\n\t  }\n\t\n\t  // Uses a set of changes plus the current scroll position to\n\t  // determine which DOM updates have to be made, and makes the\n\t  // updates.\n\t  function updateDisplayInner(cm, changes, visible, forced) {\n\t    var display = cm.display, doc = cm.doc;\n\t    if (!display.wrapper.offsetWidth) {\n\t      display.showingFrom = display.showingTo = doc.first;\n\t      display.viewOffset = 0;\n\t      return;\n\t    }\n\t\n\t    // Bail out if the visible area is already rendered and nothing changed.\n\t    if (!forced && changes.length == 0 &&\n\t        visible.from > display.showingFrom && visible.to < display.showingTo)\n\t      return;\n\t\n\t    if (maybeUpdateLineNumberWidth(cm))\n\t      changes = [{from: doc.first, to: doc.first + doc.size}];\n\t    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + \"px\";\n\t    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : \"0\";\n\t\n\t    // Used to determine which lines need their line numbers updated\n\t    var positionsChangedFrom = Infinity;\n\t    if (cm.options.lineNumbers)\n\t      for (var i = 0; i < changes.length; ++i)\n\t        if (changes[i].diff && changes[i].from < positionsChangedFrom) { positionsChangedFrom = changes[i].from; }\n\t\n\t    var end = doc.first + doc.size;\n\t    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);\n\t    var to = Math.min(end, visible.to + cm.options.viewportMargin);\n\t    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);\n\t    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);\n\t    if (sawCollapsedSpans) {\n\t      from = lineNo(visualLine(doc, getLine(doc, from)));\n\t      while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;\n\t    }\n\t\n\t    // Create a range of theoretically intact lines, and punch holes\n\t    // in that using the change info.\n\t    var intact = [{from: Math.max(display.showingFrom, doc.first),\n\t                   to: Math.min(display.showingTo, end)}];\n\t    if (intact[0].from >= intact[0].to) intact = [];\n\t    else intact = computeIntact(intact, changes);\n\t    // When merged lines are present, we might have to reduce the\n\t    // intact ranges because changes in continued fragments of the\n\t    // intact lines do require the lines to be redrawn.\n\t    if (sawCollapsedSpans)\n\t      for (var i = 0; i < intact.length; ++i) {\n\t        var range = intact[i], merged;\n\t        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {\n\t          var newTo = merged.find().from.line;\n\t          if (newTo > range.from) range.to = newTo;\n\t          else { intact.splice(i--, 1); break; }\n\t        }\n\t      }\n\t\n\t    // Clip off the parts that won't be visible\n\t    var intactLines = 0;\n\t    for (var i = 0; i < intact.length; ++i) {\n\t      var range = intact[i];\n\t      if (range.from < from) range.from = from;\n\t      if (range.to > to) range.to = to;\n\t      if (range.from >= range.to) intact.splice(i--, 1);\n\t      else intactLines += range.to - range.from;\n\t    }\n\t    if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) {\n\t      updateViewOffset(cm);\n\t      return;\n\t    }\n\t    intact.sort(function(a, b) {return a.from - b.from;});\n\t\n\t    // Avoid crashing on IE's \"unspecified error\" when in iframes\n\t    try {\n\t      var focused = document.activeElement;\n\t    } catch(e) {}\n\t    if (intactLines < (to - from) * .7) display.lineDiv.style.display = \"none\";\n\t    patchDisplay(cm, from, to, intact, positionsChangedFrom);\n\t    display.lineDiv.style.display = \"\";\n\t    if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();\n\t\n\t    var different = from != display.showingFrom || to != display.showingTo ||\n\t      display.lastSizeC != display.wrapper.clientHeight;\n\t    // This is just a bogus formula that detects when the editor is\n\t    // resized or the font size changes.\n\t    if (different) {\n\t      display.lastSizeC = display.wrapper.clientHeight;\n\t      startWorker(cm, 400);\n\t    }\n\t    display.showingFrom = from; display.showingTo = to;\n\t\n\t    display.gutters.style.height = \"\";\n\t    updateHeightsInViewport(cm);\n\t    updateViewOffset(cm);\n\t\n\t    return true;\n\t  }\n\t\n\t  function updateHeightsInViewport(cm) {\n\t    var display = cm.display;\n\t    var prevBottom = display.lineDiv.offsetTop;\n\t    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {\n\t      if (ie_lt8) {\n\t        var bot = node.offsetTop + node.offsetHeight;\n\t        height = bot - prevBottom;\n\t        prevBottom = bot;\n\t      } else {\n\t        var box = getRect(node);\n\t        height = box.bottom - box.top;\n\t      }\n\t      var diff = node.lineObj.height - height;\n\t      if (height < 2) height = textHeight(display);\n\t      if (diff > .001 || diff < -.001) {\n\t        updateLineHeight(node.lineObj, height);\n\t        var widgets = node.lineObj.widgets;\n\t        if (widgets) for (var i = 0; i < widgets.length; ++i)\n\t          widgets[i].height = widgets[i].node.offsetHeight;\n\t      }\n\t    }\n\t  }\n\t\n\t  function updateViewOffset(cm) {\n\t    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));\n\t    // Position the mover div to align with the current virtual scroll position\n\t    cm.display.mover.style.top = off + \"px\";\n\t  }\n\t\n\t  function computeIntact(intact, changes) {\n\t    for (var i = 0, l = changes.length || 0; i < l; ++i) {\n\t      var change = changes[i], intact2 = [], diff = change.diff || 0;\n\t      for (var j = 0, l2 = intact.length; j < l2; ++j) {\n\t        var range = intact[j];\n\t        if (change.to <= range.from && change.diff) {\n\t          intact2.push({from: range.from + diff, to: range.to + diff});\n\t        } else if (change.to <= range.from || change.from >= range.to) {\n\t          intact2.push(range);\n\t        } else {\n\t          if (change.from > range.from)\n\t            intact2.push({from: range.from, to: change.from});\n\t          if (change.to < range.to)\n\t            intact2.push({from: change.to + diff, to: range.to + diff});\n\t        }\n\t      }\n\t      intact = intact2;\n\t    }\n\t    return intact;\n\t  }\n\t\n\t  function getDimensions(cm) {\n\t    var d = cm.display, left = {}, width = {};\n\t    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n\t      left[cm.options.gutters[i]] = n.offsetLeft;\n\t      width[cm.options.gutters[i]] = n.offsetWidth;\n\t    }\n\t    return {fixedPos: compensateForHScroll(d),\n\t            gutterTotalWidth: d.gutters.offsetWidth,\n\t            gutterLeft: left,\n\t            gutterWidth: width,\n\t            wrapperWidth: d.wrapper.clientWidth};\n\t  }\n\t\n\t  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {\n\t    var dims = getDimensions(cm);\n\t    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n\t    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))\n\t      removeChildren(display.lineDiv);\n\t    var container = display.lineDiv, cur = container.firstChild;\n\t\n\t    function rm(node) {\n\t      var next = node.nextSibling;\n\t      if (webkit && mac && cm.display.currentWheelTarget == node) {\n\t        node.style.display = \"none\";\n\t        node.lineObj = null;\n\t      } else {\n\t        node.parentNode.removeChild(node);\n\t      }\n\t      return next;\n\t    }\n\t\n\t    var nextIntact = intact.shift(), lineN = from;\n\t    cm.doc.iter(from, to, function(line) {\n\t      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();\n\t      if (lineIsHidden(cm.doc, line)) {\n\t        if (line.height != 0) updateLineHeight(line, 0);\n\t        if (line.widgets && cur && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {\n\t          var w = line.widgets[i];\n\t          if (w.showIfHidden) {\n\t            var prev = cur.previousSibling;\n\t            if (/pre/i.test(prev.nodeName)) {\n\t              var wrap = elt(\"div\", null, null, \"position: relative\");\n\t              prev.parentNode.replaceChild(wrap, prev);\n\t              wrap.appendChild(prev);\n\t              prev = wrap;\n\t            }\n\t            var wnode = prev.appendChild(elt(\"div\", [w.node], \"CodeMirror-linewidget\"));\n\t            if (!w.handleMouseEvents) wnode.ignoreEvents = true;\n\t            positionLineWidget(w, wnode, prev, dims);\n\t          }\n\t        }\n\t      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {\n\t        // This line is intact. Skip to the actual node. Update its\n\t        // line number if needed.\n\t        while (cur.lineObj != line) cur = rm(cur);\n\t        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)\n\t          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));\n\t        cur = cur.nextSibling;\n\t      } else {\n\t        // For lines with widgets, make an attempt to find and reuse\n\t        // the existing element, so that widgets aren't needlessly\n\t        // removed and re-inserted into the dom\n\t        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)\n\t          if (search.lineObj == line && /div/i.test(search.nodeName)) { reuse = search; break; }\n\t        // This line needs to be generated.\n\t        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);\n\t        if (lineNode != reuse) {\n\t          container.insertBefore(lineNode, cur);\n\t        } else {\n\t          while (cur != reuse) cur = rm(cur);\n\t          cur = cur.nextSibling;\n\t        }\n\t\n\t        lineNode.lineObj = line;\n\t      }\n\t      ++lineN;\n\t    });\n\t    while (cur) cur = rm(cur);\n\t  }\n\t\n\t  function buildLineElement(cm, line, lineNo, dims, reuse) {\n\t    var built = buildLineContent(cm, line), lineElement = built.pre;\n\t    var markers = line.gutterMarkers, display = cm.display, wrap;\n\t\n\t    var bgClass = built.bgClass ? built.bgClass + \" \" + (line.bgClass || \"\") : line.bgClass;\n\t    if (!cm.options.lineNumbers && !markers && !bgClass && !line.wrapClass && !line.widgets)\n\t      return lineElement;\n\t\n\t    // Lines with gutter elements, widgets or a background class need\n\t    // to be wrapped again, and have the extra elements added to the\n\t    // wrapper div\n\t\n\t    if (reuse) {\n\t      reuse.alignable = null;\n\t      var isOk = true, widgetsSeen = 0, insertBefore = null;\n\t      for (var n = reuse.firstChild, next; n; n = next) {\n\t        next = n.nextSibling;\n\t        if (!/\\bCodeMirror-linewidget\\b/.test(n.className)) {\n\t          reuse.removeChild(n);\n\t        } else {\n\t          for (var i = 0; i < line.widgets.length; ++i) {\n\t            var widget = line.widgets[i];\n\t            if (widget.node == n.firstChild) {\n\t              if (!widget.above && !insertBefore) insertBefore = n;\n\t              positionLineWidget(widget, n, reuse, dims);\n\t              ++widgetsSeen;\n\t              break;\n\t            }\n\t          }\n\t          if (i == line.widgets.length) { isOk = false; break; }\n\t        }\n\t      }\n\t      reuse.insertBefore(lineElement, insertBefore);\n\t      if (isOk && widgetsSeen == line.widgets.length) {\n\t        wrap = reuse;\n\t        reuse.className = line.wrapClass || \"\";\n\t      }\n\t    }\n\t    if (!wrap) {\n\t      wrap = elt(\"div\", null, line.wrapClass, \"position: relative\");\n\t      wrap.appendChild(lineElement);\n\t    }\n\t    // Kludge to make sure the styled element lies behind the selection (by z-index)\n\t    if (bgClass)\n\t      wrap.insertBefore(elt(\"div\", null, bgClass + \" CodeMirror-linebackground\"), wrap.firstChild);\n\t    if (cm.options.lineNumbers || markers) {\n\t      var gutterWrap = wrap.insertBefore(elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"position: absolute; left: \" +\n\t                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"),\n\t                                         lineElement);\n\t      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);\n\t      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n\t        wrap.lineNumber = gutterWrap.appendChild(\n\t          elt(\"div\", lineNumberFor(cm.options, lineNo),\n\t              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n\t              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n\t              + display.lineNumInnerWidth + \"px\"));\n\t      if (markers)\n\t        for (var k = 0; k < cm.options.gutters.length; ++k) {\n\t          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n\t          if (found)\n\t            gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n\t                                       dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n\t        }\n\t    }\n\t    if (ie_lt8) wrap.style.zIndex = 2;\n\t    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n\t      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n\t      if (!widget.handleMouseEvents) node.ignoreEvents = true;\n\t      positionLineWidget(widget, node, wrap, dims);\n\t      if (widget.above)\n\t        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);\n\t      else\n\t        wrap.appendChild(node);\n\t      signalLater(widget, \"redraw\");\n\t    }\n\t    return wrap;\n\t  }\n\t\n\t  function positionLineWidget(widget, node, wrap, dims) {\n\t    if (widget.noHScroll) {\n\t      (wrap.alignable || (wrap.alignable = [])).push(node);\n\t      var width = dims.wrapperWidth;\n\t      node.style.left = dims.fixedPos + \"px\";\n\t      if (!widget.coverGutter) {\n\t        width -= dims.gutterTotalWidth;\n\t        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n\t      }\n\t      node.style.width = width + \"px\";\n\t    }\n\t    if (widget.coverGutter) {\n\t      node.style.zIndex = 5;\n\t      node.style.position = \"relative\";\n\t      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n\t    }\n\t  }\n\t\n\t  // SELECTION / CURSOR\n\t\n\t  function updateSelection(cm) {\n\t    var display = cm.display;\n\t    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);\n\t    if (collapsed || cm.options.showCursorWhenSelecting)\n\t      updateSelectionCursor(cm);\n\t    else\n\t      display.cursor.style.display = display.otherCursor.style.display = \"none\";\n\t    if (!collapsed)\n\t      updateSelectionRange(cm);\n\t    else\n\t      display.selectionDiv.style.display = \"none\";\n\t\n\t    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n\t    if (cm.options.moveInputWithCursor) {\n\t      var headPos = cursorCoords(cm, cm.doc.sel.head, \"div\");\n\t      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);\n\t      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n\t                                                        headPos.top + lineOff.top - wrapOff.top)) + \"px\";\n\t      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n\t                                                         headPos.left + lineOff.left - wrapOff.left)) + \"px\";\n\t    }\n\t  }\n\t\n\t  // No selection, plain cursor\n\t  function updateSelectionCursor(cm) {\n\t    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, \"div\");\n\t    display.cursor.style.left = pos.left + \"px\";\n\t    display.cursor.style.top = pos.top + \"px\";\n\t    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\t    display.cursor.style.display = \"\";\n\t\n\t    if (pos.other) {\n\t      display.otherCursor.style.display = \"\";\n\t      display.otherCursor.style.left = pos.other.left + \"px\";\n\t      display.otherCursor.style.top = pos.other.top + \"px\";\n\t      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n\t    } else { display.otherCursor.style.display = \"none\"; }\n\t  }\n\t\n\t  // Highlight selection\n\t  function updateSelectionRange(cm) {\n\t    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;\n\t    var fragment = document.createDocumentFragment();\n\t    var padding = paddingH(cm.display), leftSide = padding.left, rightSide = display.lineSpace.offsetWidth - padding.right;\n\t\n\t    function add(left, top, width, bottom) {\n\t      if (top < 0) top = 0;\n\t      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n\t                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n\t                               \"px; height: \" + (bottom - top) + \"px\"));\n\t    }\n\t\n\t    function drawForLine(line, fromArg, toArg) {\n\t      var lineObj = getLine(doc, line);\n\t      var lineLen = lineObj.text.length;\n\t      var start, end;\n\t      function coords(ch, bias) {\n\t        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n\t      }\n\t\n\t      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n\t        var leftPos = coords(from, \"left\"), rightPos, left, right;\n\t        if (from == to) {\n\t          rightPos = leftPos;\n\t          left = right = leftPos.left;\n\t        } else {\n\t          rightPos = coords(to - 1, \"right\");\n\t          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n\t          left = leftPos.left;\n\t          right = rightPos.right;\n\t        }\n\t        if (fromArg == null && from == 0) left = leftSide;\n\t        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n\t          add(left, leftPos.top, null, leftPos.bottom);\n\t          left = leftSide;\n\t          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n\t        }\n\t        if (toArg == null && to == lineLen) right = rightSide;\n\t        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n\t          start = leftPos;\n\t        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n\t          end = rightPos;\n\t        if (left < leftSide + 1) left = leftSide;\n\t        add(left, rightPos.top, right - left, rightPos.bottom);\n\t      });\n\t      return {start: start, end: end};\n\t    }\n\t\n\t    if (sel.from.line == sel.to.line) {\n\t      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);\n\t    } else {\n\t      var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);\n\t      var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);\n\t      var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;\n\t      var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;\n\t      if (singleVLine) {\n\t        if (leftEnd.top < rightStart.top - 2) {\n\t          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n\t          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n\t        } else {\n\t          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n\t        }\n\t      }\n\t      if (leftEnd.bottom < rightStart.top)\n\t        add(leftSide, leftEnd.bottom, null, rightStart.top);\n\t    }\n\t\n\t    removeChildrenAndAdd(display.selectionDiv, fragment);\n\t    display.selectionDiv.style.display = \"\";\n\t  }\n\t\n\t  // Cursor-blinking\n\t  function restartBlink(cm) {\n\t    if (!cm.state.focused) return;\n\t    var display = cm.display;\n\t    clearInterval(display.blinker);\n\t    var on = true;\n\t    display.cursor.style.visibility = display.otherCursor.style.visibility = \"\";\n\t    if (cm.options.cursorBlinkRate > 0)\n\t      display.blinker = setInterval(function() {\n\t        display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? \"\" : \"hidden\";\n\t      }, cm.options.cursorBlinkRate);\n\t  }\n\t\n\t  // HIGHLIGHT WORKER\n\t\n\t  function startWorker(cm, time) {\n\t    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)\n\t      cm.state.highlight.set(time, bind(highlightWorker, cm));\n\t  }\n\t\n\t  function highlightWorker(cm) {\n\t    var doc = cm.doc;\n\t    if (doc.frontier < doc.first) doc.frontier = doc.first;\n\t    if (doc.frontier >= cm.display.showingTo) return;\n\t    var end = +new Date + cm.options.workTime;\n\t    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n\t    var changed = [], prevChange;\n\t    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function(line) {\n\t      if (doc.frontier >= cm.display.showingFrom) { // Visible\n\t        var oldStyles = line.styles;\n\t        line.styles = highlightLine(cm, line, state, true);\n\t        var ischange = !oldStyles || oldStyles.length != line.styles.length;\n\t        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n\t        if (ischange) {\n\t          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;\n\t          else changed.push(prevChange = {start: doc.frontier, end: doc.frontier + 1});\n\t        }\n\t        line.stateAfter = copyState(doc.mode, state);\n\t      } else {\n\t        processLine(cm, line.text, state);\n\t        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n\t      }\n\t      ++doc.frontier;\n\t      if (+new Date > end) {\n\t        startWorker(cm, cm.options.workDelay);\n\t        return true;\n\t      }\n\t    });\n\t    if (changed.length)\n\t      operation(cm, function() {\n\t        for (var i = 0; i < changed.length; ++i)\n\t          regChange(this, changed[i].start, changed[i].end);\n\t      })();\n\t  }\n\t\n\t  // Finds the line to start with when starting a parse. Tries to\n\t  // find a line with a stateAfter, so that it can start with a\n\t  // valid state. If that fails, it returns the line with the\n\t  // smallest indentation, which tends to need the least context to\n\t  // parse correctly.\n\t  function findStartLine(cm, n, precise) {\n\t    var minindent, minline, doc = cm.doc;\n\t    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n\t    for (var search = n; search > lim; --search) {\n\t      if (search <= doc.first) return doc.first;\n\t      var line = getLine(doc, search - 1);\n\t      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n\t      var indented = countColumn(line.text, null, cm.options.tabSize);\n\t      if (minline == null || minindent > indented) {\n\t        minline = search - 1;\n\t        minindent = indented;\n\t      }\n\t    }\n\t    return minline;\n\t  }\n\t\n\t  function getStateBefore(cm, n, precise) {\n\t    var doc = cm.doc, display = cm.display;\n\t    if (!doc.mode.startState) return true;\n\t    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n\t    if (!state) state = startState(doc.mode);\n\t    else state = copyState(doc.mode, state);\n\t    doc.iter(pos, n, function(line) {\n\t      processLine(cm, line.text, state);\n\t      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;\n\t      line.stateAfter = save ? copyState(doc.mode, state) : null;\n\t      ++pos;\n\t    });\n\t    if (precise) doc.frontier = pos;\n\t    return state;\n\t  }\n\t\n\t  // POSITION MEASUREMENT\n\t\n\t  function paddingTop(display) {return display.lineSpace.offsetTop;}\n\t  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n\t  function paddingH(display) {\n\t    if (display.cachedPaddingH) return display.cachedPaddingH;\n\t    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n\t    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n\t    return display.cachedPaddingH = {left: parseInt(style.paddingLeft),\n\t                                     right: parseInt(style.paddingRight)};\n\t  }\n\t\n\t  function measureChar(cm, line, ch, data, bias) {\n\t    var dir = -1;\n\t    data = data || measureLine(cm, line);\n\t    if (data.crude) {\n\t      var left = data.left + ch * data.width;\n\t      return {left: left, right: left + data.width, top: data.top, bottom: data.bottom};\n\t    }\n\t\n\t    for (var pos = ch;; pos += dir) {\n\t      var r = data[pos];\n\t      if (r) break;\n\t      if (dir < 0 && pos == 0) dir = 1;\n\t    }\n\t    bias = pos > ch ? \"left\" : pos < ch ? \"right\" : bias;\n\t    if (bias == \"left\" && r.leftSide) r = r.leftSide;\n\t    else if (bias == \"right\" && r.rightSide) r = r.rightSide;\n\t    return {left: pos < ch ? r.right : r.left,\n\t            right: pos > ch ? r.left : r.right,\n\t            top: r.top,\n\t            bottom: r.bottom};\n\t  }\n\t\n\t  function findCachedMeasurement(cm, line) {\n\t    var cache = cm.display.measureLineCache;\n\t    for (var i = 0; i < cache.length; ++i) {\n\t      var memo = cache[i];\n\t      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&\n\t          cm.display.scroller.clientWidth == memo.width &&\n\t          memo.classes == line.textClass + \"|\" + line.wrapClass)\n\t        return memo;\n\t    }\n\t  }\n\t\n\t  function clearCachedMeasurement(cm, line) {\n\t    var exists = findCachedMeasurement(cm, line);\n\t    if (exists) exists.text = exists.measure = exists.markedSpans = null;\n\t  }\n\t\n\t  function measureLine(cm, line) {\n\t    // First look in the cache\n\t    var cached = findCachedMeasurement(cm, line);\n\t    if (cached) return cached.measure;\n\t\n\t    // Failing that, recompute and store result in cache\n\t    var measure = measureLineInner(cm, line);\n\t    var cache = cm.display.measureLineCache;\n\t    var memo = {text: line.text, width: cm.display.scroller.clientWidth,\n\t                markedSpans: line.markedSpans, measure: measure,\n\t                classes: line.textClass + \"|\" + line.wrapClass};\n\t    if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;\n\t    else cache.push(memo);\n\t    return measure;\n\t  }\n\t\n\t  function measureLineInner(cm, line) {\n\t    if (!cm.options.lineWrapping && line.text.length >= cm.options.crudeMeasuringFrom)\n\t      return crudelyMeasureLine(cm, line);\n\t\n\t    var display = cm.display, measure = emptyArray(line.text.length);\n\t    var pre = buildLineContent(cm, line, measure, true).pre;\n\t\n\t    // IE does not cache element positions of inline elements between\n\t    // calls to getBoundingClientRect. This makes the loop below,\n\t    // which gathers the positions of all the characters on the line,\n\t    // do an amount of layout work quadratic to the number of\n\t    // characters. When line wrapping is off, we try to improve things\n\t    // by first subdividing the line into a bunch of inline blocks, so\n\t    // that IE can reuse most of the layout information from caches\n\t    // for those blocks. This does interfere with line wrapping, so it\n\t    // doesn't work when wrapping is on, but in that case the\n\t    // situation is slightly better, since IE does cache line-wrapping\n\t    // information and only recomputes per-line.\n\t    if (old_ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {\n\t      var fragment = document.createDocumentFragment();\n\t      var chunk = 10, n = pre.childNodes.length;\n\t      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {\n\t        var wrap = elt(\"div\", null, null, \"display: inline-block\");\n\t        for (var j = 0; j < chunk && n; ++j) {\n\t          wrap.appendChild(pre.firstChild);\n\t          --n;\n\t        }\n\t        fragment.appendChild(wrap);\n\t      }\n\t      pre.appendChild(fragment);\n\t    }\n\t\n\t    removeChildrenAndAdd(display.measure, pre);\n\t\n\t    var outer = getRect(display.lineDiv);\n\t    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;\n\t    // Work around an IE7/8 bug where it will sometimes have randomly\n\t    // replaced our pre with a clone at this point.\n\t    if (ie_lt9 && display.measure.first != pre)\n\t      removeChildrenAndAdd(display.measure, pre);\n\t\n\t    function measureRect(rect) {\n\t      var top = rect.top - outer.top, bot = rect.bottom - outer.top;\n\t      if (bot > maxBot) bot = maxBot;\n\t      if (top < 0) top = 0;\n\t      for (var i = vranges.length - 2; i >= 0; i -= 2) {\n\t        var rtop = vranges[i], rbot = vranges[i+1];\n\t        if (rtop > bot || rbot < top) continue;\n\t        if (rtop <= top && rbot >= bot ||\n\t            top <= rtop && bot >= rbot ||\n\t            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {\n\t          vranges[i] = Math.min(top, rtop);\n\t          vranges[i+1] = Math.max(bot, rbot);\n\t          break;\n\t        }\n\t      }\n\t      if (i < 0) { i = vranges.length; vranges.push(top, bot); }\n\t      return {left: rect.left - outer.left,\n\t              right: rect.right - outer.left,\n\t              top: i, bottom: null};\n\t    }\n\t    function finishRect(rect) {\n\t      rect.bottom = vranges[rect.top+1];\n\t      rect.top = vranges[rect.top];\n\t    }\n\t\n\t    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {\n\t      var node = cur, rect = null;\n\t      // A widget might wrap, needs special care\n\t      if (/\\bCodeMirror-widget\\b/.test(cur.className) && cur.getClientRects) {\n\t        if (cur.firstChild.nodeType == 1) node = cur.firstChild;\n\t        var rects = node.getClientRects();\n\t        if (rects.length > 1) {\n\t          rect = data[i] = measureRect(rects[0]);\n\t          rect.rightSide = measureRect(rects[rects.length - 1]);\n\t        }\n\t      }\n\t      if (!rect) rect = data[i] = measureRect(getRect(node));\n\t      if (cur.measureRight) rect.right = getRect(cur.measureRight).left - outer.left;\n\t      if (cur.leftSide) rect.leftSide = measureRect(getRect(cur.leftSide));\n\t    }\n\t    removeChildren(cm.display.measure);\n\t    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {\n\t      finishRect(cur);\n\t      if (cur.leftSide) finishRect(cur.leftSide);\n\t      if (cur.rightSide) finishRect(cur.rightSide);\n\t    }\n\t    return data;\n\t  }\n\t\n\t  function crudelyMeasureLine(cm, line) {\n\t    var copy = new Line(line.text.slice(0, 100), null);\n\t    if (line.textClass) copy.textClass = line.textClass;\n\t    var measure = measureLineInner(cm, copy);\n\t    var left = measureChar(cm, copy, 0, measure, \"left\");\n\t    var right = measureChar(cm, copy, 99, measure, \"right\");\n\t    return {crude: true, top: left.top, left: left.left, bottom: left.bottom, width: (right.right - left.left) / 100};\n\t  }\n\t\n\t  function measureLineWidth(cm, line) {\n\t    var hasBadSpan = false;\n\t    if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {\n\t      var sp = line.markedSpans[i];\n\t      if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;\n\t    }\n\t    var cached = !hasBadSpan && findCachedMeasurement(cm, line);\n\t    if (cached || line.text.length >= cm.options.crudeMeasuringFrom)\n\t      return measureChar(cm, line, line.text.length, cached && cached.measure, \"right\").right;\n\t\n\t    var pre = buildLineContent(cm, line, null, true).pre;\n\t    var end = pre.appendChild(zeroWidthElement(cm.display.measure));\n\t    removeChildrenAndAdd(cm.display.measure, pre);\n\t    return getRect(end).right - getRect(cm.display.lineDiv).left;\n\t  }\n\t\n\t  function clearCaches(cm) {\n\t    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;\n\t    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n\t    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n\t    cm.display.lineNumChars = null;\n\t  }\n\t\n\t  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n\t  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\t\n\t  // Context is one of \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), or \"page\"\n\t  function intoCoordSystem(cm, lineObj, rect, context) {\n\t    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n\t      var size = widgetHeight(lineObj.widgets[i]);\n\t      rect.top += size; rect.bottom += size;\n\t    }\n\t    if (context == \"line\") return rect;\n\t    if (!context) context = \"local\";\n\t    var yOff = heightAtLine(cm, lineObj);\n\t    if (context == \"local\") yOff += paddingTop(cm.display);\n\t    else yOff -= cm.display.viewOffset;\n\t    if (context == \"page\" || context == \"window\") {\n\t      var lOff = getRect(cm.display.lineSpace);\n\t      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n\t      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n\t      rect.left += xOff; rect.right += xOff;\n\t    }\n\t    rect.top += yOff; rect.bottom += yOff;\n\t    return rect;\n\t  }\n\t\n\t  // Context may be \"window\", \"page\", \"div\", or \"local\"/null\n\t  // Result is in \"div\" coords\n\t  function fromCoordSystem(cm, coords, context) {\n\t    if (context == \"div\") return coords;\n\t    var left = coords.left, top = coords.top;\n\t    // First move into \"page\" coordinate system\n\t    if (context == \"page\") {\n\t      left -= pageScrollX();\n\t      top -= pageScrollY();\n\t    } else if (context == \"local\" || !context) {\n\t      var localBox = getRect(cm.display.sizer);\n\t      left += localBox.left;\n\t      top += localBox.top;\n\t    }\n\t\n\t    var lineSpaceBox = getRect(cm.display.lineSpace);\n\t    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n\t  }\n\t\n\t  function charCoords(cm, pos, context, lineObj, bias) {\n\t    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n\t    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);\n\t  }\n\t\n\t  function cursorCoords(cm, pos, context, lineObj, measurement) {\n\t    lineObj = lineObj || getLine(cm.doc, pos.line);\n\t    if (!measurement) measurement = measureLine(cm, lineObj);\n\t    function get(ch, right) {\n\t      var m = measureChar(cm, lineObj, ch, measurement, right ? \"right\" : \"left\");\n\t      if (right) m.left = m.right; else m.right = m.left;\n\t      return intoCoordSystem(cm, lineObj, m, context);\n\t    }\n\t    function getBidi(ch, partPos) {\n\t      var part = order[partPos], right = part.level % 2;\n\t      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n\t        part = order[--partPos];\n\t        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n\t        right = true;\n\t      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n\t        part = order[++partPos];\n\t        ch = bidiLeft(part) - part.level % 2;\n\t        right = false;\n\t      }\n\t      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n\t      return get(ch, right);\n\t    }\n\t    var order = getOrder(lineObj), ch = pos.ch;\n\t    if (!order) return get(ch);\n\t    var partPos = getBidiPartAt(order, ch);\n\t    var val = getBidi(ch, partPos);\n\t    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n\t    return val;\n\t  }\n\t\n\t  function PosWithInfo(line, ch, outside, xRel) {\n\t    var pos = new Pos(line, ch);\n\t    pos.xRel = xRel;\n\t    if (outside) pos.outside = true;\n\t    return pos;\n\t  }\n\t\n\t  // Coords must be lineSpace-local\n\t  function coordsChar(cm, x, y) {\n\t    var doc = cm.doc;\n\t    y += cm.display.viewOffset;\n\t    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n\t    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n\t    if (lineNo > last)\n\t      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n\t    if (x < 0) x = 0;\n\t\n\t    for (;;) {\n\t      var lineObj = getLine(doc, lineNo);\n\t      var found = coordsCharInner(cm, lineObj, lineNo, x, y);\n\t      var merged = collapsedSpanAtEnd(lineObj);\n\t      var mergedPos = merged && merged.find();\n\t      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n\t        lineNo = mergedPos.to.line;\n\t      else\n\t        return found;\n\t    }\n\t  }\n\t\n\t  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n\t    var innerOff = y - heightAtLine(cm, lineObj);\n\t    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n\t    var measurement = measureLine(cm, lineObj);\n\t\n\t    function getX(ch) {\n\t      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\",\n\t                            lineObj, measurement);\n\t      wrongLine = true;\n\t      if (innerOff > sp.bottom) return sp.left - adjust;\n\t      else if (innerOff < sp.top) return sp.left + adjust;\n\t      else wrongLine = false;\n\t      return sp.left;\n\t    }\n\t\n\t    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n\t    var from = lineLeft(lineObj), to = lineRight(lineObj);\n\t    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\t\n\t    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n\t    // Do a binary search between these bounds.\n\t    for (;;) {\n\t      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n\t        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n\t        var xDiff = x - (ch == from ? fromX : toX);\n\t        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n\t        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n\t                              xDiff < 0 ? -1 : xDiff ? 1 : 0);\n\t        return pos;\n\t      }\n\t      var step = Math.ceil(dist / 2), middle = from + step;\n\t      if (bidi) {\n\t        middle = from;\n\t        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n\t      }\n\t      var middleX = getX(middle);\n\t      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n\t      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n\t    }\n\t  }\n\t\n\t  var measureText;\n\t  function textHeight(display) {\n\t    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n\t    if (measureText == null) {\n\t      measureText = elt(\"pre\");\n\t      // Measure a bunch of lines, for browsers that compute\n\t      // fractional heights.\n\t      for (var i = 0; i < 49; ++i) {\n\t        measureText.appendChild(document.createTextNode(\"x\"));\n\t        measureText.appendChild(elt(\"br\"));\n\t      }\n\t      measureText.appendChild(document.createTextNode(\"x\"));\n\t    }\n\t    removeChildrenAndAdd(display.measure, measureText);\n\t    var height = measureText.offsetHeight / 50;\n\t    if (height > 3) display.cachedTextHeight = height;\n\t    removeChildren(display.measure);\n\t    return height || 1;\n\t  }\n\t\n\t  function charWidth(display) {\n\t    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n\t    var anchor = elt(\"span\", \"x\");\n\t    var pre = elt(\"pre\", [anchor]);\n\t    removeChildrenAndAdd(display.measure, pre);\n\t    var width = anchor.offsetWidth;\n\t    if (width > 2) display.cachedCharWidth = width;\n\t    return width || 10;\n\t  }\n\t\n\t  // OPERATIONS\n\t\n\t  // Operations are used to wrap changes in such a way that each\n\t  // change won't have to update the cursor and display (which would\n\t  // be awkward, slow, and error-prone), but instead updates are\n\t  // batched and then all combined and executed at once.\n\t\n\t  var nextOpId = 0;\n\t  function startOperation(cm) {\n\t    cm.curOp = {\n\t      // An array of ranges of lines that have to be updated. See\n\t      // updateDisplay.\n\t      changes: [],\n\t      forceUpdate: false,\n\t      updateInput: null,\n\t      userSelChange: null,\n\t      textChanged: null,\n\t      selectionChanged: false,\n\t      cursorActivity: false,\n\t      updateMaxLine: false,\n\t      updateScrollPos: false,\n\t      id: ++nextOpId\n\t    };\n\t    if (!delayedCallbackDepth++) delayedCallbacks = [];\n\t  }\n\t\n\t  function endOperation(cm) {\n\t    var op = cm.curOp, doc = cm.doc, display = cm.display;\n\t    cm.curOp = null;\n\t\n\t    if (op.updateMaxLine) computeMaxLength(cm);\n\t    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {\n\t      var width = measureLineWidth(cm, display.maxLine);\n\t      display.sizer.style.minWidth = Math.max(0, width + 3) + \"px\";\n\t      display.maxLineChanged = false;\n\t      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);\n\t      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)\n\t        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);\n\t    }\n\t    var newScrollPos, updated;\n\t    if (op.updateScrollPos) {\n\t      newScrollPos = op.updateScrollPos;\n\t    } else if (op.selectionChanged && display.scroller.clientHeight) { // don't rescroll if not visible\n\t      var coords = cursorCoords(cm, doc.sel.head);\n\t      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);\n\t    }\n\t    if (op.changes.length || op.forceUpdate || newScrollPos && newScrollPos.scrollTop != null) {\n\t      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate);\n\t      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;\n\t    }\n\t    if (!updated && op.selectionChanged) updateSelection(cm);\n\t    if (op.updateScrollPos) {\n\t      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, newScrollPos.scrollTop));\n\t      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, newScrollPos.scrollLeft));\n\t      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;\n\t      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;\n\t      alignHorizontally(cm);\n\t      if (op.scrollToPos)\n\t        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from),\n\t                          clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);\n\t    } else if (newScrollPos) {\n\t      scrollCursorIntoView(cm);\n\t    }\n\t    if (op.selectionChanged) restartBlink(cm);\n\t\n\t    if (cm.state.focused && op.updateInput)\n\t      resetInput(cm, op.userSelChange);\n\t\n\t    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n\t    if (hidden) for (var i = 0; i < hidden.length; ++i)\n\t      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n\t    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n\t      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\t\n\t    var delayed;\n\t    if (!--delayedCallbackDepth) {\n\t      delayed = delayedCallbacks;\n\t      delayedCallbacks = null;\n\t    }\n\t    if (op.textChanged)\n\t      signal(cm, \"change\", cm, op.textChanged);\n\t    if (op.cursorActivity) signal(cm, \"cursorActivity\", cm);\n\t    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();\n\t  }\n\t\n\t  // Wraps a function in an operation. Returns the wrapped function.\n\t  function operation(cm1, f) {\n\t    return function() {\n\t      var cm = cm1 || this, withOp = !cm.curOp;\n\t      if (withOp) startOperation(cm);\n\t      try { var result = f.apply(cm, arguments); }\n\t      finally { if (withOp) endOperation(cm); }\n\t      return result;\n\t    };\n\t  }\n\t  function docOperation(f) {\n\t    return function() {\n\t      var withOp = this.cm && !this.cm.curOp, result;\n\t      if (withOp) startOperation(this.cm);\n\t      try { result = f.apply(this, arguments); }\n\t      finally { if (withOp) endOperation(this.cm); }\n\t      return result;\n\t    };\n\t  }\n\t  function runInOp(cm, f) {\n\t    var withOp = !cm.curOp, result;\n\t    if (withOp) startOperation(cm);\n\t    try { result = f(); }\n\t    finally { if (withOp) endOperation(cm); }\n\t    return result;\n\t  }\n\t\n\t  function regChange(cm, from, to, lendiff) {\n\t    if (from == null) from = cm.doc.first;\n\t    if (to == null) to = cm.doc.first + cm.doc.size;\n\t    cm.curOp.changes.push({from: from, to: to, diff: lendiff});\n\t  }\n\t\n\t  // INPUT HANDLING\n\t\n\t  function slowPoll(cm) {\n\t    if (cm.display.pollingFast) return;\n\t    cm.display.poll.set(cm.options.pollInterval, function() {\n\t      readInput(cm);\n\t      if (cm.state.focused) slowPoll(cm);\n\t    });\n\t  }\n\t\n\t  function fastPoll(cm) {\n\t    var missed = false;\n\t    cm.display.pollingFast = true;\n\t    function p() {\n\t      var changed = readInput(cm);\n\t      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}\n\t      else {cm.display.pollingFast = false; slowPoll(cm);}\n\t    }\n\t    cm.display.poll.set(20, p);\n\t  }\n\t\n\t  // prevInput is a hack to work with IME. If we reset the textarea\n\t  // on every change, that breaks IME. So we look for changes\n\t  // compared to the previous content instead. (Modern browsers have\n\t  // events that indicate IME taking place, but these are not widely\n\t  // supported or compatible enough yet to rely on.)\n\t  function readInput(cm) {\n\t    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;\n\t    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.options.disableInput) return false;\n\t    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {\n\t      input.value = input.value.substring(0, input.value.length - 1);\n\t      cm.state.fakedLastChar = false;\n\t    }\n\t    var text = input.value;\n\t    if (text == prevInput && posEq(sel.from, sel.to)) return false;\n\t    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {\n\t      resetInput(cm, true);\n\t      return false;\n\t    }\n\t\n\t    var withOp = !cm.curOp;\n\t    if (withOp) startOperation(cm);\n\t    sel.shift = false;\n\t    var same = 0, l = Math.min(prevInput.length, text.length);\n\t    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\t    var from = sel.from, to = sel.to;\n\t    var inserted = text.slice(same);\n\t    if (same < prevInput.length)\n\t      from = Pos(from.line, from.ch - (prevInput.length - same));\n\t    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)\n\t      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + inserted.length));\n\t\n\t    var updateInput = cm.curOp.updateInput;\n\t    var changeEvent = {from: from, to: to, text: splitLines(inserted),\n\t                       origin: cm.state.pasteIncoming ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\"};\n\t    makeChange(cm.doc, changeEvent, \"end\");\n\t    cm.curOp.updateInput = updateInput;\n\t    signalLater(cm, \"inputRead\", cm, changeEvent);\n\t    if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&\n\t        cm.options.smartIndent && sel.head.ch < 100) {\n\t      var electric = cm.getModeAt(sel.head).electricChars;\n\t      if (electric) for (var i = 0; i < electric.length; i++)\n\t        if (inserted.indexOf(electric.charAt(i)) > -1) {\n\t          indentLine(cm, sel.head.line, \"smart\");\n\t          break;\n\t        }\n\t    }\n\t\n\t    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = cm.display.prevInput = \"\";\n\t    else cm.display.prevInput = text;\n\t    if (withOp) endOperation(cm);\n\t    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n\t    return true;\n\t  }\n\t\n\t  function resetInput(cm, user) {\n\t    var minimal, selected, doc = cm.doc;\n\t    if (!posEq(doc.sel.from, doc.sel.to)) {\n\t      cm.display.prevInput = \"\";\n\t      minimal = hasCopyEvent &&\n\t        (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);\n\t      var content = minimal ? \"-\" : selected || cm.getSelection();\n\t      cm.display.input.value = content;\n\t      if (cm.state.focused) selectInput(cm.display.input);\n\t      if (ie && !ie_lt9) cm.display.inputHasSelection = content;\n\t    } else if (user) {\n\t      cm.display.prevInput = cm.display.input.value = \"\";\n\t      if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n\t    }\n\t    cm.display.inaccurateSelection = minimal;\n\t  }\n\t\n\t  function focusInput(cm) {\n\t    if (cm.options.readOnly != \"nocursor\" && (!mobile || document.activeElement != cm.display.input))\n\t      cm.display.input.focus();\n\t  }\n\t\n\t  function ensureFocus(cm) {\n\t    if (!cm.state.focused) { focusInput(cm); onFocus(cm); }\n\t  }\n\t\n\t  function isReadOnly(cm) {\n\t    return cm.options.readOnly || cm.doc.cantEdit;\n\t  }\n\t\n\t  // EVENT HANDLERS\n\t\n\t  function registerEventHandlers(cm) {\n\t    var d = cm.display;\n\t    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n\t    if (old_ie)\n\t      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n\t        if (signalDOMEvent(cm, e)) return;\n\t        var pos = posFromMouse(cm, e);\n\t        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n\t        e_preventDefault(e);\n\t        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);\n\t        extendSelection(cm.doc, word.from, word.to);\n\t      }));\n\t    else\n\t      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n\t    on(d.lineSpace, \"selectstart\", function(e) {\n\t      if (!eventInWidget(d, e)) e_preventDefault(e);\n\t    });\n\t    // Gecko browsers fire contextmenu *after* opening the menu, at\n\t    // which point we can't mess with it anymore. Context menu is\n\t    // handled in onMouseDown for Gecko.\n\t    if (!captureMiddleClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\t\n\t    on(d.scroller, \"scroll\", function() {\n\t      if (d.scroller.clientHeight) {\n\t        setScrollTop(cm, d.scroller.scrollTop);\n\t        setScrollLeft(cm, d.scroller.scrollLeft, true);\n\t        signal(cm, \"scroll\", cm);\n\t      }\n\t    });\n\t    on(d.scrollbarV, \"scroll\", function() {\n\t      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);\n\t    });\n\t    on(d.scrollbarH, \"scroll\", function() {\n\t      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);\n\t    });\n\t\n\t    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n\t    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\t\n\t    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }\n\t    on(d.scrollbarH, \"mousedown\", reFocus);\n\t    on(d.scrollbarV, \"mousedown\", reFocus);\n\t    // Prevent wrapper from ever scrolling\n\t    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\t\n\t    var resizeTimer;\n\t    function onResize() {\n\t      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n\t        resizeTimer = null;\n\t        // Might be a text scaling operation, clear size caches.\n\t        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = knownScrollbarWidth = null;\n\t        clearCaches(cm);\n\t        runInOp(cm, bind(regChange, cm));\n\t      }, 100);\n\t    }\n\t    on(window, \"resize\", onResize);\n\t    // Above handler holds on to the editor and its data structures.\n\t    // Here we poll to unregister it when the editor is no longer in\n\t    // the document, so that it can be garbage-collected.\n\t    function unregister() {\n\t      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}\n\t      if (p) setTimeout(unregister, 5000);\n\t      else off(window, \"resize\", onResize);\n\t    }\n\t    setTimeout(unregister, 5000);\n\t\n\t    on(d.input, \"keyup\", operation(cm, onKeyUp));\n\t    on(d.input, \"input\", function() {\n\t      if (ie && !ie_lt9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;\n\t      fastPoll(cm);\n\t    });\n\t    on(d.input, \"keydown\", operation(cm, onKeyDown));\n\t    on(d.input, \"keypress\", operation(cm, onKeyPress));\n\t    on(d.input, \"focus\", bind(onFocus, cm));\n\t    on(d.input, \"blur\", bind(onBlur, cm));\n\t\n\t    function drag_(e) {\n\t      if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;\n\t      e_stop(e);\n\t    }\n\t    if (cm.options.dragDrop) {\n\t      on(d.scroller, \"dragstart\", function(e){onDragStart(cm, e);});\n\t      on(d.scroller, \"dragenter\", drag_);\n\t      on(d.scroller, \"dragover\", drag_);\n\t      on(d.scroller, \"drop\", operation(cm, onDrop));\n\t    }\n\t    on(d.scroller, \"paste\", function(e) {\n\t      if (eventInWidget(d, e)) return;\n\t      focusInput(cm);\n\t      fastPoll(cm);\n\t    });\n\t    on(d.input, \"paste\", function() {\n\t      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206\n\t      // Add a char to the end of textarea before paste occur so that\n\t      // selection doesn't span to the end of textarea.\n\t      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {\n\t        var start = d.input.selectionStart, end = d.input.selectionEnd;\n\t        d.input.value += \"$\";\n\t        d.input.selectionStart = start;\n\t        d.input.selectionEnd = end;\n\t        cm.state.fakedLastChar = true;\n\t      }\n\t      cm.state.pasteIncoming = true;\n\t      fastPoll(cm);\n\t    });\n\t\n\t    function prepareCopy(e) {\n\t      if (d.inaccurateSelection) {\n\t        d.prevInput = \"\";\n\t        d.inaccurateSelection = false;\n\t        d.input.value = cm.getSelection();\n\t        selectInput(d.input);\n\t      }\n\t      if (e.type == \"cut\") cm.state.cutIncoming = true;\n\t    }\n\t    on(d.input, \"cut\", prepareCopy);\n\t    on(d.input, \"copy\", prepareCopy);\n\t\n\t    // Needed to handle Tab key in KHTML\n\t    if (khtml) on(d.sizer, \"mouseup\", function() {\n\t      if (document.activeElement == d.input) d.input.blur();\n\t      focusInput(cm);\n\t    });\n\t  }\n\t\n\t  function eventInWidget(display, e) {\n\t    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n\t      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;\n\t    }\n\t  }\n\t\n\t  function posFromMouse(cm, e, liberal) {\n\t    var display = cm.display;\n\t    if (!liberal) {\n\t      var target = e_target(e);\n\t      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||\n\t          target == display.scrollbarV || target == display.scrollbarV.firstChild ||\n\t          target == display.scrollbarFiller || target == display.gutterFiller) return null;\n\t    }\n\t    var x, y, space = getRect(display.lineSpace);\n\t    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n\t    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n\t    return coordsChar(cm, x - space.left, y - space.top);\n\t  }\n\t\n\t  var lastClick, lastDoubleClick;\n\t  function onMouseDown(e) {\n\t    if (signalDOMEvent(this, e)) return;\n\t    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;\n\t    sel.shift = e.shiftKey;\n\t\n\t    if (eventInWidget(display, e)) {\n\t      if (!webkit) {\n\t        display.scroller.draggable = false;\n\t        setTimeout(function(){display.scroller.draggable = true;}, 100);\n\t      }\n\t      return;\n\t    }\n\t    if (clickInGutter(cm, e)) return;\n\t    var start = posFromMouse(cm, e);\n\t    window.focus();\n\t\n\t    switch (e_button(e)) {\n\t    case 3:\n\t      if (captureMiddleClick) onContextMenu.call(cm, cm, e);\n\t      return;\n\t    case 2:\n\t      if (webkit) cm.state.lastMiddleDown = +new Date;\n\t      if (start) extendSelection(cm.doc, start);\n\t      setTimeout(bind(focusInput, cm), 20);\n\t      e_preventDefault(e);\n\t      return;\n\t    }\n\t    // For button 1, if it was clicked inside the editor\n\t    // (posFromMouse returning non-null), we have to adjust the\n\t    // selection.\n\t    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}\n\t\n\t    setTimeout(bind(ensureFocus, cm), 0);\n\t\n\t    var now = +new Date, type = \"single\";\n\t    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n\t      type = \"triple\";\n\t      e_preventDefault(e);\n\t      setTimeout(bind(focusInput, cm), 20);\n\t      selectLine(cm, start.line);\n\t    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n\t      type = \"double\";\n\t      lastDoubleClick = {time: now, pos: start};\n\t      e_preventDefault(e);\n\t      var word = findWordAt(getLine(doc, start.line).text, start);\n\t      extendSelection(cm.doc, word.from, word.to);\n\t    } else { lastClick = {time: now, pos: start}; }\n\t\n\t    var last = start;\n\t    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&\n\t        !posLess(start, sel.from) && !posLess(sel.to, start) && type == \"single\") {\n\t      var dragEnd = operation(cm, function(e2) {\n\t        if (webkit) display.scroller.draggable = false;\n\t        cm.state.draggingText = false;\n\t        off(document, \"mouseup\", dragEnd);\n\t        off(display.scroller, \"drop\", dragEnd);\n\t        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n\t          e_preventDefault(e2);\n\t          extendSelection(cm.doc, start);\n\t          focusInput(cm);\n\t          // Work around unexplainable focus problem in IE9 (#2127)\n\t          if (old_ie && !ie_lt9)\n\t            setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);\n\t        }\n\t      });\n\t      // Let the drag handler handle this.\n\t      if (webkit) display.scroller.draggable = true;\n\t      cm.state.draggingText = dragEnd;\n\t      // IE's approach to draggable\n\t      if (display.scroller.dragDrop) display.scroller.dragDrop();\n\t      on(document, \"mouseup\", dragEnd);\n\t      on(display.scroller, \"drop\", dragEnd);\n\t      return;\n\t    }\n\t    e_preventDefault(e);\n\t    if (type == \"single\") extendSelection(cm.doc, clipPos(doc, start));\n\t\n\t    var startstart = sel.from, startend = sel.to, lastPos = start;\n\t\n\t    function doSelect(cur) {\n\t      if (posEq(lastPos, cur)) return;\n\t      lastPos = cur;\n\t\n\t      if (type == \"single\") {\n\t        extendSelection(cm.doc, clipPos(doc, start), cur);\n\t        return;\n\t      }\n\t\n\t      startstart = clipPos(doc, startstart);\n\t      startend = clipPos(doc, startend);\n\t      if (type == \"double\") {\n\t        var word = findWordAt(getLine(doc, cur.line).text, cur);\n\t        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);\n\t        else extendSelection(cm.doc, startstart, word.to);\n\t      } else if (type == \"triple\") {\n\t        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));\n\t        else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));\n\t      }\n\t    }\n\t\n\t    var editorSize = getRect(display.wrapper);\n\t    // Used to ensure timeout re-tries don't fire when another extend\n\t    // happened in the meantime (clearTimeout isn't reliable -- at\n\t    // least on Chrome, the timeouts still happen even when cleared,\n\t    // if the clear happens after their scheduled firing time).\n\t    var counter = 0;\n\t\n\t    function extend(e) {\n\t      var curCount = ++counter;\n\t      var cur = posFromMouse(cm, e, true);\n\t      if (!cur) return;\n\t      if (!posEq(cur, last)) {\n\t        ensureFocus(cm);\n\t        last = cur;\n\t        doSelect(cur);\n\t        var visible = visibleLines(display, doc);\n\t        if (cur.line >= visible.to || cur.line < visible.from)\n\t          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n\t      } else {\n\t        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n\t        if (outside) setTimeout(operation(cm, function() {\n\t          if (counter != curCount) return;\n\t          display.scroller.scrollTop += outside;\n\t          extend(e);\n\t        }), 50);\n\t      }\n\t    }\n\t\n\t    function done(e) {\n\t      counter = Infinity;\n\t      e_preventDefault(e);\n\t      focusInput(cm);\n\t      off(document, \"mousemove\", move);\n\t      off(document, \"mouseup\", up);\n\t    }\n\t\n\t    var move = operation(cm, function(e) {\n\t      if ((ie && !ie_lt10) ?  !e.buttons : !e_button(e)) done(e);\n\t      else extend(e);\n\t    });\n\t    var up = operation(cm, done);\n\t    on(document, \"mousemove\", move);\n\t    on(document, \"mouseup\", up);\n\t  }\n\t\n\t  function gutterEvent(cm, e, type, prevent, signalfn) {\n\t    try { var mX = e.clientX, mY = e.clientY; }\n\t    catch(e) { return false; }\n\t    if (mX >= Math.floor(getRect(cm.display.gutters).right)) return false;\n\t    if (prevent) e_preventDefault(e);\n\t\n\t    var display = cm.display;\n\t    var lineBox = getRect(display.lineDiv);\n\t\n\t    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n\t    mY -= lineBox.top - display.viewOffset;\n\t\n\t    for (var i = 0; i < cm.options.gutters.length; ++i) {\n\t      var g = display.gutters.childNodes[i];\n\t      if (g && getRect(g).right >= mX) {\n\t        var line = lineAtHeight(cm.doc, mY);\n\t        var gutter = cm.options.gutters[i];\n\t        signalfn(cm, type, cm, line, gutter, e);\n\t        return e_defaultPrevented(e);\n\t      }\n\t    }\n\t  }\n\t\n\t  function contextMenuInGutter(cm, e) {\n\t    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n\t    return gutterEvent(cm, e, \"gutterContextMenu\", false, signal);\n\t  }\n\t\n\t  function clickInGutter(cm, e) {\n\t    return gutterEvent(cm, e, \"gutterClick\", true, signalLater);\n\t  }\n\t\n\t  // Kludge to work around strange IE behavior where it'll sometimes\n\t  // re-fire a series of drag-related events right after the drop (#1551)\n\t  var lastDrop = 0;\n\t\n\t  function onDrop(e) {\n\t    var cm = this;\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))))\n\t      return;\n\t    e_preventDefault(e);\n\t    if (ie) lastDrop = +new Date;\n\t    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n\t    if (!pos || isReadOnly(cm)) return;\n\t    if (files && files.length && window.FileReader && window.File) {\n\t      var n = files.length, text = Array(n), read = 0;\n\t      var loadFile = function(file, i) {\n\t        var reader = new FileReader;\n\t        reader.onload = function() {\n\t          text[i] = reader.result;\n\t          if (++read == n) {\n\t            pos = clipPos(cm.doc, pos);\n\t            makeChange(cm.doc, {from: pos, to: pos, text: splitLines(text.join(\"\\n\")), origin: \"paste\"}, \"around\");\n\t          }\n\t        };\n\t        reader.readAsText(file);\n\t      };\n\t      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n\t    } else {\n\t      // Don't do a replace if the drop happened inside of the selected text.\n\t      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {\n\t        cm.state.draggingText(e);\n\t        // Ensure the editor is re-focused\n\t        setTimeout(bind(focusInput, cm), 20);\n\t        return;\n\t      }\n\t      try {\n\t        var text = e.dataTransfer.getData(\"Text\");\n\t        if (text) {\n\t          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;\n\t          setSelection(cm.doc, pos, pos);\n\t          if (cm.state.draggingText) replaceRange(cm.doc, \"\", curFrom, curTo, \"paste\");\n\t          cm.replaceSelection(text, null, \"paste\");\n\t          focusInput(cm);\n\t        }\n\t      }\n\t      catch(e){}\n\t    }\n\t  }\n\t\n\t  function onDragStart(cm, e) {\n\t    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\t\n\t    var txt = cm.getSelection();\n\t    e.dataTransfer.setData(\"Text\", txt);\n\t\n\t    // Use dummy image instead of default browsers image.\n\t    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n\t    if (e.dataTransfer.setDragImage && !safari) {\n\t      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n\t      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\t      if (opera) {\n\t        img.width = img.height = 1;\n\t        cm.display.wrapper.appendChild(img);\n\t        // Force a relayout, or Opera won't use our image for some obscure reason\n\t        img._top = img.offsetTop;\n\t      }\n\t      e.dataTransfer.setDragImage(img, 0, 0);\n\t      if (opera) img.parentNode.removeChild(img);\n\t    }\n\t  }\n\t\n\t  function setScrollTop(cm, val) {\n\t    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n\t    cm.doc.scrollTop = val;\n\t    if (!gecko) updateDisplay(cm, [], val);\n\t    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n\t    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\n\t    if (gecko) updateDisplay(cm, []);\n\t    startWorker(cm, 100);\n\t  }\n\t  function setScrollLeft(cm, val, isScroller) {\n\t    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n\t    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n\t    cm.doc.scrollLeft = val;\n\t    alignHorizontally(cm);\n\t    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n\t    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\n\t  }\n\t\n\t  // Since the delta values reported on mouse wheel events are\n\t  // unstandardized between browsers and even browser versions, and\n\t  // generally horribly unpredictable, this code starts by measuring\n\t  // the scroll effect that the first few mouse wheel events have,\n\t  // and, from that, detects the way it can convert deltas to pixel\n\t  // offsets afterwards.\n\t  //\n\t  // The reason we want to know the amount a wheel event will scroll\n\t  // is that it gives us a chance to update the display before the\n\t  // actual scrolling happens, reducing flickering.\n\t\n\t  var wheelSamples = 0, wheelPixelsPerUnit = null;\n\t  // Fill in a browser-detected starting value on browsers where we\n\t  // know one. These don't have to be accurate -- the result of them\n\t  // being wrong would just be a slight flicker on the first wheel\n\t  // scroll (if it is large enough).\n\t  if (ie) wheelPixelsPerUnit = -.53;\n\t  else if (gecko) wheelPixelsPerUnit = 15;\n\t  else if (chrome) wheelPixelsPerUnit = -.7;\n\t  else if (safari) wheelPixelsPerUnit = -1/3;\n\t\n\t  function onScrollWheel(cm, e) {\n\t    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n\t    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n\t    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n\t    else if (dy == null) dy = e.wheelDelta;\n\t\n\t    var display = cm.display, scroll = display.scroller;\n\t    // Quit if there's nothing to scroll here\n\t    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||\n\t          dy && scroll.scrollHeight > scroll.clientHeight)) return;\n\t\n\t    // Webkit browsers on OS X abort momentum scrolls when the target\n\t    // of the scroll event is removed from the scrollable element.\n\t    // This hack (see related code in patchDisplay) makes sure the\n\t    // element is kept around.\n\t    if (dy && mac && webkit) {\n\t      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {\n\t        if (cur.lineObj) {\n\t          cm.display.currentWheelTarget = cur;\n\t          break;\n\t        }\n\t      }\n\t    }\n\t\n\t    // On some browsers, horizontal scrolling will cause redraws to\n\t    // happen before the gutter has been realigned, causing it to\n\t    // wriggle around in a most unseemly way. When we have an\n\t    // estimated pixels/delta value, we just handle horizontal\n\t    // scrolling entirely here. It'll be slightly off from native, but\n\t    // better than glitching out.\n\t    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {\n\t      if (dy)\n\t        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n\t      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n\t      e_preventDefault(e);\n\t      display.wheelStartX = null; // Abort measurement, if in progress\n\t      return;\n\t    }\n\t\n\t    if (dy && wheelPixelsPerUnit != null) {\n\t      var pixels = dy * wheelPixelsPerUnit;\n\t      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n\t      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n\t      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n\t      updateDisplay(cm, [], {top: top, bottom: bot});\n\t    }\n\t\n\t    if (wheelSamples < 20) {\n\t      if (display.wheelStartX == null) {\n\t        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n\t        display.wheelDX = dx; display.wheelDY = dy;\n\t        setTimeout(function() {\n\t          if (display.wheelStartX == null) return;\n\t          var movedX = scroll.scrollLeft - display.wheelStartX;\n\t          var movedY = scroll.scrollTop - display.wheelStartY;\n\t          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n\t            (movedX && display.wheelDX && movedX / display.wheelDX);\n\t          display.wheelStartX = display.wheelStartY = null;\n\t          if (!sample) return;\n\t          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n\t          ++wheelSamples;\n\t        }, 200);\n\t      } else {\n\t        display.wheelDX += dx; display.wheelDY += dy;\n\t      }\n\t    }\n\t  }\n\t\n\t  function doHandleBinding(cm, bound, dropShift) {\n\t    if (typeof bound == \"string\") {\n\t      bound = commands[bound];\n\t      if (!bound) return false;\n\t    }\n\t    // Ensure previous input has been read, so that the handler sees a\n\t    // consistent view of the document\n\t    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\n\t    var doc = cm.doc, prevShift = doc.sel.shift, done = false;\n\t    try {\n\t      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n\t      if (dropShift) doc.sel.shift = false;\n\t      done = bound(cm) != Pass;\n\t    } finally {\n\t      doc.sel.shift = prevShift;\n\t      cm.state.suppressEdits = false;\n\t    }\n\t    return done;\n\t  }\n\t\n\t  function allKeyMaps(cm) {\n\t    var maps = cm.state.keyMaps.slice(0);\n\t    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);\n\t    maps.push(cm.options.keyMap);\n\t    return maps;\n\t  }\n\t\n\t  var maybeTransition;\n\t  function handleKeyBinding(cm, e) {\n\t    // Handle auto keymap transitions\n\t    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;\n\t    clearTimeout(maybeTransition);\n\t    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n\t      if (getKeyMap(cm.options.keyMap) == startMap) {\n\t        cm.options.keyMap = (next.call ? next.call(null, cm) : next);\n\t        keyMapChanged(cm);\n\t      }\n\t    }, 50);\n\t\n\t    var name = keyName(e, true), handled = false;\n\t    if (!name) return false;\n\t    var keymaps = allKeyMaps(cm);\n\t\n\t    if (e.shiftKey) {\n\t      // First try to resolve full name (including 'Shift-'). Failing\n\t      // that, see if there is a cursor-motion command (starting with\n\t      // 'go') bound to the keyname without 'Shift-'.\n\t      handled = lookupKey(\"Shift-\" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})\n\t             || lookupKey(name, keymaps, function(b) {\n\t                  if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n\t                    return doHandleBinding(cm, b);\n\t                });\n\t    } else {\n\t      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });\n\t    }\n\t\n\t    if (handled) {\n\t      e_preventDefault(e);\n\t      restartBlink(cm);\n\t      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }\n\t      signalLater(cm, \"keyHandled\", cm, name, e);\n\t    }\n\t    return handled;\n\t  }\n\t\n\t  function handleCharBinding(cm, e, ch) {\n\t    var handled = lookupKey(\"'\" + ch + \"'\", allKeyMaps(cm),\n\t                            function(b) { return doHandleBinding(cm, b, true); });\n\t    if (handled) {\n\t      e_preventDefault(e);\n\t      restartBlink(cm);\n\t      signalLater(cm, \"keyHandled\", cm, \"'\" + ch + \"'\", e);\n\t    }\n\t    return handled;\n\t  }\n\t\n\t  function onKeyUp(e) {\n\t    var cm = this;\n\t    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n\t    if (e.keyCode == 16) cm.doc.sel.shift = false;\n\t  }\n\t\n\t  var lastStoppedKey = null;\n\t  function onKeyDown(e) {\n\t    var cm = this;\n\t    ensureFocus(cm);\n\t    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n\t    if (old_ie && e.keyCode == 27) e.returnValue = false;\n\t    var code = e.keyCode;\n\t    // IE does strange things with escape.\n\t    cm.doc.sel.shift = code == 16 || e.shiftKey;\n\t    // First give onKeyEvent option a chance to handle this.\n\t    var handled = handleKeyBinding(cm, e);\n\t    if (opera) {\n\t      lastStoppedKey = handled ? code : null;\n\t      // Opera has no cut event... we try to at least catch the key combo\n\t      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n\t        cm.replaceSelection(\"\");\n\t    }\n\t  }\n\t\n\t  function onKeyPress(e) {\n\t    var cm = this;\n\t    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n\t    var keyCode = e.keyCode, charCode = e.charCode;\n\t    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n\t    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;\n\t    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n\t    if (handleCharBinding(cm, e, ch)) return;\n\t    if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n\t    fastPoll(cm);\n\t  }\n\t\n\t  function onFocus(cm) {\n\t    if (cm.options.readOnly == \"nocursor\") return;\n\t    if (!cm.state.focused) {\n\t      signal(cm, \"focus\", cm);\n\t      cm.state.focused = true;\n\t      if (cm.display.wrapper.className.search(/\\bCodeMirror-focused\\b/) == -1)\n\t        cm.display.wrapper.className += \" CodeMirror-focused\";\n\t      if (!cm.curOp) {\n\t        resetInput(cm, true);\n\t        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730\n\t      }\n\t    }\n\t    slowPoll(cm);\n\t    restartBlink(cm);\n\t  }\n\t  function onBlur(cm) {\n\t    if (cm.state.focused) {\n\t      signal(cm, \"blur\", cm);\n\t      cm.state.focused = false;\n\t      cm.display.wrapper.className = cm.display.wrapper.className.replace(\" CodeMirror-focused\", \"\");\n\t    }\n\t    clearInterval(cm.display.blinker);\n\t    setTimeout(function() {if (!cm.state.focused) cm.doc.sel.shift = false;}, 150);\n\t  }\n\t\n\t  var detectingSelectAll;\n\t  function onContextMenu(cm, e) {\n\t    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n\t    var display = cm.display, sel = cm.doc.sel;\n\t    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;\n\t\n\t    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n\t    if (!pos || opera) return; // Opera is difficult.\n\t\n\t    // Reset the current text selection only if the click is done outside of the selection\n\t    // and 'resetSelectionOnContextMenu' option is true.\n\t    var reset = cm.options.resetSelectionOnContextMenu;\n\t    if (reset && (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to)))\n\t      operation(cm, setSelection)(cm.doc, pos, pos);\n\t\n\t    var oldCSS = display.input.style.cssText;\n\t    display.inputDiv.style.position = \"absolute\";\n\t    display.input.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n\t      \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: transparent; outline: none;\" +\n\t      \"border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);\";\n\t    focusInput(cm);\n\t    resetInput(cm, true);\n\t    // Adds \"Select all\" to context menu in FF\n\t    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = \" \";\n\t\n\t    function prepareSelectAllHack() {\n\t      if (display.input.selectionStart != null) {\n\t        var extval = display.input.value = \"\\u200b\" + (posEq(sel.from, sel.to) ? \"\" : display.input.value);\n\t        display.prevInput = \"\\u200b\";\n\t        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;\n\t      }\n\t    }\n\t    function rehide() {\n\t      display.inputDiv.style.position = \"relative\";\n\t      display.input.style.cssText = oldCSS;\n\t      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\n\t      slowPoll(cm);\n\t\n\t      // Try to detect the user choosing select-all\n\t      if (display.input.selectionStart != null) {\n\t        if (!ie || ie_lt9) prepareSelectAllHack();\n\t        clearTimeout(detectingSelectAll);\n\t        var i = 0, poll = function(){\n\t          if (display.prevInput == \"\\u200b\" && display.input.selectionStart == 0)\n\t            operation(cm, commands.selectAll)(cm);\n\t          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);\n\t          else resetInput(cm);\n\t        };\n\t        detectingSelectAll = setTimeout(poll, 200);\n\t      }\n\t    }\n\t\n\t    if (ie && !ie_lt9) prepareSelectAllHack();\n\t    if (captureMiddleClick) {\n\t      e_stop(e);\n\t      var mouseup = function() {\n\t        off(window, \"mouseup\", mouseup);\n\t        setTimeout(rehide, 20);\n\t      };\n\t      on(window, \"mouseup\", mouseup);\n\t    } else {\n\t      setTimeout(rehide, 50);\n\t    }\n\t  }\n\t\n\t  // UPDATING\n\t\n\t  var changeEnd = CodeMirror.changeEnd = function(change) {\n\t    if (!change.text) return change.to;\n\t    return Pos(change.from.line + change.text.length - 1,\n\t               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n\t  };\n\t\n\t  // Make sure a position will be valid after the given change.\n\t  function clipPostChange(doc, change, pos) {\n\t    if (!posLess(change.from, pos)) return clipPos(doc, pos);\n\t    var diff = (change.text.length - 1) - (change.to.line - change.from.line);\n\t    if (pos.line > change.to.line + diff) {\n\t      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;\n\t      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);\n\t      return clipToLen(pos, getLine(doc, preLine).text.length);\n\t    }\n\t    if (pos.line == change.to.line + diff)\n\t      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) +\n\t                       getLine(doc, change.to.line).text.length - change.to.ch);\n\t    var inside = pos.line - change.from.line;\n\t    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));\n\t  }\n\t\n\t  // Hint can be null|\"end\"|\"start\"|\"around\"|{anchor,head}\n\t  function computeSelAfterChange(doc, change, hint) {\n\t    if (hint && typeof hint == \"object\") // Assumed to be {anchor, head} object\n\t      return {anchor: clipPostChange(doc, change, hint.anchor),\n\t              head: clipPostChange(doc, change, hint.head)};\n\t\n\t    if (hint == \"start\") return {anchor: change.from, head: change.from};\n\t\n\t    var end = changeEnd(change);\n\t    if (hint == \"around\") return {anchor: change.from, head: end};\n\t    if (hint == \"end\") return {anchor: end, head: end};\n\t\n\t    // hint is null, leave the selection alone as much as possible\n\t    var adjustPos = function(pos) {\n\t      if (posLess(pos, change.from)) return pos;\n\t      if (!posLess(change.to, pos)) return end;\n\t\n\t      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n\t      if (pos.line == change.to.line) ch += end.ch - change.to.ch;\n\t      return Pos(line, ch);\n\t    };\n\t    return {anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head)};\n\t  }\n\t\n\t  function filterChange(doc, change, update) {\n\t    var obj = {\n\t      canceled: false,\n\t      from: change.from,\n\t      to: change.to,\n\t      text: change.text,\n\t      origin: change.origin,\n\t      cancel: function() { this.canceled = true; }\n\t    };\n\t    if (update) obj.update = function(from, to, text, origin) {\n\t      if (from) this.from = clipPos(doc, from);\n\t      if (to) this.to = clipPos(doc, to);\n\t      if (text) this.text = text;\n\t      if (origin !== undefined) this.origin = origin;\n\t    };\n\t    signal(doc, \"beforeChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\t\n\t    if (obj.canceled) return null;\n\t    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n\t  }\n\t\n\t  // Replace the range from from to to by the strings in replacement.\n\t  // change is a {from, to, text [, origin]} object\n\t  function makeChange(doc, change, selUpdate, ignoreReadOnly) {\n\t    if (doc.cm) {\n\t      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);\n\t      if (doc.cm.state.suppressEdits) return;\n\t    }\n\t\n\t    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n\t      change = filterChange(doc, change, true);\n\t      if (!change) return;\n\t    }\n\t\n\t    // Possibly split or suppress the update based on the presence\n\t    // of read-only spans in its range.\n\t    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n\t    if (split) {\n\t      for (var i = split.length - 1; i >= 1; --i)\n\t        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [\"\"]});\n\t      if (split.length)\n\t        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);\n\t    } else {\n\t      makeChangeNoReadonly(doc, change, selUpdate);\n\t    }\n\t  }\n\t\n\t  function makeChangeNoReadonly(doc, change, selUpdate) {\n\t    if (change.text.length == 1 && change.text[0] == \"\" && posEq(change.from, change.to)) return;\n\t    var selAfter = computeSelAfterChange(doc, change, selUpdate);\n\t    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\t\n\t    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n\t    var rebased = [];\n\t\n\t    linkedDocs(doc, function(doc, sharedHist) {\n\t      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t        rebaseHist(doc.history, change);\n\t        rebased.push(doc.history);\n\t      }\n\t      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n\t    });\n\t  }\n\t\n\t  function makeChangeFromHistory(doc, type) {\n\t    if (doc.cm && doc.cm.state.suppressEdits) return;\n\t\n\t    var hist = doc.history;\n\t    var event = (type == \"undo\" ? hist.done : hist.undone).pop();\n\t    if (!event) return;\n\t\n\t    var anti = {changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,\n\t                anchorAfter: event.anchorBefore, headAfter: event.headBefore,\n\t                generation: hist.generation};\n\t    (type == \"undo\" ? hist.undone : hist.done).push(anti);\n\t    hist.generation = event.generation || ++hist.maxGeneration;\n\t\n\t    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\t\n\t    for (var i = event.changes.length - 1; i >= 0; --i) {\n\t      var change = event.changes[i];\n\t      change.origin = type;\n\t      if (filter && !filterChange(doc, change, false)) {\n\t        (type == \"undo\" ? hist.done : hist.undone).length = 0;\n\t        return;\n\t      }\n\t\n\t      anti.changes.push(historyChangeFromChange(doc, change));\n\t\n\t      var after = i ? computeSelAfterChange(doc, change, null)\n\t                    : {anchor: event.anchorBefore, head: event.headBefore};\n\t      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n\t      var rebased = [];\n\t\n\t      linkedDocs(doc, function(doc, sharedHist) {\n\t        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t          rebaseHist(doc.history, change);\n\t          rebased.push(doc.history);\n\t        }\n\t        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n\t      });\n\t    }\n\t  }\n\t\n\t  function shiftDoc(doc, distance) {\n\t    function shiftPos(pos) {return Pos(pos.line + distance, pos.ch);}\n\t    doc.first += distance;\n\t    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);\n\t    doc.sel.head = shiftPos(doc.sel.head); doc.sel.anchor = shiftPos(doc.sel.anchor);\n\t    doc.sel.from = shiftPos(doc.sel.from); doc.sel.to = shiftPos(doc.sel.to);\n\t  }\n\t\n\t  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n\t    if (doc.cm && !doc.cm.curOp)\n\t      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\t\n\t    if (change.to.line < doc.first) {\n\t      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n\t      return;\n\t    }\n\t    if (change.from.line > doc.lastLine()) return;\n\t\n\t    // Clip the change to the size of this doc\n\t    if (change.from.line < doc.first) {\n\t      var shift = change.text.length - 1 - (doc.first - change.from.line);\n\t      shiftDoc(doc, shift);\n\t      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n\t                text: [lst(change.text)], origin: change.origin};\n\t    }\n\t    var last = doc.lastLine();\n\t    if (change.to.line > last) {\n\t      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n\t                text: [change.text[0]], origin: change.origin};\n\t    }\n\t\n\t    change.removed = getBetween(doc, change.from, change.to);\n\t\n\t    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);\n\t    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);\n\t    else updateDoc(doc, change, spans, selAfter);\n\t  }\n\t\n\t  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {\n\t    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\t\n\t    var recomputeMaxLength = false, checkWidthStart = from.line;\n\t    if (!cm.options.lineWrapping) {\n\t      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));\n\t      doc.iter(checkWidthStart, to.line + 1, function(line) {\n\t        if (line == display.maxLine) {\n\t          recomputeMaxLength = true;\n\t          return true;\n\t        }\n\t      });\n\t    }\n\t\n\t    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))\n\t      cm.curOp.cursorActivity = true;\n\t\n\t    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));\n\t\n\t    if (!cm.options.lineWrapping) {\n\t      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n\t        var len = lineLength(doc, line);\n\t        if (len > display.maxLineLength) {\n\t          display.maxLine = line;\n\t          display.maxLineLength = len;\n\t          display.maxLineChanged = true;\n\t          recomputeMaxLength = false;\n\t        }\n\t      });\n\t      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n\t    }\n\t\n\t    // Adjust frontier, schedule worker\n\t    doc.frontier = Math.min(doc.frontier, from.line);\n\t    startWorker(cm, 400);\n\t\n\t    var lendiff = change.text.length - (to.line - from.line) - 1;\n\t    // Remember that these lines changed, for updating the display\n\t    regChange(cm, from.line, to.line + 1, lendiff);\n\t\n\t    if (hasHandler(cm, \"change\")) {\n\t      var changeObj = {from: from, to: to,\n\t                       text: change.text,\n\t                       removed: change.removed,\n\t                       origin: change.origin};\n\t      if (cm.curOp.textChanged) {\n\t        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}\n\t        cur.next = changeObj;\n\t      } else cm.curOp.textChanged = changeObj;\n\t    }\n\t  }\n\t\n\t  function replaceRange(doc, code, from, to, origin) {\n\t    if (!to) to = from;\n\t    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }\n\t    if (typeof code == \"string\") code = splitLines(code);\n\t    makeChange(doc, {from: from, to: to, text: code, origin: origin}, null);\n\t  }\n\t\n\t  // POSITION OBJECT\n\t\n\t  function Pos(line, ch) {\n\t    if (!(this instanceof Pos)) return new Pos(line, ch);\n\t    this.line = line; this.ch = ch;\n\t  }\n\t  CodeMirror.Pos = Pos;\n\t\n\t  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n\t  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n\t  function cmp(a, b) {return a.line - b.line || a.ch - b.ch;}\n\t  function copyPos(x) {return Pos(x.line, x.ch);}\n\t\n\t  // SELECTION\n\t\n\t  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n\t  function clipPos(doc, pos) {\n\t    if (pos.line < doc.first) return Pos(doc.first, 0);\n\t    var last = doc.first + doc.size - 1;\n\t    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n\t    return clipToLen(pos, getLine(doc, pos.line).text.length);\n\t  }\n\t  function clipToLen(pos, linelen) {\n\t    var ch = pos.ch;\n\t    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n\t    else if (ch < 0) return Pos(pos.line, 0);\n\t    else return pos;\n\t  }\n\t  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\t\n\t  // If shift is held, this will move the selection anchor. Otherwise,\n\t  // it'll set the whole selection.\n\t  function extendSelection(doc, pos, other, bias) {\n\t    if (doc.sel.shift || doc.sel.extend) {\n\t      var anchor = doc.sel.anchor;\n\t      if (other) {\n\t        var posBefore = posLess(pos, anchor);\n\t        if (posBefore != posLess(other, anchor)) {\n\t          anchor = pos;\n\t          pos = other;\n\t        } else if (posBefore != posLess(pos, other)) {\n\t          pos = other;\n\t        }\n\t      }\n\t      setSelection(doc, anchor, pos, bias);\n\t    } else {\n\t      setSelection(doc, pos, other || pos, bias);\n\t    }\n\t    if (doc.cm) doc.cm.curOp.userSelChange = true;\n\t  }\n\t\n\t  function filterSelectionChange(doc, anchor, head) {\n\t    var obj = {anchor: anchor, head: head};\n\t    signal(doc, \"beforeSelectionChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n\t    obj.anchor = clipPos(doc, obj.anchor); obj.head = clipPos(doc, obj.head);\n\t    return obj;\n\t  }\n\t\n\t  // Update the selection. Last two args are only used by\n\t  // updateDoc, since they have to be expressed in the line\n\t  // numbers before the update.\n\t  function setSelection(doc, anchor, head, bias, checkAtomic) {\n\t    if (!checkAtomic && hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\")) {\n\t      var filtered = filterSelectionChange(doc, anchor, head);\n\t      head = filtered.head;\n\t      anchor = filtered.anchor;\n\t    }\n\t\n\t    var sel = doc.sel;\n\t    sel.goalColumn = null;\n\t    if (bias == null) bias = posLess(head, sel.head) ? -1 : 1;\n\t    // Skip over atomic spans.\n\t    if (checkAtomic || !posEq(anchor, sel.anchor))\n\t      anchor = skipAtomic(doc, anchor, bias, checkAtomic != \"push\");\n\t    if (checkAtomic || !posEq(head, sel.head))\n\t      head = skipAtomic(doc, head, bias, checkAtomic != \"push\");\n\t\n\t    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;\n\t\n\t    sel.anchor = anchor; sel.head = head;\n\t    var inv = posLess(head, anchor);\n\t    sel.from = inv ? head : anchor;\n\t    sel.to = inv ? anchor : head;\n\t\n\t    if (doc.cm)\n\t      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged =\n\t        doc.cm.curOp.cursorActivity = true;\n\t\n\t    signalLater(doc, \"cursorActivity\", doc);\n\t  }\n\t\n\t  function reCheckSelection(cm) {\n\t    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, \"push\");\n\t  }\n\t\n\t  function skipAtomic(doc, pos, bias, mayClear) {\n\t    var flipped = false, curPos = pos;\n\t    var dir = bias || 1;\n\t    doc.cantEdit = false;\n\t    search: for (;;) {\n\t      var line = getLine(doc, curPos.line);\n\t      if (line.markedSpans) {\n\t        for (var i = 0; i < line.markedSpans.length; ++i) {\n\t          var sp = line.markedSpans[i], m = sp.marker;\n\t          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n\t              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n\t            if (mayClear) {\n\t              signal(m, \"beforeCursorEnter\");\n\t              if (m.explicitlyCleared) {\n\t                if (!line.markedSpans) break;\n\t                else {--i; continue;}\n\t              }\n\t            }\n\t            if (!m.atomic) continue;\n\t            var newPos = m.find()[dir < 0 ? \"from\" : \"to\"];\n\t            if (posEq(newPos, curPos)) {\n\t              newPos.ch += dir;\n\t              if (newPos.ch < 0) {\n\t                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n\t                else newPos = null;\n\t              } else if (newPos.ch > line.text.length) {\n\t                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n\t                else newPos = null;\n\t              }\n\t              if (!newPos) {\n\t                if (flipped) {\n\t                  // Driven in a corner -- no valid cursor position found at all\n\t                  // -- try again *with* clearing, if we didn't already\n\t                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n\t                  // Otherwise, turn off editing until further notice, and return the start of the doc\n\t                  doc.cantEdit = true;\n\t                  return Pos(doc.first, 0);\n\t                }\n\t                flipped = true; newPos = pos; dir = -dir;\n\t              }\n\t            }\n\t            curPos = newPos;\n\t            continue search;\n\t          }\n\t        }\n\t      }\n\t      return curPos;\n\t    }\n\t  }\n\t\n\t  // SCROLLING\n\t\n\t  function scrollCursorIntoView(cm) {\n\t    var coords = scrollPosIntoView(cm, cm.doc.sel.head, null, cm.options.cursorScrollMargin);\n\t    if (!cm.state.focused) return;\n\t    var display = cm.display, box = getRect(display.sizer), doScroll = null;\n\t    if (coords.top + box.top < 0) doScroll = true;\n\t    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n\t    if (doScroll != null && !phantom) {\n\t      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n\t                           (coords.top - display.viewOffset) + \"px; height: \" +\n\t                           (coords.bottom - coords.top + scrollerCutOff) + \"px; left: \" +\n\t                           coords.left + \"px; width: 2px;\");\n\t      cm.display.lineSpace.appendChild(scrollNode);\n\t      scrollNode.scrollIntoView(doScroll);\n\t      cm.display.lineSpace.removeChild(scrollNode);\n\t    }\n\t  }\n\t\n\t  function scrollPosIntoView(cm, pos, end, margin) {\n\t    if (margin == null) margin = 0;\n\t    for (;;) {\n\t      var changed = false, coords = cursorCoords(cm, pos);\n\t      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n\t      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n\t                                         Math.min(coords.top, endCoords.top) - margin,\n\t                                         Math.max(coords.left, endCoords.left),\n\t                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n\t      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n\t      if (scrollPos.scrollTop != null) {\n\t        setScrollTop(cm, scrollPos.scrollTop);\n\t        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n\t      }\n\t      if (scrollPos.scrollLeft != null) {\n\t        setScrollLeft(cm, scrollPos.scrollLeft);\n\t        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n\t      }\n\t      if (!changed) return coords;\n\t    }\n\t  }\n\t\n\t  function scrollIntoView(cm, x1, y1, x2, y2) {\n\t    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n\t    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n\t    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n\t  }\n\t\n\t  function calculateScrollPos(cm, x1, y1, x2, y2) {\n\t    var display = cm.display, snapMargin = textHeight(cm.display);\n\t    if (y1 < 0) y1 = 0;\n\t    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};\n\t    var docBottom = cm.doc.height + paddingVert(display);\n\t    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n\t    if (y1 < screentop) {\n\t      result.scrollTop = atTop ? 0 : y1;\n\t    } else if (y2 > screentop + screen) {\n\t      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n\t      if (newTop != screentop) result.scrollTop = newTop;\n\t    }\n\t\n\t    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;\n\t    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;\n\t    var gutterw = display.gutters.offsetWidth;\n\t    var atLeft = x1 < gutterw + 10;\n\t    if (x1 < screenleft + gutterw || atLeft) {\n\t      if (atLeft) x1 = 0;\n\t      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n\t    } else if (x2 > screenw + screenleft - 3) {\n\t      result.scrollLeft = x2 + 10 - screenw;\n\t    }\n\t    return result;\n\t  }\n\t\n\t  function updateScrollPos(cm, left, top) {\n\t    cm.curOp.updateScrollPos = {scrollLeft: left == null ? cm.doc.scrollLeft : left,\n\t                                scrollTop: top == null ? cm.doc.scrollTop : top};\n\t  }\n\t\n\t  function addToScrollPos(cm, left, top) {\n\t    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop});\n\t    var scroll = cm.display.scroller;\n\t    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));\n\t    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));\n\t  }\n\t\n\t  // API UTILITIES\n\t\n\t  function indentLine(cm, n, how, aggressive) {\n\t    var doc = cm.doc, state;\n\t    if (how == null) how = \"add\";\n\t    if (how == \"smart\") {\n\t      if (!cm.doc.mode.indent) how = \"prev\";\n\t      else state = getStateBefore(cm, n);\n\t    }\n\t\n\t    var tabSize = cm.options.tabSize;\n\t    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n\t    if (!aggressive && !/\\S/.test(line.text)) {\n\t      indentation = 0;\n\t      how = \"not\";\n\t    } else if (how == \"smart\") {\n\t      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n\t      if (indentation == Pass) {\n\t        if (!aggressive) return;\n\t        how = \"prev\";\n\t      }\n\t    }\n\t    if (how == \"prev\") {\n\t      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n\t      else indentation = 0;\n\t    } else if (how == \"add\") {\n\t      indentation = curSpace + cm.options.indentUnit;\n\t    } else if (how == \"subtract\") {\n\t      indentation = curSpace - cm.options.indentUnit;\n\t    } else if (typeof how == \"number\") {\n\t      indentation = curSpace + how;\n\t    }\n\t    indentation = Math.max(0, indentation);\n\t\n\t    var indentString = \"\", pos = 0;\n\t    if (cm.options.indentWithTabs)\n\t      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n\t    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\t\n\t    if (indentString != curSpaceString)\n\t      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n\t    else if (doc.sel.head.line == n && doc.sel.head.ch < curSpaceString.length)\n\t      setSelection(doc, Pos(n, curSpaceString.length), Pos(n, curSpaceString.length), 1);\n\t    line.stateAfter = null;\n\t  }\n\t\n\t  function changeLine(cm, handle, op) {\n\t    var no = handle, line = handle, doc = cm.doc;\n\t    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n\t    else no = lineNo(handle);\n\t    if (no == null) return null;\n\t    if (op(line, no)) regChange(cm, no, no + 1);\n\t    else return null;\n\t    return line;\n\t  }\n\t\n\t  function findPosH(doc, pos, dir, unit, visually) {\n\t    var line = pos.line, ch = pos.ch, origDir = dir;\n\t    var lineObj = getLine(doc, line);\n\t    var possible = true;\n\t    function findNextLine() {\n\t      var l = line + dir;\n\t      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n\t      line = l;\n\t      return lineObj = getLine(doc, l);\n\t    }\n\t    function moveOnce(boundToLine) {\n\t      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n\t      if (next == null) {\n\t        if (!boundToLine && findNextLine()) {\n\t          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n\t          else ch = dir < 0 ? lineObj.text.length : 0;\n\t        } else return (possible = false);\n\t      } else ch = next;\n\t      return true;\n\t    }\n\t\n\t    if (unit == \"char\") moveOnce();\n\t    else if (unit == \"column\") moveOnce(true);\n\t    else if (unit == \"word\" || unit == \"group\") {\n\t      var sawType = null, group = unit == \"group\";\n\t      for (var first = true;; first = false) {\n\t        if (dir < 0 && !moveOnce(!first)) break;\n\t        var cur = lineObj.text.charAt(ch) || \"\\n\";\n\t        var type = isWordChar(cur) ? \"w\"\n\t          : group && cur == \"\\n\" ? \"n\"\n\t          : !group || /\\s/.test(cur) ? null\n\t          : \"p\";\n\t        if (group && !first && !type) type = \"s\";\n\t        if (sawType && sawType != type) {\n\t          if (dir < 0) {dir = 1; moveOnce();}\n\t          break;\n\t        }\n\t\n\t        if (type) sawType = type;\n\t        if (dir > 0 && !moveOnce(!first)) break;\n\t      }\n\t    }\n\t    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n\t    if (!possible) result.hitSide = true;\n\t    return result;\n\t  }\n\t\n\t  function findPosV(cm, pos, dir, unit) {\n\t    var doc = cm.doc, x = pos.left, y;\n\t    if (unit == \"page\") {\n\t      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n\t      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n\t    } else if (unit == \"line\") {\n\t      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n\t    }\n\t    for (;;) {\n\t      var target = coordsChar(cm, x, y);\n\t      if (!target.outside) break;\n\t      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n\t      y += dir * 5;\n\t    }\n\t    return target;\n\t  }\n\t\n\t  function findWordAt(line, pos) {\n\t    var start = pos.ch, end = pos.ch;\n\t    if (line) {\n\t      if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n\t      var startChar = line.charAt(start);\n\t      var check = isWordChar(startChar) ? isWordChar\n\t        : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n\t        : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n\t      while (start > 0 && check(line.charAt(start - 1))) --start;\n\t      while (end < line.length && check(line.charAt(end))) ++end;\n\t    }\n\t    return {from: Pos(pos.line, start), to: Pos(pos.line, end)};\n\t  }\n\t\n\t  function selectLine(cm, line) {\n\t    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));\n\t  }\n\t\n\t  // PROTOTYPE\n\t\n\t  // The publicly visible API. Note that operation(null, f) means\n\t  // 'wrap f in an operation, performed on its `this` parameter'\n\t\n\t  CodeMirror.prototype = {\n\t    constructor: CodeMirror,\n\t    focus: function(){window.focus(); focusInput(this); fastPoll(this);},\n\t\n\t    setOption: function(option, value) {\n\t      var options = this.options, old = options[option];\n\t      if (options[option] == value && option != \"mode\") return;\n\t      options[option] = value;\n\t      if (optionHandlers.hasOwnProperty(option))\n\t        operation(this, optionHandlers[option])(this, value, old);\n\t    },\n\t\n\t    getOption: function(option) {return this.options[option];},\n\t    getDoc: function() {return this.doc;},\n\t\n\t    addKeyMap: function(map, bottom) {\n\t      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](map);\n\t    },\n\t    removeKeyMap: function(map) {\n\t      var maps = this.state.keyMaps;\n\t      for (var i = 0; i < maps.length; ++i)\n\t        if (maps[i] == map || (typeof maps[i] != \"string\" && maps[i].name == map)) {\n\t          maps.splice(i, 1);\n\t          return true;\n\t        }\n\t    },\n\t\n\t    addOverlay: operation(null, function(spec, options) {\n\t      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n\t      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n\t      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n\t      this.state.modeGen++;\n\t      regChange(this);\n\t    }),\n\t    removeOverlay: operation(null, function(spec) {\n\t      var overlays = this.state.overlays;\n\t      for (var i = 0; i < overlays.length; ++i) {\n\t        var cur = overlays[i].modeSpec;\n\t        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n\t          overlays.splice(i, 1);\n\t          this.state.modeGen++;\n\t          regChange(this);\n\t          return;\n\t        }\n\t      }\n\t    }),\n\t\n\t    indentLine: operation(null, function(n, dir, aggressive) {\n\t      if (typeof dir != \"string\" && typeof dir != \"number\") {\n\t        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n\t        else dir = dir ? \"add\" : \"subtract\";\n\t      }\n\t      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n\t    }),\n\t    indentSelection: operation(null, function(how) {\n\t      var sel = this.doc.sel;\n\t      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how, true);\n\t      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n\t      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);\n\t    }),\n\t\n\t    // Fetch the parser token for a given character. Useful for hacks\n\t    // that want to inspect the mode state (say, for completion).\n\t    getTokenAt: function(pos, precise) {\n\t      var doc = this.doc;\n\t      pos = clipPos(doc, pos);\n\t      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;\n\t      var line = getLine(doc, pos.line);\n\t      var stream = new StringStream(line.text, this.options.tabSize);\n\t      while (stream.pos < pos.ch && !stream.eol()) {\n\t        stream.start = stream.pos;\n\t        var style = mode.token(stream, state);\n\t      }\n\t      return {start: stream.start,\n\t              end: stream.pos,\n\t              string: stream.current(),\n\t              className: style || null, // Deprecated, use 'type' instead\n\t              type: style || null,\n\t              state: state};\n\t    },\n\t\n\t    getTokenTypeAt: function(pos) {\n\t      pos = clipPos(this.doc, pos);\n\t      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n\t      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n\t      if (ch == 0) return styles[2];\n\t      for (;;) {\n\t        var mid = (before + after) >> 1;\n\t        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n\t        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n\t        else return styles[mid * 2 + 2];\n\t      }\n\t    },\n\t\n\t    getModeAt: function(pos) {\n\t      var mode = this.doc.mode;\n\t      if (!mode.innerMode) return mode;\n\t      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n\t    },\n\t\n\t    getHelper: function(pos, type) {\n\t      return this.getHelpers(pos, type)[0];\n\t    },\n\t\n\t    getHelpers: function(pos, type) {\n\t      var found = [];\n\t      if (!helpers.hasOwnProperty(type)) return helpers;\n\t      var help = helpers[type], mode = this.getModeAt(pos);\n\t      if (typeof mode[type] == \"string\") {\n\t        if (help[mode[type]]) found.push(help[mode[type]]);\n\t      } else if (mode[type]) {\n\t        for (var i = 0; i < mode[type].length; i++) {\n\t          var val = help[mode[type][i]];\n\t          if (val) found.push(val);\n\t        }\n\t      } else if (mode.helperType && help[mode.helperType]) {\n\t        found.push(help[mode.helperType]);\n\t      } else if (help[mode.name]) {\n\t        found.push(help[mode.name]);\n\t      }\n\t      for (var i = 0; i < help._global.length; i++) {\n\t        var cur = help._global[i];\n\t        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n\t          found.push(cur.val);\n\t      }\n\t      return found;\n\t    },\n\t\n\t    getStateAfter: function(line, precise) {\n\t      var doc = this.doc;\n\t      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n\t      return getStateBefore(this, line + 1, precise);\n\t    },\n\t\n\t    cursorCoords: function(start, mode) {\n\t      var pos, sel = this.doc.sel;\n\t      if (start == null) pos = sel.head;\n\t      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n\t      else pos = start ? sel.from : sel.to;\n\t      return cursorCoords(this, pos, mode || \"page\");\n\t    },\n\t\n\t    charCoords: function(pos, mode) {\n\t      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n\t    },\n\t\n\t    coordsChar: function(coords, mode) {\n\t      coords = fromCoordSystem(this, coords, mode || \"page\");\n\t      return coordsChar(this, coords.left, coords.top);\n\t    },\n\t\n\t    lineAtHeight: function(height, mode) {\n\t      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n\t      return lineAtHeight(this.doc, height + this.display.viewOffset);\n\t    },\n\t    heightAtLine: function(line, mode) {\n\t      var end = false, last = this.doc.first + this.doc.size - 1;\n\t      if (line < this.doc.first) line = this.doc.first;\n\t      else if (line > last) { line = last; end = true; }\n\t      var lineObj = getLine(this.doc, line);\n\t      return intoCoordSystem(this, getLine(this.doc, line), {top: 0, left: 0}, mode || \"page\").top +\n\t        (end ? lineObj.height : 0);\n\t    },\n\t\n\t    defaultTextHeight: function() { return textHeight(this.display); },\n\t    defaultCharWidth: function() { return charWidth(this.display); },\n\t\n\t    setGutterMarker: operation(null, function(line, gutterID, value) {\n\t      return changeLine(this, line, function(line) {\n\t        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n\t        markers[gutterID] = value;\n\t        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    clearGutter: operation(null, function(gutterID) {\n\t      var cm = this, doc = cm.doc, i = doc.first;\n\t      doc.iter(function(line) {\n\t        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n\t          line.gutterMarkers[gutterID] = null;\n\t          regChange(cm, i, i + 1);\n\t          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n\t        }\n\t        ++i;\n\t      });\n\t    }),\n\t\n\t    addLineClass: operation(null, function(handle, where, cls) {\n\t      return changeLine(this, handle, function(line) {\n\t        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n\t        if (!line[prop]) line[prop] = cls;\n\t        else if (new RegExp(\"(?:^|\\\\s)\" + cls + \"(?:$|\\\\s)\").test(line[prop])) return false;\n\t        else line[prop] += \" \" + cls;\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    removeLineClass: operation(null, function(handle, where, cls) {\n\t      return changeLine(this, handle, function(line) {\n\t        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n\t        var cur = line[prop];\n\t        if (!cur) return false;\n\t        else if (cls == null) line[prop] = null;\n\t        else {\n\t          var found = cur.match(new RegExp(\"(?:^|\\\\s+)\" + cls + \"(?:$|\\\\s+)\"));\n\t          if (!found) return false;\n\t          var end = found.index + found[0].length;\n\t          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n\t        }\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    addLineWidget: operation(null, function(handle, node, options) {\n\t      return addLineWidget(this, handle, node, options);\n\t    }),\n\t\n\t    removeLineWidget: function(widget) { widget.clear(); },\n\t\n\t    lineInfo: function(line) {\n\t      if (typeof line == \"number\") {\n\t        if (!isLine(this.doc, line)) return null;\n\t        var n = line;\n\t        line = getLine(this.doc, line);\n\t        if (!line) return null;\n\t      } else {\n\t        var n = lineNo(line);\n\t        if (n == null) return null;\n\t      }\n\t      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n\t              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n\t              widgets: line.widgets};\n\t    },\n\t\n\t    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},\n\t\n\t    addWidget: function(pos, node, scroll, vert, horiz) {\n\t      var display = this.display;\n\t      pos = cursorCoords(this, clipPos(this.doc, pos));\n\t      var top = pos.bottom, left = pos.left;\n\t      node.style.position = \"absolute\";\n\t      display.sizer.appendChild(node);\n\t      if (vert == \"over\") {\n\t        top = pos.top;\n\t      } else if (vert == \"above\" || vert == \"near\") {\n\t        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n\t        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n\t        // Default to positioning above (if specified and possible); otherwise default to positioning below\n\t        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n\t          top = pos.top - node.offsetHeight;\n\t        else if (pos.bottom + node.offsetHeight <= vspace)\n\t          top = pos.bottom;\n\t        if (left + node.offsetWidth > hspace)\n\t          left = hspace - node.offsetWidth;\n\t      }\n\t      node.style.top = top + \"px\";\n\t      node.style.left = node.style.right = \"\";\n\t      if (horiz == \"right\") {\n\t        left = display.sizer.clientWidth - node.offsetWidth;\n\t        node.style.right = \"0px\";\n\t      } else {\n\t        if (horiz == \"left\") left = 0;\n\t        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n\t        node.style.left = left + \"px\";\n\t      }\n\t      if (scroll)\n\t        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n\t    },\n\t\n\t    triggerOnKeyDown: operation(null, onKeyDown),\n\t    triggerOnKeyPress: operation(null, onKeyPress),\n\t    triggerOnKeyUp: operation(null, onKeyUp),\n\t\n\t    execCommand: function(cmd) {\n\t      if (commands.hasOwnProperty(cmd))\n\t        return commands[cmd](this);\n\t    },\n\t\n\t    findPosH: function(from, amount, unit, visually) {\n\t      var dir = 1;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        cur = findPosH(this.doc, cur, dir, unit, visually);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveH: operation(null, function(dir, unit) {\n\t      var sel = this.doc.sel, pos;\n\t      if (sel.shift || sel.extend || posEq(sel.from, sel.to))\n\t        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);\n\t      else\n\t        pos = dir < 0 ? sel.from : sel.to;\n\t      extendSelection(this.doc, pos, pos, dir);\n\t    }),\n\t\n\t    deleteH: operation(null, function(dir, unit) {\n\t      var sel = this.doc.sel;\n\t      if (!posEq(sel.from, sel.to)) replaceRange(this.doc, \"\", sel.from, sel.to, \"+delete\");\n\t      else replaceRange(this.doc, \"\", sel.from, findPosH(this.doc, sel.head, dir, unit, false), \"+delete\");\n\t      this.curOp.userSelChange = true;\n\t    }),\n\t\n\t    findPosV: function(from, amount, unit, goalColumn) {\n\t      var dir = 1, x = goalColumn;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        var coords = cursorCoords(this, cur, \"div\");\n\t        if (x == null) x = coords.left;\n\t        else coords.left = x;\n\t        cur = findPosV(this, coords, dir, unit);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveV: operation(null, function(dir, unit) {\n\t      var sel = this.doc.sel, target, goal;\n\t      if (sel.shift || sel.extend || posEq(sel.from, sel.to)) {\n\t        var pos = cursorCoords(this, sel.head, \"div\");\n\t        if (sel.goalColumn != null) pos.left = sel.goalColumn;\n\t        target = findPosV(this, pos, dir, unit);\n\t        if (unit == \"page\") addToScrollPos(this, 0, charCoords(this, target, \"div\").top - pos.top);\n\t        goal = pos.left;\n\t      } else {\n\t        target = dir < 0 ? sel.from : sel.to;\n\t      }\n\t      extendSelection(this.doc, target, target, dir);\n\t      if (goal != null) sel.goalColumn = goal;\n\t    }),\n\t\n\t    toggleOverwrite: function(value) {\n\t      if (value != null && value == this.state.overwrite) return;\n\t      if (this.state.overwrite = !this.state.overwrite)\n\t        this.display.cursor.className += \" CodeMirror-overwrite\";\n\t      else\n\t        this.display.cursor.className = this.display.cursor.className.replace(\" CodeMirror-overwrite\", \"\");\n\t\n\t      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n\t    },\n\t    hasFocus: function() { return document.activeElement == this.display.input; },\n\t\n\t    scrollTo: operation(null, function(x, y) {\n\t      updateScrollPos(this, x, y);\n\t    }),\n\t    getScrollInfo: function() {\n\t      var scroller = this.display.scroller, co = scrollerCutOff;\n\t      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n\t              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,\n\t              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};\n\t    },\n\t\n\t    scrollIntoView: operation(null, function(range, margin) {\n\t      if (range == null) range = {from: this.doc.sel.head, to: null};\n\t      else if (typeof range == \"number\") range = {from: Pos(range, 0), to: null};\n\t      else if (range.from == null) range = {from: range, to: null};\n\t      if (!range.to) range.to = range.from;\n\t      if (!margin) margin = 0;\n\t\n\t      var coords = range;\n\t      if (range.from.line != null) {\n\t        this.curOp.scrollToPos = {from: range.from, to: range.to, margin: margin};\n\t        coords = {from: cursorCoords(this, range.from),\n\t                  to: cursorCoords(this, range.to)};\n\t      }\n\t      var sPos = calculateScrollPos(this, Math.min(coords.from.left, coords.to.left),\n\t                                    Math.min(coords.from.top, coords.to.top) - margin,\n\t                                    Math.max(coords.from.right, coords.to.right),\n\t                                    Math.max(coords.from.bottom, coords.to.bottom) + margin);\n\t      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);\n\t    }),\n\t\n\t    setSize: operation(null, function(width, height) {\n\t      function interpret(val) {\n\t        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n\t      }\n\t      if (width != null) this.display.wrapper.style.width = interpret(width);\n\t      if (height != null) this.display.wrapper.style.height = interpret(height);\n\t      if (this.options.lineWrapping)\n\t        this.display.measureLineCache.length = this.display.measureLineCachePos = 0;\n\t      this.curOp.forceUpdate = true;\n\t      signal(this, \"refresh\", this);\n\t    }),\n\t\n\t    operation: function(f){return runInOp(this, f);},\n\t\n\t    refresh: operation(null, function() {\n\t      var oldHeight = this.display.cachedTextHeight;\n\t      clearCaches(this);\n\t      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);\n\t      regChange(this);\n\t      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n\t        estimateLineHeights(this);\n\t      signal(this, \"refresh\", this);\n\t    }),\n\t\n\t    swapDoc: operation(null, function(doc) {\n\t      var old = this.doc;\n\t      old.cm = null;\n\t      attachDoc(this, doc);\n\t      clearCaches(this);\n\t      resetInput(this, true);\n\t      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);\n\t      signalLater(this, \"swapDoc\", this, old);\n\t      return old;\n\t    }),\n\t\n\t    getInputField: function(){return this.display.input;},\n\t    getWrapperElement: function(){return this.display.wrapper;},\n\t    getScrollerElement: function(){return this.display.scroller;},\n\t    getGutterElement: function(){return this.display.gutters;}\n\t  };\n\t  eventMixin(CodeMirror);\n\t\n\t  // OPTION DEFAULTS\n\t\n\t  var optionHandlers = CodeMirror.optionHandlers = {};\n\t\n\t  // The default configuration options.\n\t  var defaults = CodeMirror.defaults = {};\n\t\n\t  function option(name, deflt, handle, notOnInit) {\n\t    CodeMirror.defaults[name] = deflt;\n\t    if (handle) optionHandlers[name] =\n\t      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n\t  }\n\t\n\t  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\t\n\t  // These two are, on init, called from the constructor because they\n\t  // have to be initialized before the editor can start at all.\n\t  option(\"value\", \"\", function(cm, val) {\n\t    cm.setValue(val);\n\t  }, true);\n\t  option(\"mode\", null, function(cm, val) {\n\t    cm.doc.modeOption = val;\n\t    loadMode(cm);\n\t  }, true);\n\t\n\t  option(\"indentUnit\", 2, loadMode, true);\n\t  option(\"indentWithTabs\", false);\n\t  option(\"smartIndent\", true);\n\t  option(\"tabSize\", 4, function(cm) {\n\t    resetModeState(cm);\n\t    clearCaches(cm);\n\t    regChange(cm);\n\t  }, true);\n\t  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b\\u2028\\u2029\\ufeff]/g, function(cm, val) {\n\t    cm.options.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n\t    cm.refresh();\n\t  }, true);\n\t  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n\t  option(\"electricChars\", true);\n\t  option(\"rtlMoveVisually\", !windows);\n\t  option(\"wholeLineUpdateBefore\", true);\n\t\n\t  option(\"theme\", \"default\", function(cm) {\n\t    themeChanged(cm);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"keyMap\", \"default\", keyMapChanged);\n\t  option(\"extraKeys\", null);\n\t\n\t  option(\"onKeyEvent\", null);\n\t  option(\"onDragEvent\", null);\n\t\n\t  option(\"lineWrapping\", false, wrappingChanged, true);\n\t  option(\"gutters\", [], function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"fixedGutter\", true, function(cm, val) {\n\t    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n\t    cm.refresh();\n\t  }, true);\n\t  option(\"coverGutterNextToScrollbar\", false, updateScrollbars, true);\n\t  option(\"lineNumbers\", false, function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"firstLineNumber\", 1, guttersChanged, true);\n\t  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n\t  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\t\n\t  option(\"resetSelectionOnContextMenu\", true);\n\t\n\t  option(\"readOnly\", false, function(cm, val) {\n\t    if (val == \"nocursor\") {\n\t      onBlur(cm);\n\t      cm.display.input.blur();\n\t      cm.display.disabled = true;\n\t    } else {\n\t      cm.display.disabled = false;\n\t      if (!val) resetInput(cm, true);\n\t    }\n\t  });\n\t  option(\"disableInput\", false, function(cm, val) {if (!val) resetInput(cm, true);}, true);\n\t  option(\"dragDrop\", true);\n\t\n\t  option(\"cursorBlinkRate\", 530);\n\t  option(\"cursorScrollMargin\", 0);\n\t  option(\"cursorHeight\", 1);\n\t  option(\"workTime\", 100);\n\t  option(\"workDelay\", 100);\n\t  option(\"flattenSpans\", true, resetModeState, true);\n\t  option(\"addModeClass\", false, resetModeState, true);\n\t  option(\"pollInterval\", 100);\n\t  option(\"undoDepth\", 40, function(cm, val){cm.doc.history.undoDepth = val;});\n\t  option(\"historyEventDelay\", 500);\n\t  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n\t  option(\"maxHighlightLength\", 10000, resetModeState, true);\n\t  option(\"crudeMeasuringFrom\", 10000);\n\t  option(\"moveInputWithCursor\", true, function(cm, val) {\n\t    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;\n\t  });\n\t\n\t  option(\"tabindex\", null, function(cm, val) {\n\t    cm.display.input.tabIndex = val || \"\";\n\t  });\n\t  option(\"autofocus\", null);\n\t\n\t  // MODE DEFINITION AND QUERYING\n\t\n\t  // Known modes, by name and by MIME\n\t  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\t\n\t  CodeMirror.defineMode = function(name, mode) {\n\t    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n\t    if (arguments.length > 2) {\n\t      mode.dependencies = [];\n\t      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);\n\t    }\n\t    modes[name] = mode;\n\t  };\n\t\n\t  CodeMirror.defineMIME = function(mime, spec) {\n\t    mimeModes[mime] = spec;\n\t  };\n\t\n\t  CodeMirror.resolveMode = function(spec) {\n\t    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n\t      spec = mimeModes[spec];\n\t    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n\t      var found = mimeModes[spec.name];\n\t      if (typeof found == \"string\") found = {name: found};\n\t      spec = createObj(found, spec);\n\t      spec.name = found.name;\n\t    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n\t      return CodeMirror.resolveMode(\"application/xml\");\n\t    }\n\t    if (typeof spec == \"string\") return {name: spec};\n\t    else return spec || {name: \"null\"};\n\t  };\n\t\n\t  CodeMirror.getMode = function(options, spec) {\n\t    var spec = CodeMirror.resolveMode(spec);\n\t    var mfactory = modes[spec.name];\n\t    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n\t    var modeObj = mfactory(options, spec);\n\t    if (modeExtensions.hasOwnProperty(spec.name)) {\n\t      var exts = modeExtensions[spec.name];\n\t      for (var prop in exts) {\n\t        if (!exts.hasOwnProperty(prop)) continue;\n\t        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n\t        modeObj[prop] = exts[prop];\n\t      }\n\t    }\n\t    modeObj.name = spec.name;\n\t    if (spec.helperType) modeObj.helperType = spec.helperType;\n\t    if (spec.modeProps) for (var prop in spec.modeProps)\n\t      modeObj[prop] = spec.modeProps[prop];\n\t\n\t    return modeObj;\n\t  };\n\t\n\t  CodeMirror.defineMode(\"null\", function() {\n\t    return {token: function(stream) {stream.skipToEnd();}};\n\t  });\n\t  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\t\n\t  var modeExtensions = CodeMirror.modeExtensions = {};\n\t  CodeMirror.extendMode = function(mode, properties) {\n\t    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n\t    copyObj(properties, exts);\n\t  };\n\t\n\t  // EXTENSIONS\n\t\n\t  CodeMirror.defineExtension = function(name, func) {\n\t    CodeMirror.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineDocExtension = function(name, func) {\n\t    Doc.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineOption = option;\n\t\n\t  var initHooks = [];\n\t  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\t\n\t  var helpers = CodeMirror.helpers = {};\n\t  CodeMirror.registerHelper = function(type, name, value) {\n\t    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n\t    helpers[type][name] = value;\n\t  };\n\t  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n\t    CodeMirror.registerHelper(type, name, value);\n\t    helpers[type]._global.push({pred: predicate, val: value});\n\t  };\n\t\n\t  // UTILITIES\n\t\n\t  CodeMirror.isWordChar = isWordChar;\n\t\n\t  // MODE STATE HANDLING\n\t\n\t  // Utility functions for working with state. Exported because modes\n\t  // sometimes need to do this.\n\t  function copyState(mode, state) {\n\t    if (state === true) return state;\n\t    if (mode.copyState) return mode.copyState(state);\n\t    var nstate = {};\n\t    for (var n in state) {\n\t      var val = state[n];\n\t      if (val instanceof Array) val = val.concat([]);\n\t      nstate[n] = val;\n\t    }\n\t    return nstate;\n\t  }\n\t  CodeMirror.copyState = copyState;\n\t\n\t  function startState(mode, a1, a2) {\n\t    return mode.startState ? mode.startState(a1, a2) : true;\n\t  }\n\t  CodeMirror.startState = startState;\n\t\n\t  CodeMirror.innerMode = function(mode, state) {\n\t    while (mode.innerMode) {\n\t      var info = mode.innerMode(state);\n\t      if (!info || info.mode == mode) break;\n\t      state = info.state;\n\t      mode = info.mode;\n\t    }\n\t    return info || {mode: mode, state: state};\n\t  };\n\t\n\t  // STANDARD COMMANDS\n\t\n\t  var commands = CodeMirror.commands = {\n\t    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));},\n\t    killLine: function(cm) {\n\t      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);\n\t      if (!sel && cm.getLine(from.line).length == from.ch)\n\t        cm.replaceRange(\"\", from, Pos(from.line + 1, 0), \"+delete\");\n\t      else cm.replaceRange(\"\", from, sel ? to : Pos(from.line), \"+delete\");\n\t    },\n\t    deleteLine: function(cm) {\n\t      var l = cm.getCursor().line;\n\t      cm.replaceRange(\"\", Pos(l, 0), Pos(l + 1, 0), \"+delete\");\n\t    },\n\t    delLineLeft: function(cm) {\n\t      var cur = cm.getCursor();\n\t      cm.replaceRange(\"\", Pos(cur.line, 0), cur, \"+delete\");\n\t    },\n\t    undo: function(cm) {cm.undo();},\n\t    redo: function(cm) {cm.redo();},\n\t    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n\t    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n\t    goLineStart: function(cm) {\n\t      cm.extendSelection(lineStart(cm, cm.getCursor().line));\n\t    },\n\t    goLineStartSmart: function(cm) {\n\t      var cur = cm.getCursor(), start = lineStart(cm, cur.line);\n\t      var line = cm.getLineHandle(start.line);\n\t      var order = getOrder(line);\n\t      if (!order || order[0].level == 0) {\n\t        var firstNonWS = Math.max(0, line.text.search(/\\S/));\n\t        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;\n\t        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));\n\t      } else cm.extendSelection(start);\n\t    },\n\t    goLineEnd: function(cm) {\n\t      cm.extendSelection(lineEnd(cm, cm.getCursor().line));\n\t    },\n\t    goLineRight: function(cm) {\n\t      var top = cm.charCoords(cm.getCursor(), \"div\").top + 5;\n\t      cm.extendSelection(cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\"));\n\t    },\n\t    goLineLeft: function(cm) {\n\t      var top = cm.charCoords(cm.getCursor(), \"div\").top + 5;\n\t      cm.extendSelection(cm.coordsChar({left: 0, top: top}, \"div\"));\n\t    },\n\t    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n\t    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n\t    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n\t    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n\t    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n\t    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n\t    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n\t    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n\t    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n\t    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n\t    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n\t    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n\t    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n\t    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n\t    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n\t    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n\t    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n\t    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n\t    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n\t    indentMore: function(cm) {cm.indentSelection(\"add\");},\n\t    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n\t    insertTab: function(cm) {\n\t      cm.replaceSelection(\"\\t\", \"end\", \"+input\");\n\t    },\n\t    defaultTab: function(cm) {\n\t      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n\t      else cm.replaceSelection(\"\\t\", \"end\", \"+input\");\n\t    },\n\t    transposeChars: function(cm) {\n\t      var cur = cm.getCursor(), line = cm.getLine(cur.line);\n\t      if (cur.ch > 0 && cur.ch < line.length - 1)\n\t        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),\n\t                        Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));\n\t    },\n\t    newlineAndIndent: function(cm) {\n\t      operation(cm, function() {\n\t        cm.replaceSelection(\"\\n\", \"end\", \"+input\");\n\t        cm.indentLine(cm.getCursor().line, null, true);\n\t      })();\n\t    },\n\t    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n\t  };\n\t\n\t  // STANDARD KEYMAPS\n\t\n\t  var keyMap = CodeMirror.keyMap = {};\n\t  keyMap.basic = {\n\t    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n\t    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n\t    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n\t    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n\t    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\"\n\t  };\n\t  // Note that the save and find-related commands aren't defined by\n\t  // default. Unknown commands are simply ignored.\n\t  keyMap.pcDefault = {\n\t    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n\t    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Down\": \"goDocEnd\",\n\t    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n\t    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n\t    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n\t    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n\t    fallthrough: \"basic\"\n\t  };\n\t  keyMap.macDefault = {\n\t    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n\t    \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n\t    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineStart\", \"Cmd-Right\": \"goLineEnd\", \"Alt-Backspace\": \"delGroupBefore\",\n\t    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n\t    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n\t    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delLineLeft\",\n\t    fallthrough: [\"basic\", \"emacsy\"]\n\t  };\n\t  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\t  keyMap.emacsy = {\n\t    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n\t    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n\t    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n\t    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n\t  };\n\t\n\t  // KEYMAP DISPATCH\n\t\n\t  function getKeyMap(val) {\n\t    if (typeof val == \"string\") return keyMap[val];\n\t    else return val;\n\t  }\n\t\n\t  function lookupKey(name, maps, handle) {\n\t    function lookup(map) {\n\t      map = getKeyMap(map);\n\t      var found = map[name];\n\t      if (found === false) return \"stop\";\n\t      if (found != null && handle(found)) return true;\n\t      if (map.nofallthrough) return \"stop\";\n\t\n\t      var fallthrough = map.fallthrough;\n\t      if (fallthrough == null) return false;\n\t      if (Object.prototype.toString.call(fallthrough) != \"[object Array]\")\n\t        return lookup(fallthrough);\n\t      for (var i = 0, e = fallthrough.length; i < e; ++i) {\n\t        var done = lookup(fallthrough[i]);\n\t        if (done) return done;\n\t      }\n\t      return false;\n\t    }\n\t\n\t    for (var i = 0; i < maps.length; ++i) {\n\t      var done = lookup(maps[i]);\n\t      if (done) return done != \"stop\";\n\t    }\n\t  }\n\t  function isModifierKey(event) {\n\t    var name = keyNames[event.keyCode];\n\t    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n\t  }\n\t  function keyName(event, noShift) {\n\t    if (opera && event.keyCode == 34 && event[\"char\"]) return false;\n\t    var name = keyNames[event.keyCode];\n\t    if (name == null || event.altGraphKey) return false;\n\t    if (event.altKey) name = \"Alt-\" + name;\n\t    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = \"Ctrl-\" + name;\n\t    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = \"Cmd-\" + name;\n\t    if (!noShift && event.shiftKey) name = \"Shift-\" + name;\n\t    return name;\n\t  }\n\t  CodeMirror.lookupKey = lookupKey;\n\t  CodeMirror.isModifierKey = isModifierKey;\n\t  CodeMirror.keyName = keyName;\n\t\n\t  // FROMTEXTAREA\n\t\n\t  CodeMirror.fromTextArea = function(textarea, options) {\n\t    if (!options) options = {};\n\t    options.value = textarea.value;\n\t    if (!options.tabindex && textarea.tabindex)\n\t      options.tabindex = textarea.tabindex;\n\t    if (!options.placeholder && textarea.placeholder)\n\t      options.placeholder = textarea.placeholder;\n\t    // Set autofocus to true if this textarea is focused, or if it has\n\t    // autofocus and no other element is focused.\n\t    if (options.autofocus == null) {\n\t      var hasFocus = document.body;\n\t      // doc.activeElement occasionally throws on IE\n\t      try { hasFocus = document.activeElement; } catch(e) {}\n\t      options.autofocus = hasFocus == textarea ||\n\t        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n\t    }\n\t\n\t    function save() {textarea.value = cm.getValue();}\n\t    if (textarea.form) {\n\t      on(textarea.form, \"submit\", save);\n\t      // Deplorable hack to make the submit method do the right thing.\n\t      if (!options.leaveSubmitMethodAlone) {\n\t        var form = textarea.form, realSubmit = form.submit;\n\t        try {\n\t          var wrappedSubmit = form.submit = function() {\n\t            save();\n\t            form.submit = realSubmit;\n\t            form.submit();\n\t            form.submit = wrappedSubmit;\n\t          };\n\t        } catch(e) {}\n\t      }\n\t    }\n\t\n\t    textarea.style.display = \"none\";\n\t    var cm = CodeMirror(function(node) {\n\t      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n\t    }, options);\n\t    cm.save = save;\n\t    cm.getTextArea = function() { return textarea; };\n\t    cm.toTextArea = function() {\n\t      save();\n\t      textarea.parentNode.removeChild(cm.getWrapperElement());\n\t      textarea.style.display = \"\";\n\t      if (textarea.form) {\n\t        off(textarea.form, \"submit\", save);\n\t        if (typeof textarea.form.submit == \"function\")\n\t          textarea.form.submit = realSubmit;\n\t      }\n\t    };\n\t    return cm;\n\t  };\n\t\n\t  // STRING STREAM\n\t\n\t  // Fed to the mode parsers, provides helper functions to make\n\t  // parsers more succinct.\n\t\n\t  // The character stream used by a mode's parser.\n\t  function StringStream(string, tabSize) {\n\t    this.pos = this.start = 0;\n\t    this.string = string;\n\t    this.tabSize = tabSize || 8;\n\t    this.lastColumnPos = this.lastColumnValue = 0;\n\t    this.lineStart = 0;\n\t  }\n\t\n\t  StringStream.prototype = {\n\t    eol: function() {return this.pos >= this.string.length;},\n\t    sol: function() {return this.pos == this.lineStart;},\n\t    peek: function() {return this.string.charAt(this.pos) || undefined;},\n\t    next: function() {\n\t      if (this.pos < this.string.length)\n\t        return this.string.charAt(this.pos++);\n\t    },\n\t    eat: function(match) {\n\t      var ch = this.string.charAt(this.pos);\n\t      if (typeof match == \"string\") var ok = ch == match;\n\t      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n\t      if (ok) {++this.pos; return ch;}\n\t    },\n\t    eatWhile: function(match) {\n\t      var start = this.pos;\n\t      while (this.eat(match)){}\n\t      return this.pos > start;\n\t    },\n\t    eatSpace: function() {\n\t      var start = this.pos;\n\t      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n\t      return this.pos > start;\n\t    },\n\t    skipToEnd: function() {this.pos = this.string.length;},\n\t    skipTo: function(ch) {\n\t      var found = this.string.indexOf(ch, this.pos);\n\t      if (found > -1) {this.pos = found; return true;}\n\t    },\n\t    backUp: function(n) {this.pos -= n;},\n\t    column: function() {\n\t      if (this.lastColumnPos < this.start) {\n\t        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n\t        this.lastColumnPos = this.start;\n\t      }\n\t      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    indentation: function() {\n\t      return countColumn(this.string, null, this.tabSize) -\n\t        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    match: function(pattern, consume, caseInsensitive) {\n\t      if (typeof pattern == \"string\") {\n\t        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n\t        var substr = this.string.substr(this.pos, pattern.length);\n\t        if (cased(substr) == cased(pattern)) {\n\t          if (consume !== false) this.pos += pattern.length;\n\t          return true;\n\t        }\n\t      } else {\n\t        var match = this.string.slice(this.pos).match(pattern);\n\t        if (match && match.index > 0) return null;\n\t        if (match && consume !== false) this.pos += match[0].length;\n\t        return match;\n\t      }\n\t    },\n\t    current: function(){return this.string.slice(this.start, this.pos);},\n\t    hideFirstChars: function(n, inner) {\n\t      this.lineStart += n;\n\t      try { return inner(); }\n\t      finally { this.lineStart -= n; }\n\t    }\n\t  };\n\t  CodeMirror.StringStream = StringStream;\n\t\n\t  // TEXTMARKERS\n\t\n\t  function TextMarker(doc, type) {\n\t    this.lines = [];\n\t    this.type = type;\n\t    this.doc = doc;\n\t  }\n\t  CodeMirror.TextMarker = TextMarker;\n\t  eventMixin(TextMarker);\n\t\n\t  TextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n\t    if (withOp) startOperation(cm);\n\t    if (hasHandler(this, \"clear\")) {\n\t      var found = this.find();\n\t      if (found) signalLater(this, \"clear\", found.from, found.to);\n\t    }\n\t    var min = null, max = null;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (span.to != null) max = lineNo(line);\n\t      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n\t      if (span.from != null)\n\t        min = lineNo(line);\n\t      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)\n\t        updateLineHeight(line, textHeight(cm.display));\n\t    }\n\t    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n\t      var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);\n\t      if (len > cm.display.maxLineLength) {\n\t        cm.display.maxLine = visual;\n\t        cm.display.maxLineLength = len;\n\t        cm.display.maxLineChanged = true;\n\t      }\n\t    }\n\t\n\t    if (min != null && cm) regChange(cm, min, max + 1);\n\t    this.lines.length = 0;\n\t    this.explicitlyCleared = true;\n\t    if (this.atomic && this.doc.cantEdit) {\n\t      this.doc.cantEdit = false;\n\t      if (cm) reCheckSelection(cm);\n\t    }\n\t    if (withOp) endOperation(cm);\n\t  };\n\t\n\t  TextMarker.prototype.find = function(bothSides) {\n\t    var from, to;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (span.from != null || span.to != null) {\n\t        var found = lineNo(line);\n\t        if (span.from != null) from = Pos(found, span.from);\n\t        if (span.to != null) to = Pos(found, span.to);\n\t      }\n\t    }\n\t    if (this.type == \"bookmark\" && !bothSides) return from;\n\t    return from && {from: from, to: to};\n\t  };\n\t\n\t  TextMarker.prototype.changed = function() {\n\t    var pos = this.find(), cm = this.doc.cm;\n\t    if (!pos || !cm) return;\n\t    if (this.type != \"bookmark\") pos = pos.from;\n\t    var line = getLine(this.doc, pos.line);\n\t    clearCachedMeasurement(cm, line);\n\t    if (pos.line >= cm.display.showingFrom && pos.line < cm.display.showingTo) {\n\t      for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) if (node.lineObj == line) {\n\t        if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);\n\t        break;\n\t      }\n\t      runInOp(cm, function() {\n\t        cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = true;\n\t      });\n\t    }\n\t  };\n\t\n\t  TextMarker.prototype.attachLine = function(line) {\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n\t        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n\t    }\n\t    this.lines.push(line);\n\t  };\n\t  TextMarker.prototype.detachLine = function(line) {\n\t    this.lines.splice(indexOf(this.lines, line), 1);\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n\t    }\n\t  };\n\t\n\t  var nextMarkerId = 0;\n\t\n\t  function markText(doc, from, to, options, type) {\n\t    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n\t    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\t\n\t    var marker = new TextMarker(doc, type);\n\t    if (options) copyObj(options, marker);\n\t    if (posLess(to, from) || posEq(from, to) && marker.clearWhenEmpty !== false)\n\t      return marker;\n\t    if (marker.replacedWith) {\n\t      marker.collapsed = true;\n\t      marker.replacedWith = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n\t      if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;\n\t    }\n\t    if (marker.collapsed) {\n\t      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n\t          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n\t        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n\t      sawCollapsedSpans = true;\n\t    }\n\t\n\t    if (marker.addToHistory)\n\t      addToHistory(doc, {from: from, to: to, origin: \"markText\"},\n\t                   {head: doc.sel.head, anchor: doc.sel.anchor}, NaN);\n\t\n\t    var curLine = from.line, cm = doc.cm, updateMaxLine;\n\t    doc.iter(curLine, to.line + 1, function(line) {\n\t      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)\n\t        updateMaxLine = true;\n\t      var span = {from: null, to: null, marker: marker};\n\t      if (curLine == from.line) span.from = from.ch;\n\t      if (curLine == to.line) span.to = to.ch;\n\t      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n\t      addMarkedSpan(line, span);\n\t      ++curLine;\n\t    });\n\t    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n\t      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n\t    });\n\t\n\t    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\t\n\t    if (marker.readOnly) {\n\t      sawReadOnlySpans = true;\n\t      if (doc.history.done.length || doc.history.undone.length)\n\t        doc.clearHistory();\n\t    }\n\t    if (marker.collapsed) {\n\t      marker.id = ++nextMarkerId;\n\t      marker.atomic = true;\n\t    }\n\t    if (cm) {\n\t      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n\t      if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed)\n\t        regChange(cm, from.line, to.line + 1);\n\t      if (marker.atomic) reCheckSelection(cm);\n\t    }\n\t    return marker;\n\t  }\n\t\n\t  // SHARED TEXTMARKERS\n\t\n\t  function SharedTextMarker(markers, primary) {\n\t    this.markers = markers;\n\t    this.primary = primary;\n\t    for (var i = 0, me = this; i < markers.length; ++i) {\n\t      markers[i].parent = this;\n\t      on(markers[i], \"clear\", function(){me.clear();});\n\t    }\n\t  }\n\t  CodeMirror.SharedTextMarker = SharedTextMarker;\n\t  eventMixin(SharedTextMarker);\n\t\n\t  SharedTextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    this.explicitlyCleared = true;\n\t    for (var i = 0; i < this.markers.length; ++i)\n\t      this.markers[i].clear();\n\t    signalLater(this, \"clear\");\n\t  };\n\t  SharedTextMarker.prototype.find = function() {\n\t    return this.primary.find();\n\t  };\n\t\n\t  function markTextShared(doc, from, to, options, type) {\n\t    options = copyObj(options);\n\t    options.shared = false;\n\t    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n\t    var widget = options.replacedWith;\n\t    linkedDocs(doc, function(doc) {\n\t      if (widget) options.replacedWith = widget.cloneNode(true);\n\t      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n\t      for (var i = 0; i < doc.linked.length; ++i)\n\t        if (doc.linked[i].isParent) return;\n\t      primary = lst(markers);\n\t    });\n\t    return new SharedTextMarker(markers, primary);\n\t  }\n\t\n\t  // TEXTMARKER SPANS\n\t\n\t  function getMarkedSpanFor(spans, marker) {\n\t    if (spans) for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.marker == marker) return span;\n\t    }\n\t  }\n\t  function removeMarkedSpan(spans, span) {\n\t    for (var r, i = 0; i < spans.length; ++i)\n\t      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n\t    return r;\n\t  }\n\t  function addMarkedSpan(line, span) {\n\t    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n\t    span.marker.attachLine(line);\n\t  }\n\t\n\t  function markedSpansBefore(old, startCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n\t      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n\t        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n\t        (nw || (nw = [])).push({from: span.from,\n\t                                to: endsAfter ? null : span.to,\n\t                                marker: marker});\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t\n\t  function markedSpansAfter(old, endCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n\t      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n\t        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n\t        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,\n\t                                to: span.to == null ? null : span.to - endCh,\n\t                                marker: marker});\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t\n\t  function stretchSpansOverChange(doc, change) {\n\t    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n\t    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n\t    if (!oldFirst && !oldLast) return null;\n\t\n\t    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);\n\t    // Get the spans that 'stick out' on both sides\n\t    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n\t    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\t\n\t    // Next, merge those two ends\n\t    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n\t    if (first) {\n\t      // Fix up .to properties of first\n\t      for (var i = 0; i < first.length; ++i) {\n\t        var span = first[i];\n\t        if (span.to == null) {\n\t          var found = getMarkedSpanFor(last, span.marker);\n\t          if (!found) span.to = startCh;\n\t          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n\t        }\n\t      }\n\t    }\n\t    if (last) {\n\t      // Fix up .from in last (or move them into first in case of sameLine)\n\t      for (var i = 0; i < last.length; ++i) {\n\t        var span = last[i];\n\t        if (span.to != null) span.to += offset;\n\t        if (span.from == null) {\n\t          var found = getMarkedSpanFor(first, span.marker);\n\t          if (!found) {\n\t            span.from = offset;\n\t            if (sameLine) (first || (first = [])).push(span);\n\t          }\n\t        } else {\n\t          span.from += offset;\n\t          if (sameLine) (first || (first = [])).push(span);\n\t        }\n\t      }\n\t    }\n\t    // Make sure we didn't create any zero-length spans\n\t    if (first) first = clearEmptySpans(first);\n\t    if (last && last != first) last = clearEmptySpans(last);\n\t\n\t    var newMarkers = [first];\n\t    if (!sameLine) {\n\t      // Fill gap with whole-line-spans\n\t      var gap = change.text.length - 2, gapMarkers;\n\t      if (gap > 0 && first)\n\t        for (var i = 0; i < first.length; ++i)\n\t          if (first[i].to == null)\n\t            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});\n\t      for (var i = 0; i < gap; ++i)\n\t        newMarkers.push(gapMarkers);\n\t      newMarkers.push(last);\n\t    }\n\t    return newMarkers;\n\t  }\n\t\n\t  function clearEmptySpans(spans) {\n\t    for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n\t        spans.splice(i--, 1);\n\t    }\n\t    if (!spans.length) return null;\n\t    return spans;\n\t  }\n\t\n\t  function mergeOldSpans(doc, change) {\n\t    var old = getOldSpans(doc, change);\n\t    var stretched = stretchSpansOverChange(doc, change);\n\t    if (!old) return stretched;\n\t    if (!stretched) return old;\n\t\n\t    for (var i = 0; i < old.length; ++i) {\n\t      var oldCur = old[i], stretchCur = stretched[i];\n\t      if (oldCur && stretchCur) {\n\t        spans: for (var j = 0; j < stretchCur.length; ++j) {\n\t          var span = stretchCur[j];\n\t          for (var k = 0; k < oldCur.length; ++k)\n\t            if (oldCur[k].marker == span.marker) continue spans;\n\t          oldCur.push(span);\n\t        }\n\t      } else if (stretchCur) {\n\t        old[i] = stretchCur;\n\t      }\n\t    }\n\t    return old;\n\t  }\n\t\n\t  function removeReadOnlyRanges(doc, from, to) {\n\t    var markers = null;\n\t    doc.iter(from.line, to.line + 1, function(line) {\n\t      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n\t        var mark = line.markedSpans[i].marker;\n\t        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n\t          (markers || (markers = [])).push(mark);\n\t      }\n\t    });\n\t    if (!markers) return null;\n\t    var parts = [{from: from, to: to}];\n\t    for (var i = 0; i < markers.length; ++i) {\n\t      var mk = markers[i], m = mk.find();\n\t      for (var j = 0; j < parts.length; ++j) {\n\t        var p = parts[j];\n\t        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;\n\t        var newParts = [j, 1];\n\t        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))\n\t          newParts.push({from: p.from, to: m.from});\n\t        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))\n\t          newParts.push({from: m.to, to: p.to});\n\t        parts.splice.apply(parts, newParts);\n\t        j += newParts.length - 1;\n\t      }\n\t    }\n\t    return parts;\n\t  }\n\t\n\t  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n\t  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\t\n\t  function compareCollapsedMarkers(a, b) {\n\t    var lenDiff = a.lines.length - b.lines.length;\n\t    if (lenDiff != 0) return lenDiff;\n\t    var aPos = a.find(), bPos = b.find();\n\t    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n\t    if (fromCmp) return -fromCmp;\n\t    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n\t    if (toCmp) return toCmp;\n\t    return b.id - a.id;\n\t  }\n\t\n\t  function collapsedSpanAtSide(line, start) {\n\t    var sps = sawCollapsedSpans && line.markedSpans, found;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n\t          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n\t        found = sp.marker;\n\t    }\n\t    return found;\n\t  }\n\t  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n\t  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\t\n\t  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n\t    var line = getLine(doc, lineNo);\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var i = 0; i < sps.length; ++i) {\n\t      var sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      var found = sp.marker.find(true);\n\t      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n\t      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n\t      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n\t      if (fromCmp <= 0 && (cmp(found.to, from) || extraRight(sp.marker) - extraLeft(marker)) > 0 ||\n\t          fromCmp >= 0 && (cmp(found.from, to) || extraLeft(sp.marker) - extraRight(marker)) < 0)\n\t        return true;\n\t    }\n\t  }\n\t\n\t  function visualLine(doc, line) {\n\t    var merged;\n\t    while (merged = collapsedSpanAtStart(line))\n\t      line = getLine(doc, merged.find().from.line);\n\t    return line;\n\t  }\n\t\n\t  function lineIsHidden(doc, line) {\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      if (sp.from == null) return true;\n\t      if (sp.marker.replacedWith) continue;\n\t      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n\t        return true;\n\t    }\n\t  }\n\t  function lineIsHiddenInner(doc, line, span) {\n\t    if (span.to == null) {\n\t      var end = span.marker.find().to, endLine = getLine(doc, end.line);\n\t      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));\n\t    }\n\t    if (span.marker.inclusiveRight && span.to == line.text.length)\n\t      return true;\n\t    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n\t      sp = line.markedSpans[i];\n\t      if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to &&\n\t          (sp.to == null || sp.to != span.from) &&\n\t          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n\t          lineIsHiddenInner(doc, line, sp)) return true;\n\t    }\n\t  }\n\t\n\t  function detachMarkedSpans(line) {\n\t    var spans = line.markedSpans;\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.detachLine(line);\n\t    line.markedSpans = null;\n\t  }\n\t\n\t  function attachMarkedSpans(line, spans) {\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.attachLine(line);\n\t    line.markedSpans = spans;\n\t  }\n\t\n\t  // LINE WIDGETS\n\t\n\t  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {\n\t    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n\t      this[opt] = options[opt];\n\t    this.cm = cm;\n\t    this.node = node;\n\t  };\n\t  eventMixin(LineWidget);\n\t  function widgetOperation(f) {\n\t    return function() {\n\t      var withOp = !this.cm.curOp;\n\t      if (withOp) startOperation(this.cm);\n\t      try {var result = f.apply(this, arguments);}\n\t      finally {if (withOp) endOperation(this.cm);}\n\t      return result;\n\t    };\n\t  }\n\t  LineWidget.prototype.clear = widgetOperation(function() {\n\t    var ws = this.line.widgets, no = lineNo(this.line);\n\t    if (no == null || !ws) return;\n\t    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n\t    if (!ws.length) this.line.widgets = null;\n\t    var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;\n\t    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));\n\t    if (aboveVisible) addToScrollPos(this.cm, 0, -this.height);\n\t    regChange(this.cm, no, no + 1);\n\t  });\n\t  LineWidget.prototype.changed = widgetOperation(function() {\n\t    var oldH = this.height;\n\t    this.height = null;\n\t    var diff = widgetHeight(this) - oldH;\n\t    if (!diff) return;\n\t    updateLineHeight(this.line, this.line.height + diff);\n\t    var no = lineNo(this.line);\n\t    regChange(this.cm, no, no + 1);\n\t  });\n\t\n\t  function widgetHeight(widget) {\n\t    if (widget.height != null) return widget.height;\n\t    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)\n\t      removeChildrenAndAdd(widget.cm.display.measure, elt(\"div\", [widget.node], null, \"position: relative\"));\n\t    return widget.height = widget.node.offsetHeight;\n\t  }\n\t\n\t  function addLineWidget(cm, handle, node, options) {\n\t    var widget = new LineWidget(cm, node, options);\n\t    if (widget.noHScroll) cm.display.alignWidgets = true;\n\t    changeLine(cm, handle, function(line) {\n\t      var widgets = line.widgets || (line.widgets = []);\n\t      if (widget.insertAt == null) widgets.push(widget);\n\t      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n\t      widget.line = line;\n\t      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {\n\t        var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;\n\t        updateLineHeight(line, line.height + widgetHeight(widget));\n\t        if (aboveVisible) addToScrollPos(cm, 0, widget.height);\n\t        cm.curOp.forceUpdate = true;\n\t      }\n\t      return true;\n\t    });\n\t    return widget;\n\t  }\n\t\n\t  // LINE DATA STRUCTURE\n\t\n\t  // Line objects. These hold state related to a line, including\n\t  // highlighting info (the styles array).\n\t  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n\t    this.text = text;\n\t    attachMarkedSpans(this, markedSpans);\n\t    this.height = estimateHeight ? estimateHeight(this) : 1;\n\t  };\n\t  eventMixin(Line);\n\t  Line.prototype.lineNo = function() { return lineNo(this); };\n\t\n\t  function updateLine(line, text, markedSpans, estimateHeight) {\n\t    line.text = text;\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    if (line.styles) line.styles = null;\n\t    if (line.order != null) line.order = null;\n\t    detachMarkedSpans(line);\n\t    attachMarkedSpans(line, markedSpans);\n\t    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n\t    if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t  }\n\t\n\t  function cleanUpLine(line) {\n\t    line.parent = null;\n\t    detachMarkedSpans(line);\n\t  }\n\t\n\t  // Run the given mode's parser over a line, update the styles\n\t  // array, which contains alternating fragments of text and CSS\n\t  // classes.\n\t  function runMode(cm, text, mode, state, f, forceToEnd) {\n\t    var flattenSpans = mode.flattenSpans;\n\t    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n\t    var curStart = 0, curStyle = null;\n\t    var stream = new StringStream(text, cm.options.tabSize), style;\n\t    if (text == \"\" && mode.blankLine) mode.blankLine(state);\n\t    while (!stream.eol()) {\n\t      if (stream.pos > cm.options.maxHighlightLength) {\n\t        flattenSpans = false;\n\t        if (forceToEnd) processLine(cm, text, state, stream.pos);\n\t        stream.pos = text.length;\n\t        style = null;\n\t      } else {\n\t        style = mode.token(stream, state);\n\t      }\n\t      if (cm.options.addModeClass) {\n\t        var mName = CodeMirror.innerMode(mode, state).mode.name;\n\t        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n\t      }\n\t      if (!flattenSpans || curStyle != style) {\n\t        if (curStart < stream.start) f(stream.start, curStyle);\n\t        curStart = stream.start; curStyle = style;\n\t      }\n\t      stream.start = stream.pos;\n\t    }\n\t    while (curStart < stream.pos) {\n\t      // Webkit seems to refuse to render text nodes longer than 57444 characters\n\t      var pos = Math.min(stream.pos, curStart + 50000);\n\t      f(pos, curStyle);\n\t      curStart = pos;\n\t    }\n\t  }\n\t\n\t  function highlightLine(cm, line, state, forceToEnd) {\n\t    // A styles array always starts with a number identifying the\n\t    // mode/overlays that it is based on (for easy invalidation).\n\t    var st = [cm.state.modeGen];\n\t    // Compute the base array of styles\n\t    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n\t      st.push(end, style);\n\t    }, forceToEnd);\n\t\n\t    // Run overlays, adjust style array.\n\t    for (var o = 0; o < cm.state.overlays.length; ++o) {\n\t      var overlay = cm.state.overlays[o], i = 1, at = 0;\n\t      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n\t        var start = i;\n\t        // Ensure there's a token end at the current position, and that i points at it\n\t        while (at < end) {\n\t          var i_end = st[i];\n\t          if (i_end > end)\n\t            st.splice(i, 1, end, st[i+1], i_end);\n\t          i += 2;\n\t          at = Math.min(end, i_end);\n\t        }\n\t        if (!style) return;\n\t        if (overlay.opaque) {\n\t          st.splice(start, i - start, end, style);\n\t          i = start + 2;\n\t        } else {\n\t          for (; start < i; start += 2) {\n\t            var cur = st[start+1];\n\t            st[start+1] = cur ? cur + \" \" + style : style;\n\t          }\n\t        }\n\t      });\n\t    }\n\t\n\t    return st;\n\t  }\n\t\n\t  function getLineStyles(cm, line) {\n\t    if (!line.styles || line.styles[0] != cm.state.modeGen)\n\t      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\n\t    return line.styles;\n\t  }\n\t\n\t  // Lightweight form of highlight -- proceed over this line and\n\t  // update state, but don't save a style array.\n\t  function processLine(cm, text, state, startAt) {\n\t    var mode = cm.doc.mode;\n\t    var stream = new StringStream(text, cm.options.tabSize);\n\t    stream.start = stream.pos = startAt || 0;\n\t    if (text == \"\" && mode.blankLine) mode.blankLine(state);\n\t    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {\n\t      mode.token(stream, state);\n\t      stream.start = stream.pos;\n\t    }\n\t  }\n\t\n\t  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n\t  function interpretTokenStyle(style, builder) {\n\t    if (!style) return null;\n\t    for (;;) {\n\t      var lineClass = style.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n\t      if (!lineClass) break;\n\t      style = style.slice(0, lineClass.index) + style.slice(lineClass.index + lineClass[0].length);\n\t      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n\t      if (builder[prop] == null)\n\t        builder[prop] = lineClass[2];\n\t      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(builder[prop]))\n\t        builder[prop] += \" \" + lineClass[2];\n\t    }\n\t    if (/^\\s*$/.test(style)) return null;\n\t    var cache = builder.cm.options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n\t    return cache[style] ||\n\t      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n\t  }\n\t\n\t  function buildLineContent(cm, realLine, measure, copyWidgets) {\n\t    var merged, line = realLine, empty = true;\n\t    while (merged = collapsedSpanAtStart(line))\n\t      line = getLine(cm.doc, merged.find().from.line);\n\t\n\t    var builder = {pre: elt(\"pre\"), col: 0, pos: 0,\n\t                   measure: null, measuredSomething: false, cm: cm,\n\t                   copyWidgets: copyWidgets};\n\t\n\t    do {\n\t      if (line.text) empty = false;\n\t      builder.measure = line == realLine && measure;\n\t      builder.pos = 0;\n\t      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;\n\t      if ((ie || webkit) && cm.getOption(\"lineWrapping\"))\n\t        builder.addToken = buildTokenSplitSpaces(builder.addToken);\n\t      var next = insertLineContent(line, builder, getLineStyles(cm, line));\n\t      if (measure && line == realLine && !builder.measuredSomething) {\n\t        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));\n\t        builder.measuredSomething = true;\n\t      }\n\t      if (next) line = getLine(cm.doc, next.to.line);\n\t    } while (next);\n\t\n\t    if (measure && !builder.measuredSomething && !measure[0])\n\t      measure[0] = builder.pre.appendChild(empty ? elt(\"span\", \"\\u00a0\") : zeroWidthElement(cm.display.measure));\n\t    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))\n\t      builder.pre.appendChild(document.createTextNode(\"\\u00a0\"));\n\t\n\t    var order;\n\t    // Work around problem with the reported dimensions of single-char\n\t    // direction spans on IE (issue #1129). See also the comment in\n\t    // cursorCoords.\n\t    if (measure && ie && (order = getOrder(line))) {\n\t      var l = order.length - 1;\n\t      if (order[l].from == order[l].to) --l;\n\t      var last = order[l], prev = order[l - 1];\n\t      if (last.from + 1 == last.to && prev && last.level < prev.level) {\n\t        var span = measure[builder.pos - 1];\n\t        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure),\n\t                                               span.nextSibling);\n\t      }\n\t    }\n\t\n\t    var textClass = builder.textClass ? builder.textClass + \" \" + (realLine.textClass || \"\") : realLine.textClass;\n\t    if (textClass) builder.pre.className = textClass;\n\t\n\t    signal(cm, \"renderLine\", cm, realLine, builder.pre);\n\t    return builder;\n\t  }\n\t\n\t  function defaultSpecialCharPlaceholder(ch) {\n\t    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n\t    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n\t    return token;\n\t  }\n\t\n\t  function buildToken(builder, text, style, startStyle, endStyle, title) {\n\t    if (!text) return;\n\t    var special = builder.cm.options.specialChars;\n\t    if (!special.test(text)) {\n\t      builder.col += text.length;\n\t      var content = document.createTextNode(text);\n\t    } else {\n\t      var content = document.createDocumentFragment(), pos = 0;\n\t      while (true) {\n\t        special.lastIndex = pos;\n\t        var m = special.exec(text);\n\t        var skipped = m ? m.index - pos : text.length - pos;\n\t        if (skipped) {\n\t          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));\n\t          builder.col += skipped;\n\t        }\n\t        if (!m) break;\n\t        pos += skipped + 1;\n\t        if (m[0] == \"\\t\") {\n\t          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n\t          content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n\t          builder.col += tabWidth;\n\t        } else {\n\t          var token = builder.cm.options.specialCharPlaceholder(m[0]);\n\t          content.appendChild(token);\n\t          builder.col += 1;\n\t        }\n\t      }\n\t    }\n\t    if (style || startStyle || endStyle || builder.measure) {\n\t      var fullStyle = style || \"\";\n\t      if (startStyle) fullStyle += startStyle;\n\t      if (endStyle) fullStyle += endStyle;\n\t      var token = elt(\"span\", [content], fullStyle);\n\t      if (title) token.title = title;\n\t      return builder.pre.appendChild(token);\n\t    }\n\t    builder.pre.appendChild(content);\n\t  }\n\t\n\t  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {\n\t    var wrapping = builder.cm.options.lineWrapping;\n\t    for (var i = 0; i < text.length; ++i) {\n\t      var start = i == 0, to = i + 1;\n\t      while (to < text.length && isExtendingChar(text.charAt(to))) ++to;\n\t      var ch = text.slice(i, to);\n\t      i = to - 1;\n\t      if (i && wrapping && spanAffectsWrapping(text, i))\n\t        builder.pre.appendChild(elt(\"wbr\"));\n\t      var old = builder.measure[builder.pos];\n\t      var span = builder.measure[builder.pos] =\n\t        buildToken(builder, ch, style,\n\t                   start && startStyle, i == text.length - 1 && endStyle);\n\t      if (old) span.leftSide = old.leftSide || old;\n\t      // In IE single-space nodes wrap differently than spaces\n\t      // embedded in larger text nodes, except when set to\n\t      // white-space: normal (issue #1268).\n\t      if (old_ie && wrapping && ch == \" \" && i && !/\\s/.test(text.charAt(i - 1)) &&\n\t          i < text.length - 1 && !/\\s/.test(text.charAt(i + 1)))\n\t        span.style.whiteSpace = \"normal\";\n\t      builder.pos += ch.length;\n\t    }\n\t    if (text.length) builder.measuredSomething = true;\n\t  }\n\t\n\t  function buildTokenSplitSpaces(inner) {\n\t    function split(old) {\n\t      var out = \" \";\n\t      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n\t      out += \" \";\n\t      return out;\n\t    }\n\t    return function(builder, text, style, startStyle, endStyle, title) {\n\t      return inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);\n\t    };\n\t  }\n\t\n\t  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n\t    var widget = !ignoreWidget && marker.replacedWith;\n\t    if (widget) {\n\t      if (builder.copyWidgets) widget = widget.cloneNode(true);\n\t      builder.pre.appendChild(widget);\n\t      if (builder.measure) {\n\t        if (size) {\n\t          builder.measure[builder.pos] = widget;\n\t        } else {\n\t          var elt = zeroWidthElement(builder.cm.display.measure);\n\t          if (marker.type == \"bookmark\" && !marker.insertLeft)\n\t            builder.measure[builder.pos] = builder.pre.appendChild(elt);\n\t          else if (builder.measure[builder.pos])\n\t            return;\n\t          else\n\t            builder.measure[builder.pos] = builder.pre.insertBefore(elt, widget);\n\t        }\n\t        builder.measuredSomething = true;\n\t      }\n\t    }\n\t    builder.pos += size;\n\t  }\n\t\n\t  // Outputs a number of spans to make up a line, taking highlighting\n\t  // and marked text into account.\n\t  function insertLineContent(line, builder, styles) {\n\t    var spans = line.markedSpans, allText = line.text, at = 0;\n\t    if (!spans) {\n\t      for (var i = 1; i < styles.length; i+=2)\n\t        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder));\n\t      return;\n\t    }\n\t\n\t    var len = allText.length, pos = 0, i = 1, text = \"\", style;\n\t    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n\t    for (;;) {\n\t      if (nextChange == pos) { // Update current marker set\n\t        spanStyle = spanEndStyle = spanStartStyle = title = \"\";\n\t        collapsed = null; nextChange = Infinity;\n\t        var foundBookmarks = [];\n\t        for (var j = 0; j < spans.length; ++j) {\n\t          var sp = spans[j], m = sp.marker;\n\t          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\n\t            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = \"\"; }\n\t            if (m.className) spanStyle += \" \" + m.className;\n\t            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n\t            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\n\t            if (m.title && !title) title = m.title;\n\t            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n\t              collapsed = sp;\n\t          } else if (sp.from > pos && nextChange > sp.from) {\n\t            nextChange = sp.from;\n\t          }\n\t          if (m.type == \"bookmark\" && sp.from == pos && m.replacedWith) foundBookmarks.push(m);\n\t        }\n\t        if (collapsed && (collapsed.from || 0) == pos) {\n\t          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,\n\t                             collapsed.marker, collapsed.from == null);\n\t          if (collapsed.to == null) return collapsed.marker.find();\n\t        }\n\t        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n\t          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n\t      }\n\t      if (pos >= len) break;\n\t\n\t      var upto = Math.min(len, nextChange);\n\t      while (true) {\n\t        if (text) {\n\t          var end = pos + text.length;\n\t          if (!collapsed) {\n\t            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n\t            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n\t                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title);\n\t          }\n\t          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n\t          pos = end;\n\t          spanStartStyle = \"\";\n\t        }\n\t        text = allText.slice(at, at = styles[i++]);\n\t        style = interpretTokenStyle(styles[i++], builder);\n\t      }\n\t    }\n\t  }\n\t\n\t  // DOCUMENT DATA STRUCTURE\n\t\n\t  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {\n\t    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n\t    function update(line, text, spans) {\n\t      updateLine(line, text, spans, estimateHeight);\n\t      signalLater(line, \"change\", line, change);\n\t    }\n\t\n\t    var from = change.from, to = change.to, text = change.text;\n\t    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n\t    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\t\n\t    // First adjust the line structure\n\t    if (from.ch == 0 && to.ch == 0 && lastText == \"\" &&\n\t        (!doc.cm || doc.cm.options.wholeLineUpdateBefore)) {\n\t      // This is a whole-line replace. Treated specially to make\n\t      // sure line objects move the way they are supposed to.\n\t      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)\n\t        added.push(new Line(text[i], spansFor(i), estimateHeight));\n\t      update(lastLine, lastLine.text, lastSpans);\n\t      if (nlines) doc.remove(from.line, nlines);\n\t      if (added.length) doc.insert(from.line, added);\n\t    } else if (firstLine == lastLine) {\n\t      if (text.length == 1) {\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n\t      } else {\n\t        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)\n\t          added.push(new Line(text[i], spansFor(i), estimateHeight));\n\t        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t        doc.insert(from.line + 1, added);\n\t      }\n\t    } else if (text.length == 1) {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n\t      doc.remove(from.line + 1, nlines);\n\t    } else {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n\t      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)\n\t        added.push(new Line(text[i], spansFor(i), estimateHeight));\n\t      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n\t      doc.insert(from.line + 1, added);\n\t    }\n\t\n\t    signalLater(doc, \"change\", doc, change);\n\t    setSelection(doc, selAfter.anchor, selAfter.head, null, true);\n\t  }\n\t\n\t  function LeafChunk(lines) {\n\t    this.lines = lines;\n\t    this.parent = null;\n\t    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n\t      lines[i].parent = this;\n\t      height += lines[i].height;\n\t    }\n\t    this.height = height;\n\t  }\n\t\n\t  LeafChunk.prototype = {\n\t    chunkSize: function() { return this.lines.length; },\n\t    removeInner: function(at, n) {\n\t      for (var i = at, e = at + n; i < e; ++i) {\n\t        var line = this.lines[i];\n\t        this.height -= line.height;\n\t        cleanUpLine(line);\n\t        signalLater(line, \"delete\");\n\t      }\n\t      this.lines.splice(at, n);\n\t    },\n\t    collapse: function(lines) {\n\t      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n\t    },\n\t    insertInner: function(at, lines, height) {\n\t      this.height += height;\n\t      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n\t      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;\n\t    },\n\t    iterN: function(at, n, op) {\n\t      for (var e = at + n; at < e; ++at)\n\t        if (op(this.lines[at])) return true;\n\t    }\n\t  };\n\t\n\t  function BranchChunk(children) {\n\t    this.children = children;\n\t    var size = 0, height = 0;\n\t    for (var i = 0, e = children.length; i < e; ++i) {\n\t      var ch = children[i];\n\t      size += ch.chunkSize(); height += ch.height;\n\t      ch.parent = this;\n\t    }\n\t    this.size = size;\n\t    this.height = height;\n\t    this.parent = null;\n\t  }\n\t\n\t  BranchChunk.prototype = {\n\t    chunkSize: function() { return this.size; },\n\t    removeInner: function(at, n) {\n\t      this.size -= n;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var rm = Math.min(n, sz - at), oldHeight = child.height;\n\t          child.removeInner(at, rm);\n\t          this.height -= oldHeight - child.height;\n\t          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n\t          if ((n -= rm) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t      if (this.size - n < 25) {\n\t        var lines = [];\n\t        this.collapse(lines);\n\t        this.children = [new LeafChunk(lines)];\n\t        this.children[0].parent = this;\n\t      }\n\t    },\n\t    collapse: function(lines) {\n\t      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);\n\t    },\n\t    insertInner: function(at, lines, height) {\n\t      this.size += lines.length;\n\t      this.height += height;\n\t      for (var i = 0, e = this.children.length; i < e; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at <= sz) {\n\t          child.insertInner(at, lines, height);\n\t          if (child.lines && child.lines.length > 50) {\n\t            while (child.lines.length > 50) {\n\t              var spilled = child.lines.splice(child.lines.length - 25, 25);\n\t              var newleaf = new LeafChunk(spilled);\n\t              child.height -= newleaf.height;\n\t              this.children.splice(i + 1, 0, newleaf);\n\t              newleaf.parent = this;\n\t            }\n\t            this.maybeSpill();\n\t          }\n\t          break;\n\t        }\n\t        at -= sz;\n\t      }\n\t    },\n\t    maybeSpill: function() {\n\t      if (this.children.length <= 10) return;\n\t      var me = this;\n\t      do {\n\t        var spilled = me.children.splice(me.children.length - 5, 5);\n\t        var sibling = new BranchChunk(spilled);\n\t        if (!me.parent) { // Become the parent node\n\t          var copy = new BranchChunk(me.children);\n\t          copy.parent = me;\n\t          me.children = [copy, sibling];\n\t          me = copy;\n\t        } else {\n\t          me.size -= sibling.size;\n\t          me.height -= sibling.height;\n\t          var myIndex = indexOf(me.parent.children, me);\n\t          me.parent.children.splice(myIndex + 1, 0, sibling);\n\t        }\n\t        sibling.parent = me.parent;\n\t      } while (me.children.length > 10);\n\t      me.parent.maybeSpill();\n\t    },\n\t    iterN: function(at, n, op) {\n\t      for (var i = 0, e = this.children.length; i < e; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var used = Math.min(n, sz - at);\n\t          if (child.iterN(at, used, op)) return true;\n\t          if ((n -= used) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t    }\n\t  };\n\t\n\t  var nextDocId = 0;\n\t  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {\n\t    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\n\t    if (firstLine == null) firstLine = 0;\n\t\n\t    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n\t    this.first = firstLine;\n\t    this.scrollTop = this.scrollLeft = 0;\n\t    this.cantEdit = false;\n\t    this.history = makeHistory();\n\t    this.cleanGeneration = 1;\n\t    this.frontier = firstLine;\n\t    var start = Pos(firstLine, 0);\n\t    this.sel = {from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null};\n\t    this.id = ++nextDocId;\n\t    this.modeOption = mode;\n\t\n\t    if (typeof text == \"string\") text = splitLines(text);\n\t    updateDoc(this, {from: start, to: start, text: text}, null, {head: start, anchor: start});\n\t  };\n\t\n\t  Doc.prototype = createObj(BranchChunk.prototype, {\n\t    constructor: Doc,\n\t    iter: function(from, to, op) {\n\t      if (op) this.iterN(from - this.first, to - from, op);\n\t      else this.iterN(this.first, this.first + this.size, from);\n\t    },\n\t\n\t    insert: function(at, lines) {\n\t      var height = 0;\n\t      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;\n\t      this.insertInner(at - this.first, lines, height);\n\t    },\n\t    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\t\n\t    getValue: function(lineSep) {\n\t      var lines = getLines(this, this.first, this.first + this.size);\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || \"\\n\");\n\t    },\n\t    setValue: function(code) {\n\t      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n\t      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n\t                        text: splitLines(code), origin: \"setValue\"},\n\t                 {head: top, anchor: top}, true);\n\t    },\n\t    replaceRange: function(code, from, to, origin) {\n\t      from = clipPos(this, from);\n\t      to = to ? clipPos(this, to) : from;\n\t      replaceRange(this, code, from, to, origin);\n\t    },\n\t    getRange: function(from, to, lineSep) {\n\t      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || \"\\n\");\n\t    },\n\t\n\t    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\t    setLine: function(line, text) {\n\t      if (isLine(this, line))\n\t        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));\n\t    },\n\t    removeLine: function(line) {\n\t      if (line) replaceRange(this, \"\", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));\n\t      else replaceRange(this, \"\", Pos(0, 0), clipPos(this, Pos(1, 0)));\n\t    },\n\t\n\t    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n\t    getLineNumber: function(line) {return lineNo(line);},\n\t\n\t    getLineHandleVisualStart: function(line) {\n\t      if (typeof line == \"number\") line = getLine(this, line);\n\t      return visualLine(this, line);\n\t    },\n\t\n\t    lineCount: function() {return this.size;},\n\t    firstLine: function() {return this.first;},\n\t    lastLine: function() {return this.first + this.size - 1;},\n\t\n\t    clipPos: function(pos) {return clipPos(this, pos);},\n\t\n\t    getCursor: function(start) {\n\t      var sel = this.sel, pos;\n\t      if (start == null || start == \"head\") pos = sel.head;\n\t      else if (start == \"anchor\") pos = sel.anchor;\n\t      else if (start == \"end\" || start === false) pos = sel.to;\n\t      else pos = sel.from;\n\t      return copyPos(pos);\n\t    },\n\t    somethingSelected: function() {return !posEq(this.sel.head, this.sel.anchor);},\n\t\n\t    setCursor: docOperation(function(line, ch, extend) {\n\t      var pos = clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line);\n\t      if (extend) extendSelection(this, pos);\n\t      else setSelection(this, pos, pos);\n\t    }),\n\t    setSelection: docOperation(function(anchor, head, bias) {\n\t      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), bias);\n\t    }),\n\t    extendSelection: docOperation(function(from, to, bias) {\n\t      extendSelection(this, clipPos(this, from), to && clipPos(this, to), bias);\n\t    }),\n\t\n\t    getSelection: function(lineSep) {return this.getRange(this.sel.from, this.sel.to, lineSep);},\n\t    replaceSelection: function(code, collapse, origin) {\n\t      makeChange(this, {from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin}, collapse || \"around\");\n\t    },\n\t    undo: docOperation(function() {makeChangeFromHistory(this, \"undo\");}),\n\t    redo: docOperation(function() {makeChangeFromHistory(this, \"redo\");}),\n\t\n\t    setExtending: function(val) {this.sel.extend = val;},\n\t\n\t    historySize: function() {\n\t      var hist = this.history;\n\t      return {undo: hist.done.length, redo: hist.undone.length};\n\t    },\n\t    clearHistory: function() {this.history = makeHistory(this.history.maxGeneration);},\n\t\n\t    markClean: function() {\n\t      this.cleanGeneration = this.changeGeneration(true);\n\t    },\n\t    changeGeneration: function(forceSplit) {\n\t      if (forceSplit)\n\t        this.history.lastOp = this.history.lastOrigin = null;\n\t      return this.history.generation;\n\t    },\n\t    isClean: function (gen) {\n\t      return this.history.generation == (gen || this.cleanGeneration);\n\t    },\n\t\n\t    getHistory: function() {\n\t      return {done: copyHistoryArray(this.history.done),\n\t              undone: copyHistoryArray(this.history.undone)};\n\t    },\n\t    setHistory: function(histData) {\n\t      var hist = this.history = makeHistory(this.history.maxGeneration);\n\t      hist.done = histData.done.slice(0);\n\t      hist.undone = histData.undone.slice(0);\n\t    },\n\t\n\t    markText: function(from, to, options) {\n\t      return markText(this, clipPos(this, from), clipPos(this, to), options, \"range\");\n\t    },\n\t    setBookmark: function(pos, options) {\n\t      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n\t                      insertLeft: options && options.insertLeft,\n\t                      clearWhenEmpty: false};\n\t      pos = clipPos(this, pos);\n\t      return markText(this, pos, pos, realOpts, \"bookmark\");\n\t    },\n\t    findMarksAt: function(pos) {\n\t      pos = clipPos(this, pos);\n\t      var markers = [], spans = getLine(this, pos.line).markedSpans;\n\t      if (spans) for (var i = 0; i < spans.length; ++i) {\n\t        var span = spans[i];\n\t        if ((span.from == null || span.from <= pos.ch) &&\n\t            (span.to == null || span.to >= pos.ch))\n\t          markers.push(span.marker.parent || span.marker);\n\t      }\n\t      return markers;\n\t    },\n\t    findMarks: function(from, to) {\n\t      from = clipPos(this, from); to = clipPos(this, to);\n\t      var found = [], lineNo = from.line;\n\t      this.iter(from.line, to.line + 1, function(line) {\n\t        var spans = line.markedSpans;\n\t        if (spans) for (var i = 0; i < spans.length; i++) {\n\t          var span = spans[i];\n\t          if (!(lineNo == from.line && from.ch > span.to ||\n\t                span.from == null && lineNo != from.line||\n\t                lineNo == to.line && span.from > to.ch))\n\t            found.push(span.marker.parent || span.marker);\n\t        }\n\t        ++lineNo;\n\t      });\n\t      return found;\n\t    },\n\t    getAllMarks: function() {\n\t      var markers = [];\n\t      this.iter(function(line) {\n\t        var sps = line.markedSpans;\n\t        if (sps) for (var i = 0; i < sps.length; ++i)\n\t          if (sps[i].from != null) markers.push(sps[i].marker);\n\t      });\n\t      return markers;\n\t    },\n\t\n\t    posFromIndex: function(off) {\n\t      var ch, lineNo = this.first;\n\t      this.iter(function(line) {\n\t        var sz = line.text.length + 1;\n\t        if (sz > off) { ch = off; return true; }\n\t        off -= sz;\n\t        ++lineNo;\n\t      });\n\t      return clipPos(this, Pos(lineNo, ch));\n\t    },\n\t    indexFromPos: function (coords) {\n\t      coords = clipPos(this, coords);\n\t      var index = coords.ch;\n\t      if (coords.line < this.first || coords.ch < 0) return 0;\n\t      this.iter(this.first, coords.line, function (line) {\n\t        index += line.text.length + 1;\n\t      });\n\t      return index;\n\t    },\n\t\n\t    copy: function(copyHistory) {\n\t      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\n\t      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n\t      doc.sel = {from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,\n\t                 shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn};\n\t      if (copyHistory) {\n\t        doc.history.undoDepth = this.history.undoDepth;\n\t        doc.setHistory(this.getHistory());\n\t      }\n\t      return doc;\n\t    },\n\t\n\t    linkedDoc: function(options) {\n\t      if (!options) options = {};\n\t      var from = this.first, to = this.first + this.size;\n\t      if (options.from != null && options.from > from) from = options.from;\n\t      if (options.to != null && options.to < to) to = options.to;\n\t      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\n\t      if (options.sharedHist) copy.history = this.history;\n\t      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n\t      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n\t      return copy;\n\t    },\n\t    unlinkDoc: function(other) {\n\t      if (other instanceof CodeMirror) other = other.doc;\n\t      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n\t        var link = this.linked[i];\n\t        if (link.doc != other) continue;\n\t        this.linked.splice(i, 1);\n\t        other.unlinkDoc(this);\n\t        break;\n\t      }\n\t      // If the histories were shared, split them again\n\t      if (other.history == this.history) {\n\t        var splitIds = [other.id];\n\t        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n\t        other.history = makeHistory();\n\t        other.history.done = copyHistoryArray(this.history.done, splitIds);\n\t        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n\t      }\n\t    },\n\t    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\t\n\t    getMode: function() {return this.mode;},\n\t    getEditor: function() {return this.cm;}\n\t  });\n\t\n\t  Doc.prototype.eachLine = Doc.prototype.iter;\n\t\n\t  // The Doc methods that should be available on CodeMirror instances\n\t  var dontDelegate = \"iter insert remove copy getEditor\".split(\" \");\n\t  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n\t    CodeMirror.prototype[prop] = (function(method) {\n\t      return function() {return method.apply(this.doc, arguments);};\n\t    })(Doc.prototype[prop]);\n\t\n\t  eventMixin(Doc);\n\t\n\t  function linkedDocs(doc, f, sharedHistOnly) {\n\t    function propagate(doc, skip, sharedHist) {\n\t      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n\t        var rel = doc.linked[i];\n\t        if (rel.doc == skip) continue;\n\t        var shared = sharedHist && rel.sharedHist;\n\t        if (sharedHistOnly && !shared) continue;\n\t        f(rel.doc, shared);\n\t        propagate(rel.doc, doc, shared);\n\t      }\n\t    }\n\t    propagate(doc, null, true);\n\t  }\n\t\n\t  function attachDoc(cm, doc) {\n\t    if (doc.cm) throw new Error(\"This document is already in use.\");\n\t    cm.doc = doc;\n\t    doc.cm = cm;\n\t    estimateLineHeights(cm);\n\t    loadMode(cm);\n\t    if (!cm.options.lineWrapping) computeMaxLength(cm);\n\t    cm.options.mode = doc.modeOption;\n\t    regChange(cm);\n\t  }\n\t\n\t  // LINE UTILITIES\n\t\n\t  function getLine(chunk, n) {\n\t    n -= chunk.first;\n\t    while (!chunk.lines) {\n\t      for (var i = 0;; ++i) {\n\t        var child = chunk.children[i], sz = child.chunkSize();\n\t        if (n < sz) { chunk = child; break; }\n\t        n -= sz;\n\t      }\n\t    }\n\t    return chunk.lines[n];\n\t  }\n\t\n\t  function getBetween(doc, start, end) {\n\t    var out = [], n = start.line;\n\t    doc.iter(start.line, end.line + 1, function(line) {\n\t      var text = line.text;\n\t      if (n == end.line) text = text.slice(0, end.ch);\n\t      if (n == start.line) text = text.slice(start.ch);\n\t      out.push(text);\n\t      ++n;\n\t    });\n\t    return out;\n\t  }\n\t  function getLines(doc, from, to) {\n\t    var out = [];\n\t    doc.iter(from, to, function(line) { out.push(line.text); });\n\t    return out;\n\t  }\n\t\n\t  function updateLineHeight(line, height) {\n\t    var diff = height - line.height;\n\t    for (var n = line; n; n = n.parent) n.height += diff;\n\t  }\n\t\n\t  function lineNo(line) {\n\t    if (line.parent == null) return null;\n\t    var cur = line.parent, no = indexOf(cur.lines, line);\n\t    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n\t      for (var i = 0;; ++i) {\n\t        if (chunk.children[i] == cur) break;\n\t        no += chunk.children[i].chunkSize();\n\t      }\n\t    }\n\t    return no + cur.first;\n\t  }\n\t\n\t  function lineAtHeight(chunk, h) {\n\t    var n = chunk.first;\n\t    outer: do {\n\t      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n\t        var child = chunk.children[i], ch = child.height;\n\t        if (h < ch) { chunk = child; continue outer; }\n\t        h -= ch;\n\t        n += child.chunkSize();\n\t      }\n\t      return n;\n\t    } while (!chunk.lines);\n\t    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n\t      var line = chunk.lines[i], lh = line.height;\n\t      if (h < lh) break;\n\t      h -= lh;\n\t    }\n\t    return n + i;\n\t  }\n\t\n\t  function heightAtLine(cm, lineObj) {\n\t    lineObj = visualLine(cm.doc, lineObj);\n\t\n\t    var h = 0, chunk = lineObj.parent;\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i];\n\t      if (line == lineObj) break;\n\t      else h += line.height;\n\t    }\n\t    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n\t      for (var i = 0; i < p.children.length; ++i) {\n\t        var cur = p.children[i];\n\t        if (cur == chunk) break;\n\t        else h += cur.height;\n\t      }\n\t    }\n\t    return h;\n\t  }\n\t\n\t  function getOrder(line) {\n\t    var order = line.order;\n\t    if (order == null) order = line.order = bidiOrdering(line.text);\n\t    return order;\n\t  }\n\t\n\t  // HISTORY\n\t\n\t  function makeHistory(startGen) {\n\t    return {\n\t      // Arrays of history events. Doing something adds an event to\n\t      // done and clears undo. Undoing moves events from done to\n\t      // undone, redoing moves them in the other direction.\n\t      done: [], undone: [], undoDepth: Infinity,\n\t      // Used to track when changes can be merged into a single undo\n\t      // event\n\t      lastTime: 0, lastOp: null, lastOrigin: null,\n\t      // Used by the isClean() method\n\t      generation: startGen || 1, maxGeneration: startGen || 1\n\t    };\n\t  }\n\t\n\t  function attachLocalSpans(doc, change, from, to) {\n\t    var existing = change[\"spans_\" + doc.id], n = 0;\n\t    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n\t      if (line.markedSpans)\n\t        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n\t      ++n;\n\t    });\n\t  }\n\t\n\t  function historyChangeFromChange(doc, change) {\n\t    var from = { line: change.from.line, ch: change.from.ch };\n\t    var histChange = {from: from, to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n\t    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n\t    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n\t    return histChange;\n\t  }\n\t\n\t  function addToHistory(doc, change, selAfter, opId) {\n\t    var hist = doc.history;\n\t    hist.undone.length = 0;\n\t    var time = +new Date, cur = lst(hist.done);\n\t\n\t    if (cur &&\n\t        (hist.lastOp == opId ||\n\t         hist.lastOrigin == change.origin && change.origin &&\n\t         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay) ||\n\t          change.origin.charAt(0) == \"*\"))) {\n\t      // Merge this change into the last event\n\t      var last = lst(cur.changes);\n\t      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {\n\t        // Optimized case for simple insertion -- don't want to add\n\t        // new changesets for every character typed\n\t        last.to = changeEnd(change);\n\t      } else {\n\t        // Add new sub-event\n\t        cur.changes.push(historyChangeFromChange(doc, change));\n\t      }\n\t      cur.anchorAfter = selAfter.anchor; cur.headAfter = selAfter.head;\n\t    } else {\n\t      // Can not be merged, start a new event.\n\t      cur = {changes: [historyChangeFromChange(doc, change)],\n\t             generation: hist.generation,\n\t             anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,\n\t             anchorAfter: selAfter.anchor, headAfter: selAfter.head};\n\t      hist.done.push(cur);\n\t      while (hist.done.length > hist.undoDepth)\n\t        hist.done.shift();\n\t    }\n\t    hist.generation = ++hist.maxGeneration;\n\t    hist.lastTime = time;\n\t    hist.lastOp = opId;\n\t    hist.lastOrigin = change.origin;\n\t\n\t    if (!last) signal(doc, \"historyAdded\");\n\t  }\n\t\n\t  function removeClearedSpans(spans) {\n\t    if (!spans) return null;\n\t    for (var i = 0, out; i < spans.length; ++i) {\n\t      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n\t      else if (out) out.push(spans[i]);\n\t    }\n\t    return !out ? spans : out.length ? out : null;\n\t  }\n\t\n\t  function getOldSpans(doc, change) {\n\t    var found = change[\"spans_\" + doc.id];\n\t    if (!found) return null;\n\t    for (var i = 0, nw = []; i < change.text.length; ++i)\n\t      nw.push(removeClearedSpans(found[i]));\n\t    return nw;\n\t  }\n\t\n\t  // Used both to provide a JSON-safe object in .getHistory, and, when\n\t  // detaching a document, to split the history in two\n\t  function copyHistoryArray(events, newGroup) {\n\t    for (var i = 0, copy = []; i < events.length; ++i) {\n\t      var event = events[i], changes = event.changes, newChanges = [];\n\t      copy.push({changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,\n\t                 anchorAfter: event.anchorAfter, headAfter: event.headAfter});\n\t      for (var j = 0; j < changes.length; ++j) {\n\t        var change = changes[j], m;\n\t        newChanges.push({from: change.from, to: change.to, text: change.text});\n\t        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n\t          if (indexOf(newGroup, Number(m[1])) > -1) {\n\t            lst(newChanges)[prop] = change[prop];\n\t            delete change[prop];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return copy;\n\t  }\n\t\n\t  // Rebasing/resetting history to deal with externally-sourced changes\n\t\n\t  function rebaseHistSel(pos, from, to, diff) {\n\t    if (to < pos.line) {\n\t      pos.line += diff;\n\t    } else if (from < pos.line) {\n\t      pos.line = from;\n\t      pos.ch = 0;\n\t    }\n\t  }\n\t\n\t  // Tries to rebase an array of history events given a change in the\n\t  // document. If the change touches the same lines as the event, the\n\t  // event, and everything 'behind' it, is discarded. If the change is\n\t  // before the event, the event's positions are updated. Uses a\n\t  // copy-on-write scheme for the positions, to avoid having to\n\t  // reallocate them all on every rebase, but also avoid problems with\n\t  // shared position objects being unsafely updated.\n\t  function rebaseHistArray(array, from, to, diff) {\n\t    for (var i = 0; i < array.length; ++i) {\n\t      var sub = array[i], ok = true;\n\t      for (var j = 0; j < sub.changes.length; ++j) {\n\t        var cur = sub.changes[j];\n\t        if (!sub.copied) { cur.from = copyPos(cur.from); cur.to = copyPos(cur.to); }\n\t        if (to < cur.from.line) {\n\t          cur.from.line += diff;\n\t          cur.to.line += diff;\n\t        } else if (from <= cur.to.line) {\n\t          ok = false;\n\t          break;\n\t        }\n\t      }\n\t      if (!sub.copied) {\n\t        sub.anchorBefore = copyPos(sub.anchorBefore); sub.headBefore = copyPos(sub.headBefore);\n\t        sub.anchorAfter = copyPos(sub.anchorAfter); sub.readAfter = copyPos(sub.headAfter);\n\t        sub.copied = true;\n\t      }\n\t      if (!ok) {\n\t        array.splice(0, i + 1);\n\t        i = 0;\n\t      } else {\n\t        rebaseHistSel(sub.anchorBefore); rebaseHistSel(sub.headBefore);\n\t        rebaseHistSel(sub.anchorAfter); rebaseHistSel(sub.headAfter);\n\t      }\n\t    }\n\t  }\n\t\n\t  function rebaseHist(hist, change) {\n\t    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n\t    rebaseHistArray(hist.done, from, to, diff);\n\t    rebaseHistArray(hist.undone, from, to, diff);\n\t  }\n\t\n\t  // EVENT OPERATORS\n\t\n\t  function stopMethod() {e_stop(this);}\n\t  // Ensure an event has a stop method.\n\t  function addStop(event) {\n\t    if (!event.stop) event.stop = stopMethod;\n\t    return event;\n\t  }\n\t\n\t  function e_preventDefault(e) {\n\t    if (e.preventDefault) e.preventDefault();\n\t    else e.returnValue = false;\n\t  }\n\t  function e_stopPropagation(e) {\n\t    if (e.stopPropagation) e.stopPropagation();\n\t    else e.cancelBubble = true;\n\t  }\n\t  function e_defaultPrevented(e) {\n\t    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n\t  }\n\t  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\t  CodeMirror.e_stop = e_stop;\n\t  CodeMirror.e_preventDefault = e_preventDefault;\n\t  CodeMirror.e_stopPropagation = e_stopPropagation;\n\t\n\t  function e_target(e) {return e.target || e.srcElement;}\n\t  function e_button(e) {\n\t    var b = e.which;\n\t    if (b == null) {\n\t      if (e.button & 1) b = 1;\n\t      else if (e.button & 2) b = 3;\n\t      else if (e.button & 4) b = 2;\n\t    }\n\t    if (mac && e.ctrlKey && b == 1) b = 3;\n\t    return b;\n\t  }\n\t\n\t  // EVENT HANDLING\n\t\n\t  function on(emitter, type, f) {\n\t    if (emitter.addEventListener)\n\t      emitter.addEventListener(type, f, false);\n\t    else if (emitter.attachEvent)\n\t      emitter.attachEvent(\"on\" + type, f);\n\t    else {\n\t      var map = emitter._handlers || (emitter._handlers = {});\n\t      var arr = map[type] || (map[type] = []);\n\t      arr.push(f);\n\t    }\n\t  }\n\t\n\t  function off(emitter, type, f) {\n\t    if (emitter.removeEventListener)\n\t      emitter.removeEventListener(type, f, false);\n\t    else if (emitter.detachEvent)\n\t      emitter.detachEvent(\"on\" + type, f);\n\t    else {\n\t      var arr = emitter._handlers && emitter._handlers[type];\n\t      if (!arr) return;\n\t      for (var i = 0; i < arr.length; ++i)\n\t        if (arr[i] == f) { arr.splice(i, 1); break; }\n\t    }\n\t  }\n\t\n\t  function signal(emitter, type /*, values...*/) {\n\t    var arr = emitter._handlers && emitter._handlers[type];\n\t    if (!arr) return;\n\t    var args = Array.prototype.slice.call(arguments, 2);\n\t    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\n\t  }\n\t\n\t  var delayedCallbacks, delayedCallbackDepth = 0;\n\t  function signalLater(emitter, type /*, values...*/) {\n\t    var arr = emitter._handlers && emitter._handlers[type];\n\t    if (!arr) return;\n\t    var args = Array.prototype.slice.call(arguments, 2);\n\t    if (!delayedCallbacks) {\n\t      ++delayedCallbackDepth;\n\t      delayedCallbacks = [];\n\t      setTimeout(fireDelayed, 0);\n\t    }\n\t    function bnd(f) {return function(){f.apply(null, args);};};\n\t    for (var i = 0; i < arr.length; ++i)\n\t      delayedCallbacks.push(bnd(arr[i]));\n\t  }\n\t\n\t  function signalDOMEvent(cm, e, override) {\n\t    signal(cm, override || e.type, cm, e);\n\t    return e_defaultPrevented(e) || e.codemirrorIgnore;\n\t  }\n\t\n\t  function fireDelayed() {\n\t    --delayedCallbackDepth;\n\t    var delayed = delayedCallbacks;\n\t    delayedCallbacks = null;\n\t    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n\t  }\n\t\n\t  function hasHandler(emitter, type) {\n\t    var arr = emitter._handlers && emitter._handlers[type];\n\t    return arr && arr.length > 0;\n\t  }\n\t\n\t  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;\n\t\n\t  function eventMixin(ctor) {\n\t    ctor.prototype.on = function(type, f) {on(this, type, f);};\n\t    ctor.prototype.off = function(type, f) {off(this, type, f);};\n\t  }\n\t\n\t  // MISC UTILITIES\n\t\n\t  // Number of pixels added to scroller and sizer to hide scrollbar\n\t  var scrollerCutOff = 30;\n\t\n\t  // Returned or thrown by various protocols to signal 'I'm not\n\t  // handling this'.\n\t  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\t\n\t  function Delayed() {this.id = null;}\n\t  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n\t\n\t  // Counts the column offset in a string, taking tabs into account.\n\t  // Used mostly to find indentation.\n\t  function countColumn(string, end, tabSize, startIndex, startValue) {\n\t    if (end == null) {\n\t      end = string.search(/[^\\s\\u00a0]/);\n\t      if (end == -1) end = string.length;\n\t    }\n\t    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {\n\t      if (string.charAt(i) == \"\\t\") n += tabSize - (n % tabSize);\n\t      else ++n;\n\t    }\n\t    return n;\n\t  }\n\t  CodeMirror.countColumn = countColumn;\n\t\n\t  var spaceStrs = [\"\"];\n\t  function spaceStr(n) {\n\t    while (spaceStrs.length <= n)\n\t      spaceStrs.push(lst(spaceStrs) + \" \");\n\t    return spaceStrs[n];\n\t  }\n\t\n\t  function lst(arr) { return arr[arr.length-1]; }\n\t\n\t  function selectInput(node) {\n\t    if (ios) { // Mobile Safari apparently has a bug where select() is broken.\n\t      node.selectionStart = 0;\n\t      node.selectionEnd = node.value.length;\n\t    } else {\n\t      // Suppress mysterious IE10 errors\n\t      try { node.select(); }\n\t      catch(_e) {}\n\t    }\n\t  }\n\t\n\t  function indexOf(collection, elt) {\n\t    if (collection.indexOf) return collection.indexOf(elt);\n\t    for (var i = 0, e = collection.length; i < e; ++i)\n\t      if (collection[i] == elt) return i;\n\t    return -1;\n\t  }\n\t\n\t  function createObj(base, props) {\n\t    function Obj() {}\n\t    Obj.prototype = base;\n\t    var inst = new Obj();\n\t    if (props) copyObj(props, inst);\n\t    return inst;\n\t  }\n\t\n\t  function copyObj(obj, target) {\n\t    if (!target) target = {};\n\t    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];\n\t    return target;\n\t  }\n\t\n\t  function emptyArray(size) {\n\t    for (var a = [], i = 0; i < size; ++i) a.push(undefined);\n\t    return a;\n\t  }\n\t\n\t  function bind(f) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    return function(){return f.apply(null, args);};\n\t  }\n\t\n\t  var nonASCIISingleCaseWordChar = /[\\u00df\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\t  function isWordChar(ch) {\n\t    return /\\w/.test(ch) || ch > \"\\x80\" &&\n\t      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n\t  }\n\t\n\t  function isEmpty(obj) {\n\t    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n\t    return true;\n\t  }\n\t\n\t  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n\t  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\t\n\t  // DOM UTILITIES\n\t\n\t  function elt(tag, content, className, style) {\n\t    var e = document.createElement(tag);\n\t    if (className) e.className = className;\n\t    if (style) e.style.cssText = style;\n\t    if (typeof content == \"string\") setTextContent(e, content);\n\t    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n\t    return e;\n\t  }\n\t\n\t  function removeChildren(e) {\n\t    for (var count = e.childNodes.length; count > 0; --count)\n\t      e.removeChild(e.firstChild);\n\t    return e;\n\t  }\n\t\n\t  function removeChildrenAndAdd(parent, e) {\n\t    return removeChildren(parent).appendChild(e);\n\t  }\n\t\n\t  function setTextContent(e, str) {\n\t    if (ie_lt9) {\n\t      e.innerHTML = \"\";\n\t      e.appendChild(document.createTextNode(str));\n\t    } else e.textContent = str;\n\t  }\n\t\n\t  function getRect(node) {\n\t    return node.getBoundingClientRect();\n\t  }\n\t  CodeMirror.replaceGetRect = function(f) { getRect = f; };\n\t\n\t  // FEATURE DETECTION\n\t\n\t  // Detect drag-and-drop\n\t  var dragAndDrop = function() {\n\t    // There is *some* kind of drag-and-drop support in IE6-8, but I\n\t    // couldn't get it to work yet.\n\t    if (ie_lt9) return false;\n\t    var div = elt('div');\n\t    return \"draggable\" in div || \"dragDrop\" in div;\n\t  }();\n\t\n\t  // For a reason I have yet to figure out, some browsers disallow\n\t  // word wrapping between certain characters *only* if a new inline\n\t  // element is started between them. This makes it hard to reliably\n\t  // measure the position of things, since that requires inserting an\n\t  // extra span. This terribly fragile set of tests matches the\n\t  // character combinations that suffer from this phenomenon on the\n\t  // various browsers.\n\t  function spanAffectsWrapping() { return false; }\n\t  if (gecko) // Only for \"$'\"\n\t    spanAffectsWrapping = function(str, i) {\n\t      return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;\n\t    };\n\t  else if (safari && !/Version\\/([6-9]|\\d\\d)\\b/.test(navigator.userAgent))\n\t    spanAffectsWrapping = function(str, i) {\n\t      return /\\-[^ \\-?]|\\?[^ !\\'\\\"\\),.\\-\\/:;\\?\\]\\}]/.test(str.slice(i - 1, i + 1));\n\t    };\n\t  else if (webkit && /Chrome\\/(?:29|[3-9]\\d|\\d\\d\\d)\\./.test(navigator.userAgent))\n\t    spanAffectsWrapping = function(str, i) {\n\t      var code = str.charCodeAt(i - 1);\n\t      return code >= 8208 && code <= 8212;\n\t    };\n\t  else if (webkit)\n\t    spanAffectsWrapping = function(str, i) {\n\t      if (i > 1 && str.charCodeAt(i - 1) == 45) {\n\t        if (/\\w/.test(str.charAt(i - 2)) && /[^\\-?\\.]/.test(str.charAt(i))) return true;\n\t        if (i > 2 && /[\\d\\.,]/.test(str.charAt(i - 2)) && /[\\d\\.,]/.test(str.charAt(i))) return false;\n\t      }\n\t      return /[~!#%&*)=+}\\]\\\\|\\\"\\.>,:;][({[<]|-[^\\-?\\.\\u2010-\\u201f\\u2026]|\\?[\\w~`@#$%\\^&*(_=+{[|><]|\\u2026[\\w~`@#$%\\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));\n\t    };\n\t\n\t  var knownScrollbarWidth;\n\t  function scrollbarWidth(measure) {\n\t    if (knownScrollbarWidth != null) return knownScrollbarWidth;\n\t    var test = elt(\"div\", null, null, \"width: 50px; height: 50px; overflow-x: scroll\");\n\t    removeChildrenAndAdd(measure, test);\n\t    if (test.offsetWidth)\n\t      knownScrollbarWidth = test.offsetHeight - test.clientHeight;\n\t    return knownScrollbarWidth || 0;\n\t  }\n\t\n\t  var zwspSupported;\n\t  function zeroWidthElement(measure) {\n\t    if (zwspSupported == null) {\n\t      var test = elt(\"span\", \"\\u200b\");\n\t      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n\t      if (measure.firstChild.offsetHeight != 0)\n\t        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;\n\t    }\n\t    if (zwspSupported) return elt(\"span\", \"\\u200b\");\n\t    else return elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n\t  }\n\t\n\t  // See if \"\".split is the broken IE version, if so, provide an\n\t  // alternative way to split lines.\n\t  var splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n\t    var pos = 0, result = [], l = string.length;\n\t    while (pos <= l) {\n\t      var nl = string.indexOf(\"\\n\", pos);\n\t      if (nl == -1) nl = string.length;\n\t      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n\t      var rt = line.indexOf(\"\\r\");\n\t      if (rt != -1) {\n\t        result.push(line.slice(0, rt));\n\t        pos += rt + 1;\n\t      } else {\n\t        result.push(line);\n\t        pos = nl + 1;\n\t      }\n\t    }\n\t    return result;\n\t  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\t  CodeMirror.splitLines = splitLines;\n\t\n\t  var hasSelection = window.getSelection ? function(te) {\n\t    try { return te.selectionStart != te.selectionEnd; }\n\t    catch(e) { return false; }\n\t  } : function(te) {\n\t    try {var range = te.ownerDocument.selection.createRange();}\n\t    catch(e) {}\n\t    if (!range || range.parentElement() != te) return false;\n\t    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n\t  };\n\t\n\t  var hasCopyEvent = (function() {\n\t    var e = elt(\"div\");\n\t    if (\"oncopy\" in e) return true;\n\t    e.setAttribute(\"oncopy\", \"return;\");\n\t    return typeof e.oncopy == 'function';\n\t  })();\n\t\n\t  // KEY NAMING\n\t\n\t  var keyNames = {3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n\t                  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n\t                  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n\t                  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\", 107: \"=\", 109: \"-\", 127: \"Delete\",\n\t                  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n\t                  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n\t                  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"};\n\t  CodeMirror.keyNames = keyNames;\n\t  (function() {\n\t    // Number keys\n\t    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n\t    // Alphabetic keys\n\t    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n\t    // Function keys\n\t    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n\t  })();\n\t\n\t  // BIDI HELPERS\n\t\n\t  function iterateBidiSections(order, from, to, f) {\n\t    if (!order) return f(from, to, \"ltr\");\n\t    var found = false;\n\t    for (var i = 0; i < order.length; ++i) {\n\t      var part = order[i];\n\t      if (part.from < to && part.to > from || from == to && part.to == from) {\n\t        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n\t        found = true;\n\t      }\n\t    }\n\t    if (!found) f(from, to, \"ltr\");\n\t  }\n\t\n\t  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n\t  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\t\n\t  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n\t  function lineRight(line) {\n\t    var order = getOrder(line);\n\t    if (!order) return line.text.length;\n\t    return bidiRight(lst(order));\n\t  }\n\t\n\t  function lineStart(cm, lineN) {\n\t    var line = getLine(cm.doc, lineN);\n\t    var visual = visualLine(cm.doc, line);\n\t    if (visual != line) lineN = lineNo(visual);\n\t    var order = getOrder(visual);\n\t    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n\t    return Pos(lineN, ch);\n\t  }\n\t  function lineEnd(cm, lineN) {\n\t    var merged, line;\n\t    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))\n\t      lineN = merged.find().to.line;\n\t    var order = getOrder(line);\n\t    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n\t    return Pos(lineN, ch);\n\t  }\n\t\n\t  function compareBidiLevel(order, a, b) {\n\t    var linedir = order[0].level;\n\t    if (a == linedir) return true;\n\t    if (b == linedir) return false;\n\t    return a < b;\n\t  }\n\t  var bidiOther;\n\t  function getBidiPartAt(order, pos) {\n\t    bidiOther = null;\n\t    for (var i = 0, found; i < order.length; ++i) {\n\t      var cur = order[i];\n\t      if (cur.from < pos && cur.to > pos) return i;\n\t      if ((cur.from == pos || cur.to == pos)) {\n\t        if (found == null) {\n\t          found = i;\n\t        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n\t          if (cur.from != cur.to) bidiOther = found;\n\t          return i;\n\t        } else {\n\t          if (cur.from != cur.to) bidiOther = i;\n\t          return found;\n\t        }\n\t      }\n\t    }\n\t    return found;\n\t  }\n\t\n\t  function moveInLine(line, pos, dir, byUnit) {\n\t    if (!byUnit) return pos + dir;\n\t    do pos += dir;\n\t    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n\t    return pos;\n\t  }\n\t\n\t  // This is somewhat involved. It is needed in order to move\n\t  // 'visually' through bi-directional text -- i.e., pressing left\n\t  // should make the cursor go left, even when in RTL text. The\n\t  // tricky part is the 'jumps', where RTL and LTR text touch each\n\t  // other. This often requires the cursor offset to move more than\n\t  // one unit, in order to visually move one unit.\n\t  function moveVisually(line, start, dir, byUnit) {\n\t    var bidi = getOrder(line);\n\t    if (!bidi) return moveLogically(line, start, dir, byUnit);\n\t    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n\t    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\t\n\t    for (;;) {\n\t      if (target > part.from && target < part.to) return target;\n\t      if (target == part.from || target == part.to) {\n\t        if (getBidiPartAt(bidi, target) == pos) return target;\n\t        part = bidi[pos += dir];\n\t        return (dir > 0) == part.level % 2 ? part.to : part.from;\n\t      } else {\n\t        part = bidi[pos += dir];\n\t        if (!part) return null;\n\t        if ((dir > 0) == part.level % 2)\n\t          target = moveInLine(line, part.to, -1, byUnit);\n\t        else\n\t          target = moveInLine(line, part.from, 1, byUnit);\n\t      }\n\t    }\n\t  }\n\t\n\t  function moveLogically(line, start, dir, byUnit) {\n\t    var target = start + dir;\n\t    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n\t    return target < 0 || target > line.text.length ? null : target;\n\t  }\n\t\n\t  // Bidirectional ordering algorithm\n\t  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n\t  // that this (partially) implements.\n\t\n\t  // One-char codes used for character types:\n\t  // L (L):   Left-to-Right\n\t  // R (R):   Right-to-Left\n\t  // r (AL):  Right-to-Left Arabic\n\t  // 1 (EN):  European Number\n\t  // + (ES):  European Number Separator\n\t  // % (ET):  European Number Terminator\n\t  // n (AN):  Arabic Number\n\t  // , (CS):  Common Number Separator\n\t  // m (NSM): Non-Spacing Mark\n\t  // b (BN):  Boundary Neutral\n\t  // s (B):   Paragraph Separator\n\t  // t (S):   Segment Separator\n\t  // w (WS):  Whitespace\n\t  // N (ON):  Other Neutrals\n\t\n\t  // Returns null if characters are ordered as they appear\n\t  // (left-to-right), or an array of sections ({from, to, level}\n\t  // objects) in the order in which they occur visually.\n\t  var bidiOrdering = (function() {\n\t    // Character types for codepoints 0 to 0xff\n\t    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL\";\n\t    // Character types for codepoints 0x600 to 0x6ff\n\t    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr\";\n\t    function charType(code) {\n\t      if (code <= 0xff) return lowTypes.charAt(code);\n\t      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n\t      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);\n\t      else if (0x700 <= code && code <= 0x8ac) return \"r\";\n\t      else return \"L\";\n\t    }\n\t\n\t    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n\t    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\t    // Browsers seem to always treat the boundaries of block elements as being L.\n\t    var outerType = \"L\";\n\t\n\t    return function(str) {\n\t      if (!bidiRE.test(str)) return false;\n\t      var len = str.length, types = [];\n\t      for (var i = 0, type; i < len; ++i)\n\t        types.push(type = charType(str.charCodeAt(i)));\n\t\n\t      // W1. Examine each non-spacing mark (NSM) in the level run, and\n\t      // change the type of the NSM to the type of the previous\n\t      // character. If the NSM is at the start of the level run, it will\n\t      // get the type of sor.\n\t      for (var i = 0, prev = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"m\") types[i] = prev;\n\t        else prev = type;\n\t      }\n\t\n\t      // W2. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, AL, or sor) is found. If an\n\t      // AL is found, change the type of the European number to Arabic\n\t      // number.\n\t      // W3. Change all ALs to R.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n\t        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n\t      }\n\t\n\t      // W4. A single European separator between two European numbers\n\t      // changes to a European number. A single common separator between\n\t      // two numbers of the same type changes to that type.\n\t      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n\t        var type = types[i];\n\t        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n\t        else if (type == \",\" && prev == types[i+1] &&\n\t                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n\t        prev = type;\n\t      }\n\t\n\t      // W5. A sequence of European terminators adjacent to European\n\t      // numbers changes to all European numbers.\n\t      // W6. Otherwise, separators and terminators change to Other\n\t      // Neutral.\n\t      for (var i = 0; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \",\") types[i] = \"N\";\n\t        else if (type == \"%\") {\n\t          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n\t          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // W7. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, or sor) is found. If an L is\n\t      // found, then change the type of the European number to L.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n\t        else if (isStrong.test(type)) cur = type;\n\t      }\n\t\n\t      // N1. A sequence of neutrals takes the direction of the\n\t      // surrounding strong text if the text on both sides has the same\n\t      // direction. European and Arabic numbers act as if they were R in\n\t      // terms of their influence on neutrals. Start-of-level-run (sor)\n\t      // and end-of-level-run (eor) are used at level run boundaries.\n\t      // N2. Any remaining neutrals take the embedding direction.\n\t      for (var i = 0; i < len; ++i) {\n\t        if (isNeutral.test(types[i])) {\n\t          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n\t          var before = (i ? types[i-1] : outerType) == \"L\";\n\t          var after = (end < len ? types[end] : outerType) == \"L\";\n\t          var replace = before || after ? \"L\" : \"R\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // Here we depart from the documented algorithm, in order to avoid\n\t      // building up an actual levels array. Since there are only three\n\t      // levels (0, 1, 2) in an implementation that doesn't take\n\t      // explicit embedding into account, we can build up the order on\n\t      // the fly, without following the level-based algorithm.\n\t      var order = [], m;\n\t      for (var i = 0; i < len;) {\n\t        if (countsAsLeft.test(types[i])) {\n\t          var start = i;\n\t          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n\t          order.push({from: start, to: i, level: 0});\n\t        } else {\n\t          var pos = i, at = order.length;\n\t          for (++i; i < len && types[i] != \"L\"; ++i) {}\n\t          for (var j = pos; j < i;) {\n\t            if (countsAsNum.test(types[j])) {\n\t              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});\n\t              var nstart = j;\n\t              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n\t              order.splice(at, 0, {from: nstart, to: j, level: 2});\n\t              pos = j;\n\t            } else ++j;\n\t          }\n\t          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});\n\t        }\n\t      }\n\t      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n\t        order[0].from = m[0].length;\n\t        order.unshift({from: 0, to: m[0].length, level: 0});\n\t      }\n\t      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n\t        lst(order).to -= m[0].length;\n\t        order.push({from: len - m[0].length, to: len, level: 0});\n\t      }\n\t      if (order[0].level != lst(order).level)\n\t        order.push({from: len, to: len, level: order[0].level});\n\t\n\t      return order;\n\t    };\n\t  })();\n\t\n\t  // THE END\n\t\n\t  CodeMirror.version = \"3.22.0\";\n\t\n\t  return CodeMirror;\n\t})();\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, require) {\n\n\t// TODO actually recognize syntax of TypeScript constructs\n\t\n\tCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n\t  var indentUnit = config.indentUnit;\n\t  var statementIndent = parserConfig.statementIndent;\n\t  var jsonldMode = parserConfig.jsonld;\n\t  var jsonMode = parserConfig.json || jsonldMode;\n\t  var isTS = parserConfig.typescript;\n\t\n\t  // Tokenizer\n\t\n\t  var keywords = function(){\n\t    function kw(type) {return {type: type, style: \"keyword\"};}\n\t    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n\t    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\t\n\t    var jsKeywords = {\n\t      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n\t      \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"delete\": C, \"throw\": C, \"debugger\": C,\n\t      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n\t      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n\t      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n\t      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n\t      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n\t      \"this\": kw(\"this\"), \"module\": kw(\"module\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n\t      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C\n\t    };\n\t\n\t    // Extend the 'normal' keywords with the TypeScript language extensions\n\t    if (isTS) {\n\t      var type = {type: \"variable\", style: \"variable-3\"};\n\t      var tsKeywords = {\n\t        // object-like things\n\t        \"interface\": kw(\"interface\"),\n\t        \"extends\": kw(\"extends\"),\n\t        \"constructor\": kw(\"constructor\"),\n\t\n\t        // scope modifiers\n\t        \"public\": kw(\"public\"),\n\t        \"private\": kw(\"private\"),\n\t        \"protected\": kw(\"protected\"),\n\t        \"static\": kw(\"static\"),\n\t\n\t        // types\n\t        \"string\": type, \"number\": type, \"bool\": type, \"any\": type\n\t      };\n\t\n\t      for (var attr in tsKeywords) {\n\t        jsKeywords[attr] = tsKeywords[attr];\n\t      }\n\t    }\n\t\n\t    return jsKeywords;\n\t  }();\n\t\n\t  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n\t  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\t\n\t  function readRegexp(stream) {\n\t    var escaped = false, next, inSet = false;\n\t    while ((next = stream.next()) != null) {\n\t      if (!escaped) {\n\t        if (next == \"/\" && !inSet) return;\n\t        if (next == \"[\") inSet = true;\n\t        else if (inSet && next == \"]\") inSet = false;\n\t      }\n\t      escaped = !escaped && next == \"\\\\\";\n\t    }\n\t  }\n\t\n\t  // Used as scratch variables to communicate multiple values without\n\t  // consing up tons of objects.\n\t  var type, content;\n\t  function ret(tp, style, cont) {\n\t    type = tp; content = cont;\n\t    return style;\n\t  }\n\t  function tokenBase(stream, state) {\n\t    var ch = stream.next();\n\t    if (ch == '\"' || ch == \"'\") {\n\t      state.tokenize = tokenString(ch);\n\t      return state.tokenize(stream, state);\n\t    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n\t      return ret(\"number\", \"number\");\n\t    } else if (ch == \".\" && stream.match(\"..\")) {\n\t      return ret(\"spread\", \"meta\");\n\t    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n\t      return ret(ch);\n\t    } else if (ch == \"=\" && stream.eat(\">\")) {\n\t      return ret(\"=>\", \"operator\");\n\t    } else if (ch == \"0\" && stream.eat(/x/i)) {\n\t      stream.eatWhile(/[\\da-f]/i);\n\t      return ret(\"number\", \"number\");\n\t    } else if (/\\d/.test(ch)) {\n\t      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n\t      return ret(\"number\", \"number\");\n\t    } else if (ch == \"/\") {\n\t      if (stream.eat(\"*\")) {\n\t        state.tokenize = tokenComment;\n\t        return tokenComment(stream, state);\n\t      } else if (stream.eat(\"/\")) {\n\t        stream.skipToEnd();\n\t        return ret(\"comment\", \"comment\");\n\t      } else if (state.lastType == \"operator\" || state.lastType == \"keyword c\" ||\n\t               state.lastType == \"sof\" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n\t        readRegexp(stream);\n\t        stream.eatWhile(/[gimy]/); // 'y' is \"sticky\" option in Mozilla\n\t        return ret(\"regexp\", \"string-2\");\n\t      } else {\n\t        stream.eatWhile(isOperatorChar);\n\t        return ret(\"operator\", \"operator\", stream.current());\n\t      }\n\t    } else if (ch == \"`\") {\n\t      state.tokenize = tokenQuasi;\n\t      return tokenQuasi(stream, state);\n\t    } else if (ch == \"#\") {\n\t      stream.skipToEnd();\n\t      return ret(\"error\", \"error\");\n\t    } else if (isOperatorChar.test(ch)) {\n\t      stream.eatWhile(isOperatorChar);\n\t      return ret(\"operator\", \"operator\", stream.current());\n\t    } else {\n\t      stream.eatWhile(/[\\w\\$_]/);\n\t      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n\t      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n\t                     ret(\"variable\", \"variable\", word);\n\t    }\n\t  }\n\t\n\t  function tokenString(quote) {\n\t    return function(stream, state) {\n\t      var escaped = false, next;\n\t      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n\t        state.tokenize = tokenBase;\n\t        return ret(\"jsonld-keyword\", \"meta\");\n\t      }\n\t      while ((next = stream.next()) != null) {\n\t        if (next == quote && !escaped) break;\n\t        escaped = !escaped && next == \"\\\\\";\n\t      }\n\t      if (!escaped) state.tokenize = tokenBase;\n\t      return ret(\"string\", \"string\");\n\t    };\n\t  }\n\t\n\t  function tokenComment(stream, state) {\n\t    var maybeEnd = false, ch;\n\t    while (ch = stream.next()) {\n\t      if (ch == \"/\" && maybeEnd) {\n\t        state.tokenize = tokenBase;\n\t        break;\n\t      }\n\t      maybeEnd = (ch == \"*\");\n\t    }\n\t    return ret(\"comment\", \"comment\");\n\t  }\n\t\n\t  function tokenQuasi(stream, state) {\n\t    var escaped = false, next;\n\t    while ((next = stream.next()) != null) {\n\t      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n\t        state.tokenize = tokenBase;\n\t        break;\n\t      }\n\t      escaped = !escaped && next == \"\\\\\";\n\t    }\n\t    return ret(\"quasi\", \"string-2\", stream.current());\n\t  }\n\t\n\t  var brackets = \"([{}])\";\n\t  // This is a crude lookahead trick to try and notice that we're\n\t  // parsing the argument patterns for a fat-arrow function before we\n\t  // actually hit the arrow token. It only works if the arrow is on\n\t  // the same line as the arguments and there's no strange noise\n\t  // (comments) in between. Fallback is to only notice when we hit the\n\t  // arrow, and not declare the arguments as locals for the arrow\n\t  // body.\n\t  function findFatArrow(stream, state) {\n\t    if (state.fatArrowAt) state.fatArrowAt = null;\n\t    var arrow = stream.string.indexOf(\"=>\", stream.start);\n\t    if (arrow < 0) return;\n\t\n\t    var depth = 0, sawSomething = false;\n\t    for (var pos = arrow - 1; pos >= 0; --pos) {\n\t      var ch = stream.string.charAt(pos);\n\t      var bracket = brackets.indexOf(ch);\n\t      if (bracket >= 0 && bracket < 3) {\n\t        if (!depth) { ++pos; break; }\n\t        if (--depth == 0) break;\n\t      } else if (bracket >= 3 && bracket < 6) {\n\t        ++depth;\n\t      } else if (/[$\\w]/.test(ch)) {\n\t        sawSomething = true;\n\t      } else if (sawSomething && !depth) {\n\t        ++pos;\n\t        break;\n\t      }\n\t    }\n\t    if (sawSomething && !depth) state.fatArrowAt = pos;\n\t  }\n\t\n\t  // Parser\n\t\n\t  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\t\n\t  function JSLexical(indented, column, type, align, prev, info) {\n\t    this.indented = indented;\n\t    this.column = column;\n\t    this.type = type;\n\t    this.prev = prev;\n\t    this.info = info;\n\t    if (align != null) this.align = align;\n\t  }\n\t\n\t  function inScope(state, varname) {\n\t    for (var v = state.localVars; v; v = v.next)\n\t      if (v.name == varname) return true;\n\t    for (var cx = state.context; cx; cx = cx.prev) {\n\t      for (var v = cx.vars; v; v = v.next)\n\t        if (v.name == varname) return true;\n\t    }\n\t  }\n\t\n\t  function parseJS(state, style, type, content, stream) {\n\t    var cc = state.cc;\n\t    // Communicate our context to the combinators.\n\t    // (Less wasteful than consing up a hundred closures on every call.)\n\t    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\t\n\t    if (!state.lexical.hasOwnProperty(\"align\"))\n\t      state.lexical.align = true;\n\t\n\t    while(true) {\n\t      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n\t      if (combinator(type, content)) {\n\t        while(cc.length && cc[cc.length - 1].lex)\n\t          cc.pop()();\n\t        if (cx.marked) return cx.marked;\n\t        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n\t        return style;\n\t      }\n\t    }\n\t  }\n\t\n\t  // Combinator utils\n\t\n\t  var cx = {state: null, column: null, marked: null, cc: null};\n\t  function pass() {\n\t    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n\t  }\n\t  function cont() {\n\t    pass.apply(null, arguments);\n\t    return true;\n\t  }\n\t  function register(varname) {\n\t    function inList(list) {\n\t      for (var v = list; v; v = v.next)\n\t        if (v.name == varname) return true;\n\t      return false;\n\t    }\n\t    var state = cx.state;\n\t    if (state.context) {\n\t      cx.marked = \"def\";\n\t      if (inList(state.localVars)) return;\n\t      state.localVars = {name: varname, next: state.localVars};\n\t    } else {\n\t      if (inList(state.globalVars)) return;\n\t      if (parserConfig.globalVars)\n\t        state.globalVars = {name: varname, next: state.globalVars};\n\t    }\n\t  }\n\t\n\t  // Combinators\n\t\n\t  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n\t  function pushcontext() {\n\t    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n\t    cx.state.localVars = defaultVars;\n\t  }\n\t  function popcontext() {\n\t    cx.state.localVars = cx.state.context.vars;\n\t    cx.state.context = cx.state.context.prev;\n\t  }\n\t  function pushlex(type, info) {\n\t    var result = function() {\n\t      var state = cx.state, indent = state.indented;\n\t      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n\t      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n\t    };\n\t    result.lex = true;\n\t    return result;\n\t  }\n\t  function poplex() {\n\t    var state = cx.state;\n\t    if (state.lexical.prev) {\n\t      if (state.lexical.type == \")\")\n\t        state.indented = state.lexical.indented;\n\t      state.lexical = state.lexical.prev;\n\t    }\n\t  }\n\t  poplex.lex = true;\n\t\n\t  function expect(wanted) {\n\t    return function(type) {\n\t      if (type == wanted) return cont();\n\t      else if (wanted == \";\") return pass();\n\t      else return cont(arguments.callee);\n\t    };\n\t  }\n\t\n\t  function statement(type, value) {\n\t    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n\t    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n\t    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n\t    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n\t    if (type == \";\") return cont();\n\t    if (type == \"if\") return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse);\n\t    if (type == \"function\") return cont(functiondef);\n\t    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n\t    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n\t    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n\t                                      block, poplex, poplex);\n\t    if (type == \"case\") return cont(expression, expect(\":\"));\n\t    if (type == \"default\") return cont(expect(\":\"));\n\t    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n\t                                     statement, poplex, popcontext);\n\t    if (type == \"module\") return cont(pushlex(\"form\"), pushcontext, afterModule, popcontext, poplex);\n\t    if (type == \"class\") return cont(pushlex(\"form\"), className, objlit, poplex);\n\t    if (type == \"export\") return cont(pushlex(\"form\"), afterExport, poplex);\n\t    if (type == \"import\") return cont(pushlex(\"form\"), afterImport, poplex);\n\t    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n\t  }\n\t  function expression(type) {\n\t    return expressionInner(type, false);\n\t  }\n\t  function expressionNoComma(type) {\n\t    return expressionInner(type, true);\n\t  }\n\t  function expressionInner(type, noComma) {\n\t    if (cx.state.fatArrowAt == cx.stream.start) {\n\t      var body = noComma ? arrowBodyNoComma : arrowBody;\n\t      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\n\t      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n\t    }\n\t\n\t    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n\t    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n\t    if (type == \"function\") return cont(functiondef);\n\t    if (type == \"keyword c\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n\t    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, comprehension, expect(\")\"), poplex, maybeop);\n\t    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n\t    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n\t    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n\t    return cont();\n\t  }\n\t  function maybeexpression(type) {\n\t    if (type.match(/[;\\}\\)\\],]/)) return pass();\n\t    return pass(expression);\n\t  }\n\t  function maybeexpressionNoComma(type) {\n\t    if (type.match(/[;\\}\\)\\],]/)) return pass();\n\t    return pass(expressionNoComma);\n\t  }\n\t\n\t  function maybeoperatorComma(type, value) {\n\t    if (type == \",\") return cont(expression);\n\t    return maybeoperatorNoComma(type, value, false);\n\t  }\n\t  function maybeoperatorNoComma(type, value, noComma) {\n\t    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n\t    var expr = noComma == false ? expression : expressionNoComma;\n\t    if (value == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n\t    if (type == \"operator\") {\n\t      if (/\\+\\+|--/.test(value)) return cont(me);\n\t      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n\t      return cont(expr);\n\t    }\n\t    if (type == \"quasi\") { cx.cc.push(me); return quasi(value); }\n\t    if (type == \";\") return;\n\t    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n\t    if (type == \".\") return cont(property, me);\n\t    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n\t  }\n\t  function quasi(value) {\n\t    if (value.slice(value.length - 2) != \"${\") return cont();\n\t    return cont(expression, continueQuasi);\n\t  }\n\t  function continueQuasi(type) {\n\t    if (type == \"}\") {\n\t      cx.marked = \"string-2\";\n\t      cx.state.tokenize = tokenQuasi;\n\t      return cont();\n\t    }\n\t  }\n\t  function arrowBody(type) {\n\t    findFatArrow(cx.stream, cx.state);\n\t    if (type == \"{\") return pass(statement);\n\t    return pass(expression);\n\t  }\n\t  function arrowBodyNoComma(type) {\n\t    findFatArrow(cx.stream, cx.state);\n\t    if (type == \"{\") return pass(statement);\n\t    return pass(expressionNoComma);\n\t  }\n\t  function maybelabel(type) {\n\t    if (type == \":\") return cont(poplex, statement);\n\t    return pass(maybeoperatorComma, expect(\";\"), poplex);\n\t  }\n\t  function property(type) {\n\t    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n\t  }\n\t  function objprop(type, value) {\n\t    if (type == \"variable\") {\n\t      cx.marked = \"property\";\n\t      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n\t    } else if (type == \"number\" || type == \"string\") {\n\t      cx.marked = jsonldMode ? \"property\" : (type + \" property\");\n\t    } else if (type == \"[\") {\n\t      return cont(expression, expect(\"]\"), afterprop);\n\t    }\n\t    if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);\n\t  }\n\t  function getterSetter(type) {\n\t    if (type != \"variable\") return pass(afterprop);\n\t    cx.marked = \"property\";\n\t    return cont(functiondef);\n\t  }\n\t  function afterprop(type) {\n\t    if (type == \":\") return cont(expressionNoComma);\n\t    if (type == \"(\") return pass(functiondef);\n\t  }\n\t  function commasep(what, end) {\n\t    function proceed(type) {\n\t      if (type == \",\") {\n\t        var lex = cx.state.lexical;\n\t        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n\t        return cont(what, proceed);\n\t      }\n\t      if (type == end) return cont();\n\t      return cont(expect(end));\n\t    }\n\t    return function(type) {\n\t      if (type == end) return cont();\n\t      return pass(what, proceed);\n\t    };\n\t  }\n\t  function contCommasep(what, end, info) {\n\t    for (var i = 3; i < arguments.length; i++)\n\t      cx.cc.push(arguments[i]);\n\t    return cont(pushlex(end, info), commasep(what, end), poplex);\n\t  }\n\t  function block(type) {\n\t    if (type == \"}\") return cont();\n\t    return pass(statement, block);\n\t  }\n\t  function maybetype(type) {\n\t    if (isTS && type == \":\") return cont(typedef);\n\t  }\n\t  function typedef(type) {\n\t    if (type == \"variable\"){cx.marked = \"variable-3\"; return cont();}\n\t  }\n\t  function vardef() {\n\t    return pass(pattern, maybetype, maybeAssign, vardefCont);\n\t  }\n\t  function pattern(type, value) {\n\t    if (type == \"variable\") { register(value); return cont(); }\n\t    if (type == \"[\") return contCommasep(pattern, \"]\");\n\t    if (type == \"{\") return contCommasep(proppattern, \"}\");\n\t  }\n\t  function proppattern(type, value) {\n\t    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n\t      register(value);\n\t      return cont(maybeAssign);\n\t    }\n\t    if (type == \"variable\") cx.marked = \"property\";\n\t    return cont(expect(\":\"), pattern, maybeAssign);\n\t  }\n\t  function maybeAssign(_type, value) {\n\t    if (value == \"=\") return cont(expressionNoComma);\n\t  }\n\t  function vardefCont(type) {\n\t    if (type == \",\") return cont(vardef);\n\t  }\n\t  function maybeelse(type, value) {\n\t    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\"), statement, poplex);\n\t  }\n\t  function forspec(type) {\n\t    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n\t  }\n\t  function forspec1(type) {\n\t    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n\t    if (type == \";\") return cont(forspec2);\n\t    if (type == \"variable\") return cont(formaybeinof);\n\t    return pass(expression, expect(\";\"), forspec2);\n\t  }\n\t  function formaybeinof(_type, value) {\n\t    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n\t    return cont(maybeoperatorComma, forspec2);\n\t  }\n\t  function forspec2(type, value) {\n\t    if (type == \";\") return cont(forspec3);\n\t    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n\t    return pass(expression, expect(\";\"), forspec3);\n\t  }\n\t  function forspec3(type) {\n\t    if (type != \")\") cont(expression);\n\t  }\n\t  function functiondef(type, value) {\n\t    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n\t    if (type == \"variable\") {register(value); return cont(functiondef);}\n\t    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, statement, popcontext);\n\t  }\n\t  function funarg(type) {\n\t    if (type == \"spread\") return cont(funarg);\n\t    return pass(pattern, maybetype);\n\t  }\n\t  function className(type, value) {\n\t    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n\t  }\n\t  function classNameAfter(_type, value) {\n\t    if (value == \"extends\") return cont(expression);\n\t  }\n\t  function objlit(type) {\n\t    if (type == \"{\") return contCommasep(objprop, \"}\");\n\t  }\n\t  function afterModule(type, value) {\n\t    if (type == \"string\") return cont(statement);\n\t    if (type == \"variable\") { register(value); return cont(maybeFrom); }\n\t  }\n\t  function afterExport(_type, value) {\n\t    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n\t    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n\t    return pass(statement);\n\t  }\n\t  function afterImport(type) {\n\t    if (type == \"string\") return cont();\n\t    return pass(importSpec, maybeFrom);\n\t  }\n\t  function importSpec(type, value) {\n\t    if (type == \"{\") return contCommasep(importSpec, \"}\");\n\t    if (type == \"variable\") register(value);\n\t    return cont();\n\t  }\n\t  function maybeFrom(_type, value) {\n\t    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n\t  }\n\t  function arrayLiteral(type) {\n\t    if (type == \"]\") return cont();\n\t    return pass(expressionNoComma, maybeArrayComprehension);\n\t  }\n\t  function maybeArrayComprehension(type) {\n\t    if (type == \"for\") return pass(comprehension, expect(\"]\"));\n\t    if (type == \",\") return cont(commasep(expressionNoComma, \"]\"));\n\t    return pass(commasep(expressionNoComma, \"]\"));\n\t  }\n\t  function comprehension(type) {\n\t    if (type == \"for\") return cont(forspec, comprehension);\n\t    if (type == \"if\") return cont(expression, comprehension);\n\t  }\n\t\n\t  // Interface\n\t\n\t  return {\n\t    startState: function(basecolumn) {\n\t      var state = {\n\t        tokenize: tokenBase,\n\t        lastType: \"sof\",\n\t        cc: [],\n\t        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n\t        localVars: parserConfig.localVars,\n\t        context: parserConfig.localVars && {vars: parserConfig.localVars},\n\t        indented: 0\n\t      };\n\t      if (parserConfig.globalVars) state.globalVars = parserConfig.globalVars;\n\t      return state;\n\t    },\n\t\n\t    token: function(stream, state) {\n\t      if (stream.sol()) {\n\t        if (!state.lexical.hasOwnProperty(\"align\"))\n\t          state.lexical.align = false;\n\t        state.indented = stream.indentation();\n\t        findFatArrow(stream, state);\n\t      }\n\t      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n\t      var style = state.tokenize(stream, state);\n\t      if (type == \"comment\") return style;\n\t      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n\t      return parseJS(state, style, type, content, stream);\n\t    },\n\t\n\t    indent: function(state, textAfter) {\n\t      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n\t      if (state.tokenize != tokenBase) return 0;\n\t      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n\t      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n\t      for (var i = state.cc.length - 1; i >= 0; --i) {\n\t        var c = state.cc[i];\n\t        if (c == poplex) lexical = lexical.prev;\n\t        else if (c != maybeelse) break;\n\t      }\n\t      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n\t      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n\t        lexical = lexical.prev;\n\t      var type = lexical.type, closing = firstChar == type;\n\t\n\t      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n\t      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n\t      else if (type == \"form\") return lexical.indented + indentUnit;\n\t      else if (type == \"stat\")\n\t        return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? statementIndent || indentUnit : 0);\n\t      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n\t        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n\t      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n\t      else return lexical.indented + (closing ? 0 : indentUnit);\n\t    },\n\t\n\t    electricChars: \":{}\",\n\t    blockCommentStart: jsonMode ? null : \"/*\",\n\t    blockCommentEnd: jsonMode ? null : \"*/\",\n\t    lineComment: jsonMode ? null : \"//\",\n\t    fold: \"brace\",\n\t\n\t    helperType: jsonMode ? \"json\" : \"javascript\",\n\t    jsonldMode: jsonldMode,\n\t    jsonMode: jsonMode\n\t  };\n\t});\n\t\n\tCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\n\tCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\n\tCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\n\tCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\n\tCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\n\tCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports =\n\t\t\".CodeMirror-hints{position:absolute;z-index:10;overflow:hidden;list-style:none;margin:0;padding:2px;-webkit-box-shadow:2px 3px 5px rgba(0,0,0,.2);-moz-box-shadow:2px 3px 5px rgba(0,0,0,.2);box-shadow:2px 3px 5px rgba(0,0,0,.2);border-radius:3px;border:1px solid silver;background:#fff;font-size:90%;font-family:monospace;max-height:20em;overflow-y:auto}.CodeMirror-hint{margin:0;padding:0 4px;border-radius:2px;max-width:19em;overflow:hidden;white-space:pre;color:#000;cursor:pointer}.CodeMirror-hint-active{background:#08f;color:#fff}\";\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports =\n\t\t\".CodeMirror-lint-markers{width:16px}.CodeMirror-lint-tooltip{background-color:infobackground;border:1px solid #000;border-radius:4px 4px 4px 4px;color:infotext;font-family:monospace;font-size:10pt;overflow:hidden;padding:2px 5px;position:fixed;white-space:pre-wrap;z-index:100;max-width:600px;opacity:0;transition:opacity .4s;-moz-transition:opacity .4s;-webkit-transition:opacity .4s;-o-transition:opacity .4s;-ms-transition:opacity .4s}.CodeMirror-lint-mark-error,.CodeMirror-lint-mark-warning{background-position:left bottom;background-repeat:repeat-x}.CodeMirror-lint-mark-error{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==)}.CodeMirror-lint-mark-warning{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=)}.CodeMirror-lint-marker-error,.CodeMirror-lint-marker-warning{background-position:center center;background-repeat:no-repeat;cursor:pointer;display:inline-block;height:16px;width:16px;vertical-align:middle;position:relative}.CodeMirror-lint-message-error,.CodeMirror-lint-message-warning{padding-left:18px;background-position:top left;background-repeat:no-repeat}.CodeMirror-lint-marker-error,.CodeMirror-lint-message-error{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=)}.CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=)}.CodeMirror-lint-marker-multiple{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-position:right bottom;width:100%;height:100%}\";\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports =\n\t\t\".CodeMirror{font-family:monospace;height:300px}.CodeMirror-scroll{overflow:auto}.CodeMirror-lines{padding:4px 0}.CodeMirror pre{padding:0 4px}.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror div.CodeMirror-cursor{border-left:1px solid #000;z-index:3}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.CodeMirror.cm-keymap-fat-cursor div.CodeMirror-cursor{width:auto;border:0;background:#7e7;z-index:1}.cm-tab{display:inline-block}.CodeMirror-ruler{border-left:1px solid #ccc;position:absolute}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable{color:#000}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3{color:#085}.cm-s-default .cm-property,.cm-s-default .cm-operator{color:#000}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-s-default .cm-error,.cm-invalidchar{color:red}div.CodeMirror span.CodeMirror-matchingbracket{color:#0f0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#f22}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{line-height:1;position:relative;overflow:hidden;background:#fff;color:#000}.CodeMirror-scroll{margin-bottom:-30px;margin-right:-30px;padding-bottom:30px;height:100%;outline:none}.CodeMirror-scroll,.CodeMirror-sizer{position:relative;-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-sizer{border-right:30px solid transparent}.CodeMirror-vscrollbar,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{position:absolute;z-index:6;display:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;padding-bottom:30px;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;-moz-box-sizing:content-box;box-sizing:content-box;padding-bottom:30px;margin-bottom:-32px;display:inline-block;*zoom:1;*display:inline}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-lines{cursor:text}.CodeMirror pre{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:0 0;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible}.CodeMirror-wrap pre{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;overflow:auto}.CodeMirror-wrap .CodeMirror-scroll{overflow-x:hidden}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-measure pre{position:static}.CodeMirror div.CodeMirror-cursor{position:absolute;visibility:hidden;border-right:none;width:0}.CodeMirror-focused div.CodeMirror-cursor{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.cm-searching{background:#ffa;background:rgba(255,255,0,.4)}.CodeMirror span{*vertical-align:text-bottom}@media print{.CodeMirror div.CodeMirror-cursor{visibility:hidden}}\";\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports =\n\t\t\".cm-s-xq-light span.cm-keyword{line-height:1em;font-weight:700;color:#5A5CAD}.cm-s-xq-light span.cm-atom{color:#6C8CD5}.cm-s-xq-light span.cm-number{color:#164}.cm-s-xq-light span.cm-def{text-decoration:underline}.cm-s-xq-light span.cm-variable,.cm-s-xq-light span.cm-variable-2,.cm-s-xq-light span.cm-variable-3{color:#000}.cm-s-xq-light span.cm-comment{color:#0080FF;font-style:italic}.cm-s-xq-light span.cm-string{color:red}.cm-s-xq-light span.cm-meta{color:#ff0}.cm-s-xq-light span.cm-qualifier{color:grey}.cm-s-xq-light span.cm-builtin{color:#7EA656}.cm-s-xq-light span.cm-bracket{color:#cc7}.cm-s-xq-light span.cm-tag{color:#3F7F7F}.cm-s-xq-light span.cm-attribute{color:#7F007F}.cm-s-xq-light span.cm-error{color:red}.cm-s-xq-light .CodeMirror-activeline-background{background:#e8f2ff!important}.cm-s-xq-light .CodeMirror-matchingbracket{outline:1px solid grey;color:#000!important;background:#ff0}\";\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports =\n\t\trequire(25) +\n\t\trequire(26) +\n\t\t\"html,body{border:0;font-family:\\\"Helvetica-Neue\\\",\\\"Helvetica\\\",Arial,sans-serif;line-height:1.5;margin:0;padding:0}div,span,object,iframe,img,table,caption,thead,tbody,tfoot,tr,tr,td,article,aside,canvas,details,figure,hgroup,menu,nav,footer,header,section,summary,mark,audio,video{border:0;margin:0;padding:0}h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,address,cit,code,del,dfn,em,ins,q,samp,small,strong,sub,sup,b,i,hr,dl,dt,dd,ol,ul,li,fieldset,legend,label{border:0;font-size:100%;vertical-align:baseline;margin:0;padding:0}article,aside,canvas,figure,figure img,figcaption,hgroup,footer,header,nav,section,audio,video{display:block}table{border-collapse:separate;border-spacing:0}table caption,table th,table td{text-align:left;vertical-align:middle}a img{border:0}:focus{outline:0}*,*:before,*:after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}body{color:#222;margin:0;padding:0;border:0;font-family:\\\"Helvetica Neue LT Std\\\";font-size:48pt;line-height:1.2em;visibility:visible}p,a,li,li:before,h1,h2,h3,h4,h5,h6{text-shadow:0 0 .1em rgba(0,0,0,.5)}h1,h2,h3,h4,h5,h6{text-align:center;font-weight:700;background-color:rgba(0,0,0,.1);margin:.4em -100%}h1{font-size:1.6em;padding-top:.25em}h2{font-size:1.4em;padding-top:.3em}h3{font-size:1.2em;padding-top:.3em}h4,h5,h6{font-size:1.1em;padding-top:.3em}ul li,ol li{list-style:none;position:relative}ul li:before,ol li:before{color:#888;text-align:right;position:absolute;left:0}ul li:before{content:' ';width:1em;height:1em;margin-left:-1em;background:url(\"+require(40)+\");background-size:contain}strong{letter-spacing:.05em}#slides{z-index:1;position:fixed;background:#ccc}#slides,#slides .background{background-size:cover;width:100%;height:100%;margin:0;padding:0;border:0}#slides .background{z-index:2;position:absolute;opacity:0;-webkit-transition:opacity .3s ease;-moz-transition:opacity .3s ease;transition:opacity .3s ease}#slides .background.active{opacity:1}#slides section{z-index:10;background:rgba(255,255,255,.8);background-size:cover;visibility:hidden;position:absolute;width:80%;height:80%;left:10%;top:10%;margin:0;padding:0 10%;border:0;border-radius:.2em;display:-webkit-box;display:-moz-box;display:box;-webkit-box-pack:center;-webkit-box-align:center;-moz-box-pack:center;-moz-box-align:center;box-pack:center;box-align:center;opacity:0;-webkit-transform:scale(1.25);-webkit-filter:grayscale(100%);-webkit-transition:-webkit-filter .3s ease,-webkit-transform .3s ease,opacity .3s ease;-moz-transform:scale(1.25);-moz-filter:grayscale(100%);-moz-transition:-moz-filter .3s ease,-moz-transform .3s ease,opacity .3s ease;transform:scale(1.25);filter:grayscale(100%);transition:filter .3s ease,transform .3s ease,opacity .3s ease}#slides section .slideContainer{width:100%}#slides section.current,#slides section.out{visibility:visible}#slides section.current{opacity:1;-webkit-filter:grayscale(0);-webkit-transform:scale(1);-moz-filter:grayscale(0);-moz-transform:scale(1);filter:grayscale(0);transform:scale(1)}#slides section.out{-webkit-transform:scale(.75);-moz-transform:scale(.75);transform:scale(.75)}#slides section.editor{left:0;top:0;width:100%;height:100%;border-radius:0;background:0 0}#slides section.editor .editorFrame,#slides section.editor .targetFrame{position:absolute;width:50%;height:100%;top:0;padding:.5em}#slides section.editor .editorFrame{left:0;padding-right:0}#slides section.editor .targetFrame{left:50%}#slides section.editor .targetFrame iframe{z-index:14;background:#444;width:100%;height:100%;margin:0;padding:0}#slides section.editor .loaderFrame{z-index:15;background:#444;width:100%;height:100%;margin:0;padding:0}#slides section.editor .CodeMirror{font-family:\\\"Inconsolata\\\";line-height:1.2em;font-size:.5em}#slides section.editor .CodeMirror,#slides section.editor .loaderFrame,#slides section.editor .targetFrame iframe{box-shadow:0 .1em .2em rgba(0,0,0,.6);border-radius:.1em}.CodeMirror-hints,.CodeMirror-hints li{font-family:\\\"Inconsolata\\\";line-height:1.2em;font-size:.5em;text-shadow:none}\";\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports =\n\t\t\"@font-face{font-family:'Helvetica Neue LT Std';font-style:normal;font-weight:400;src:local('Helvetica Neue LT Std Regular'),url(\"+require(36)+\") format('opentype')}@font-face{font-family:'Helvetica Neue LT Std';font-style:normal;font-weight:700;src:local('Helvetica Neue LT Std Bold'),url(\"+require(34)+\") format('opentype')}@font-face{font-family:'Helvetica Neue LT Std';font-style:italic;font-weight:400;src:local('Helvetica Neue LT Std Regular Italic'),url(\"+require(37)+\") format('opentype')}@font-face{font-family:'Helvetica Neue LT Std';font-style:italic;font-weight:700;src:local('Helvetica Neue LT Std Bold Italic'),url(\"+require(35)+\") format('opentype')}\";\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports =\n\t\t\"@font-face{font-family:'Inconsolata';font-style:normal;font-weight:400;src:local('Inconsolata'),url(\"+require(39)+\") format('truetype')}@font-face{font-family:'Inconsolata';font-style:normal;font-weight:700;src:local('Inconsolata Bold'),local('Inconsolata-Bold'),url(\"+require(38)+\") format('truetype')}\";\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, require) {\n\n\t//fgnass.github.com/spin.js#v1.3.2\n\t\n\t/**\n\t * Copyright (c) 2011-2013 Felix Gnass\n\t * Licensed under the MIT license\n\t */\n\t(function(root, factory) {\n\t\n\t  /* CommonJS */\n\t  if (true)  module.exports = factory()\n\t\n\t  /* AMD module */\n\t  else if (typeof define == 'function' && define.amd) define(factory)\n\t\n\t  /* Browser global */\n\t  else root.Spinner = factory()\n\t}\n\t(this, function() {\n\t  \"use strict\";\n\t\n\t  var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */\n\t    , animations = {} /* Animation rules keyed by their name */\n\t    , useCssAnimations /* Whether to use CSS animations or setTimeout */\n\t\n\t  /**\n\t   * Utility function to create elements. If no tag name is given,\n\t   * a DIV is created. Optionally properties can be passed.\n\t   */\n\t  function createEl(tag, prop) {\n\t    var el = document.createElement(tag || 'div')\n\t      , n\n\t\n\t    for(n in prop) el[n] = prop[n]\n\t    return el\n\t  }\n\t\n\t  /**\n\t   * Appends children and returns the parent.\n\t   */\n\t  function ins(parent /* child1, child2, ...*/) {\n\t    for (var i=1, n=arguments.length; i<n; i++)\n\t      parent.appendChild(arguments[i])\n\t\n\t    return parent\n\t  }\n\t\n\t  /**\n\t   * Insert a new stylesheet to hold the @keyframe or VML rules.\n\t   */\n\t  var sheet = (function() {\n\t    var el = createEl('style', {type : 'text/css'})\n\t    ins(document.getElementsByTagName('head')[0], el)\n\t    return el.sheet || el.styleSheet\n\t  }())\n\t\n\t  /**\n\t   * Creates an opacity keyframe animation rule and returns its name.\n\t   * Since most mobile Webkits have timing issues with animation-delay,\n\t   * we create separate rules for each line/segment.\n\t   */\n\t  function addAnimation(alpha, trail, i, lines) {\n\t    var name = ['opacity', trail, ~~(alpha*100), i, lines].join('-')\n\t      , start = 0.01 + i/lines * 100\n\t      , z = Math.max(1 - (1-alpha) / trail * (100-start), alpha)\n\t      , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()\n\t      , pre = prefix && '-' + prefix + '-' || ''\n\t\n\t    if (!animations[name]) {\n\t      sheet.insertRule(\n\t        '@' + pre + 'keyframes ' + name + '{' +\n\t        '0%{opacity:' + z + '}' +\n\t        start + '%{opacity:' + alpha + '}' +\n\t        (start+0.01) + '%{opacity:1}' +\n\t        (start+trail) % 100 + '%{opacity:' + alpha + '}' +\n\t        '100%{opacity:' + z + '}' +\n\t        '}', sheet.cssRules.length)\n\t\n\t      animations[name] = 1\n\t    }\n\t\n\t    return name\n\t  }\n\t\n\t  /**\n\t   * Tries various vendor prefixes and returns the first supported property.\n\t   */\n\t  function vendor(el, prop) {\n\t    var s = el.style\n\t      , pp\n\t      , i\n\t\n\t    prop = prop.charAt(0).toUpperCase() + prop.slice(1)\n\t    for(i=0; i<prefixes.length; i++) {\n\t      pp = prefixes[i]+prop\n\t      if(s[pp] !== undefined) return pp\n\t    }\n\t    if(s[prop] !== undefined) return prop\n\t  }\n\t\n\t  /**\n\t   * Sets multiple style properties at once.\n\t   */\n\t  function css(el, prop) {\n\t    for (var n in prop)\n\t      el.style[vendor(el, n)||n] = prop[n]\n\t\n\t    return el\n\t  }\n\t\n\t  /**\n\t   * Fills in default values.\n\t   */\n\t  function merge(obj) {\n\t    for (var i=1; i < arguments.length; i++) {\n\t      var def = arguments[i]\n\t      for (var n in def)\n\t        if (obj[n] === undefined) obj[n] = def[n]\n\t    }\n\t    return obj\n\t  }\n\t\n\t  /**\n\t   * Returns the absolute page-offset of the given element.\n\t   */\n\t  function pos(el) {\n\t    var o = { x:el.offsetLeft, y:el.offsetTop }\n\t    while((el = el.offsetParent))\n\t      o.x+=el.offsetLeft, o.y+=el.offsetTop\n\t\n\t    return o\n\t  }\n\t\n\t  /**\n\t   * Returns the line color from the given string or array.\n\t   */\n\t  function getColor(color, idx) {\n\t    return typeof color == 'string' ? color : color[idx % color.length]\n\t  }\n\t\n\t  // Built-in defaults\n\t\n\t  var defaults = {\n\t    lines: 12,            // The number of lines to draw\n\t    length: 7,            // The length of each line\n\t    width: 5,             // The line thickness\n\t    radius: 10,           // The radius of the inner circle\n\t    rotate: 0,            // Rotation offset\n\t    corners: 1,           // Roundness (0..1)\n\t    color: '#000',        // #rgb or #rrggbb\n\t    direction: 1,         // 1: clockwise, -1: counterclockwise\n\t    speed: 1,             // Rounds per second\n\t    trail: 100,           // Afterglow percentage\n\t    opacity: 1/4,         // Opacity of the lines\n\t    fps: 20,              // Frames per second when using setTimeout()\n\t    zIndex: 2e9,          // Use a high z-index by default\n\t    className: 'spinner', // CSS class to assign to the element\n\t    top: 'auto',          // center vertically\n\t    left: 'auto',         // center horizontally\n\t    position: 'relative'  // element position\n\t  }\n\t\n\t  /** The constructor */\n\t  function Spinner(o) {\n\t    if (typeof this == 'undefined') return new Spinner(o)\n\t    this.opts = merge(o || {}, Spinner.defaults, defaults)\n\t  }\n\t\n\t  // Global defaults that override the built-ins:\n\t  Spinner.defaults = {}\n\t\n\t  merge(Spinner.prototype, {\n\t\n\t    /**\n\t     * Adds the spinner to the given target element. If this instance is already\n\t     * spinning, it is automatically removed from its previous target b calling\n\t     * stop() internally.\n\t     */\n\t    spin: function(target) {\n\t      this.stop()\n\t\n\t      var self = this\n\t        , o = self.opts\n\t        , el = self.el = css(createEl(0, {className: o.className}), {position: o.position, width: 0, zIndex: o.zIndex})\n\t        , mid = o.radius+o.length+o.width\n\t        , ep // element position\n\t        , tp // target position\n\t\n\t      if (target) {\n\t        target.insertBefore(el, target.firstChild||null)\n\t        tp = pos(target)\n\t        ep = pos(el)\n\t        css(el, {\n\t          left: (o.left == 'auto' ? tp.x-ep.x + (target.offsetWidth >> 1) : parseInt(o.left, 10) + mid) + 'px',\n\t          top: (o.top == 'auto' ? tp.y-ep.y + (target.offsetHeight >> 1) : parseInt(o.top, 10) + mid)  + 'px'\n\t        })\n\t      }\n\t\n\t      el.setAttribute('role', 'progressbar')\n\t      self.lines(el, self.opts)\n\t\n\t      if (!useCssAnimations) {\n\t        // No CSS animation support, use setTimeout() instead\n\t        var i = 0\n\t          , start = (o.lines - 1) * (1 - o.direction) / 2\n\t          , alpha\n\t          , fps = o.fps\n\t          , f = fps/o.speed\n\t          , ostep = (1-o.opacity) / (f*o.trail / 100)\n\t          , astep = f/o.lines\n\t\n\t        ;(function anim() {\n\t          i++;\n\t          for (var j = 0; j < o.lines; j++) {\n\t            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity)\n\t\n\t            self.opacity(el, j * o.direction + start, alpha, o)\n\t          }\n\t          self.timeout = self.el && setTimeout(anim, ~~(1000/fps))\n\t        })()\n\t      }\n\t      return self\n\t    },\n\t\n\t    /**\n\t     * Stops and removes the Spinner.\n\t     */\n\t    stop: function() {\n\t      var el = this.el\n\t      if (el) {\n\t        clearTimeout(this.timeout)\n\t        if (el.parentNode) el.parentNode.removeChild(el)\n\t        this.el = undefined\n\t      }\n\t      return this\n\t    },\n\t\n\t    /**\n\t     * Internal method that draws the individual lines. Will be overwritten\n\t     * in VML fallback mode below.\n\t     */\n\t    lines: function(el, o) {\n\t      var i = 0\n\t        , start = (o.lines - 1) * (1 - o.direction) / 2\n\t        , seg\n\t\n\t      function fill(color, shadow) {\n\t        return css(createEl(), {\n\t          position: 'absolute',\n\t          width: (o.length+o.width) + 'px',\n\t          height: o.width + 'px',\n\t          background: color,\n\t          boxShadow: shadow,\n\t          transformOrigin: 'left',\n\t          transform: 'rotate(' + ~~(360/o.lines*i+o.rotate) + 'deg) translate(' + o.radius+'px' +',0)',\n\t          borderRadius: (o.corners * o.width>>1) + 'px'\n\t        })\n\t      }\n\t\n\t      for (; i < o.lines; i++) {\n\t        seg = css(createEl(), {\n\t          position: 'absolute',\n\t          top: 1+~(o.width/2) + 'px',\n\t          transform: o.hwaccel ? 'translate3d(0,0,0)' : '',\n\t          opacity: o.opacity,\n\t          animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1/o.speed + 's linear infinite'\n\t        })\n\t\n\t        if (o.shadow) ins(seg, css(fill('#000', '0 0 4px ' + '#000'), {top: 2+'px'}))\n\t        ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')))\n\t      }\n\t      return el\n\t    },\n\t\n\t    /**\n\t     * Internal method that adjusts the opacity of a single line.\n\t     * Will be overwritten in VML fallback mode below.\n\t     */\n\t    opacity: function(el, i, val) {\n\t      if (i < el.childNodes.length) el.childNodes[i].style.opacity = val\n\t    }\n\t\n\t  })\n\t\n\t\n\t  function initVML() {\n\t\n\t    /* Utility function to create a VML tag */\n\t    function vml(tag, attr) {\n\t      return createEl('<' + tag + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"spin-vml\">', attr)\n\t    }\n\t\n\t    // No CSS transforms but VML support, add a CSS rule for VML elements:\n\t    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')\n\t\n\t    Spinner.prototype.lines = function(el, o) {\n\t      var r = o.length+o.width\n\t        , s = 2*r\n\t\n\t      function grp() {\n\t        return css(\n\t          vml('group', {\n\t            coordsize: s + ' ' + s,\n\t            coordorigin: -r + ' ' + -r\n\t          }),\n\t          { width: s, height: s }\n\t        )\n\t      }\n\t\n\t      var margin = -(o.width+o.length)*2 + 'px'\n\t        , g = css(grp(), {position: 'absolute', top: margin, left: margin})\n\t        , i\n\t\n\t      function seg(i, dx, filter) {\n\t        ins(g,\n\t          ins(css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx}),\n\t            ins(css(vml('roundrect', {arcsize: o.corners}), {\n\t                width: r,\n\t                height: o.width,\n\t                left: o.radius,\n\t                top: -o.width>>1,\n\t                filter: filter\n\t              }),\n\t              vml('fill', {color: getColor(o.color, i), opacity: o.opacity}),\n\t              vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change\n\t            )\n\t          )\n\t        )\n\t      }\n\t\n\t      if (o.shadow)\n\t        for (i = 1; i <= o.lines; i++)\n\t          seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')\n\t\n\t      for (i = 1; i <= o.lines; i++) seg(i)\n\t      return ins(el, g)\n\t    }\n\t\n\t    Spinner.prototype.opacity = function(el, i, val, o) {\n\t      var c = el.firstChild\n\t      o = o.shadow && o.lines || 0\n\t      if (c && i+o < c.childNodes.length) {\n\t        c = c.childNodes[i+o]; c = c && c.firstChild; c = c && c.firstChild\n\t        if (c) c.opacity = val\n\t      }\n\t    }\n\t  }\n\t\n\t  var probe = css(createEl('group'), {behavior: 'url(#default#VML)'})\n\t\n\t  if (!vendor(probe, 'transform') && probe.adj) initVML()\n\t  else useCssAnimations = vendor(probe, 'animation')\n\t\n\t  return Spinner\n\t\n\t}));\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, require) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\tvar dispose = require(1)\n\t\t// The css code:\n\t\t(require(20))\n\tif(false) {\n\t\tmodule.hot.accept();\n\t\tmodule.hot.dispose(dispose);\n\t}\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, require) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\tvar dispose = require(1)\n\t\t// The css code:\n\t\t(require(21))\n\tif(false) {\n\t\tmodule.hot.accept();\n\t\tmodule.hot.dispose(dispose);\n\t}\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, require) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\tvar dispose = require(1)\n\t\t// The css code:\n\t\t(require(22))\n\tif(false) {\n\t\tmodule.hot.accept();\n\t\tmodule.hot.dispose(dispose);\n\t}\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, require) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\tvar dispose = require(1)\n\t\t// The css code:\n\t\t(require(23))\n\tif(false) {\n\t\tmodule.hot.accept();\n\t\tmodule.hot.dispose(dispose);\n\t}\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, require) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\tvar dispose = require(1)\n\t\t// The css code:\n\t\t(require(24))\n\tif(false) {\n\t\tmodule.hot.accept();\n\t\tmodule.hot.dispose(dispose);\n\t}\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, require) {\n\n\t/* WEBPACK VAR INJECTION */(function(require, global, process) {(function(global) {\n\t  'use strict';\n\t  if (global.$traceurRuntime) {\n\t    return;\n\t  }\n\t  var $Object = Object;\n\t  var $TypeError = TypeError;\n\t  var $create = $Object.create;\n\t  var $defineProperties = $Object.defineProperties;\n\t  var $defineProperty = $Object.defineProperty;\n\t  var $freeze = $Object.freeze;\n\t  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;\n\t  var $getOwnPropertyNames = $Object.getOwnPropertyNames;\n\t  var $getPrototypeOf = $Object.getPrototypeOf;\n\t  var $hasOwnProperty = $Object.prototype.hasOwnProperty;\n\t  var $toString = $Object.prototype.toString;\n\t  function nonEnum(value) {\n\t    return {\n\t      configurable: true,\n\t      enumerable: false,\n\t      value: value,\n\t      writable: true\n\t    };\n\t  }\n\t  var method = nonEnum;\n\t  var counter = 0;\n\t  function newUniqueString() {\n\t    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';\n\t  }\n\t  var symbolInternalProperty = newUniqueString();\n\t  var symbolDescriptionProperty = newUniqueString();\n\t  var symbolDataProperty = newUniqueString();\n\t  var symbolValues = $create(null);\n\t  function isSymbol(symbol) {\n\t    return typeof symbol === 'object' && symbol instanceof SymbolValue;\n\t  }\n\t  function typeOf(v) {\n\t    if (isSymbol(v))\n\t      return 'symbol';\n\t    return typeof v;\n\t  }\n\t  function Symbol(description) {\n\t    var value = new SymbolValue(description);\n\t    if (!(this instanceof Symbol))\n\t      return value;\n\t    throw new TypeError('Symbol cannot be new\\'ed');\n\t  }\n\t  $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));\n\t  $defineProperty(Symbol.prototype, 'toString', method(function() {\n\t    var symbolValue = this[symbolDataProperty];\n\t    if (!getOption('symbols'))\n\t      return symbolValue[symbolInternalProperty];\n\t    if (!symbolValue)\n\t      throw TypeError('Conversion from symbol to string');\n\t    var desc = symbolValue[symbolDescriptionProperty];\n\t    if (desc === undefined)\n\t      desc = '';\n\t    return 'Symbol(' + desc + ')';\n\t  }));\n\t  $defineProperty(Symbol.prototype, 'valueOf', method(function() {\n\t    var symbolValue = this[symbolDataProperty];\n\t    if (!symbolValue)\n\t      throw TypeError('Conversion from symbol to string');\n\t    if (!getOption('symbols'))\n\t      return symbolValue[symbolInternalProperty];\n\t    return symbolValue;\n\t  }));\n\t  function SymbolValue(description) {\n\t    var key = newUniqueString();\n\t    $defineProperty(this, symbolDataProperty, {value: this});\n\t    $defineProperty(this, symbolInternalProperty, {value: key});\n\t    $defineProperty(this, symbolDescriptionProperty, {value: description});\n\t    $freeze(this);\n\t    symbolValues[key] = this;\n\t  }\n\t  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));\n\t  $defineProperty(SymbolValue.prototype, 'toString', {\n\t    value: Symbol.prototype.toString,\n\t    enumerable: false\n\t  });\n\t  $defineProperty(SymbolValue.prototype, 'valueOf', {\n\t    value: Symbol.prototype.valueOf,\n\t    enumerable: false\n\t  });\n\t  $freeze(SymbolValue.prototype);\n\t  Symbol.iterator = Symbol();\n\t  function toProperty(name) {\n\t    if (isSymbol(name))\n\t      return name[symbolInternalProperty];\n\t    return name;\n\t  }\n\t  function getOwnPropertyNames(object) {\n\t    var rv = [];\n\t    var names = $getOwnPropertyNames(object);\n\t    for (var i = 0; i < names.length; i++) {\n\t      var name = names[i];\n\t      if (!symbolValues[name])\n\t        rv.push(name);\n\t    }\n\t    return rv;\n\t  }\n\t  function getOwnPropertyDescriptor(object, name) {\n\t    return $getOwnPropertyDescriptor(object, toProperty(name));\n\t  }\n\t  function getOwnPropertySymbols(object) {\n\t    var rv = [];\n\t    var names = $getOwnPropertyNames(object);\n\t    for (var i = 0; i < names.length; i++) {\n\t      var symbol = symbolValues[names[i]];\n\t      if (symbol)\n\t        rv.push(symbol);\n\t    }\n\t    return rv;\n\t  }\n\t  function hasOwnProperty(name) {\n\t    return $hasOwnProperty.call(this, toProperty(name));\n\t  }\n\t  function getOption(name) {\n\t    return global.traceur && global.traceur.options[name];\n\t  }\n\t  function setProperty(object, name, value) {\n\t    var sym,\n\t        desc;\n\t    if (isSymbol(name)) {\n\t      sym = name;\n\t      name = name[symbolInternalProperty];\n\t    }\n\t    object[name] = value;\n\t    if (sym && (desc = $getOwnPropertyDescriptor(object, name)))\n\t      $defineProperty(object, name, {enumerable: false});\n\t    return value;\n\t  }\n\t  function defineProperty(object, name, descriptor) {\n\t    if (isSymbol(name)) {\n\t      if (descriptor.enumerable) {\n\t        descriptor = $create(descriptor, {enumerable: {value: false}});\n\t      }\n\t      name = name[symbolInternalProperty];\n\t    }\n\t    $defineProperty(object, name, descriptor);\n\t    return object;\n\t  }\n\t  function polyfillObject(Object) {\n\t    $defineProperty(Object, 'defineProperty', {value: defineProperty});\n\t    $defineProperty(Object, 'getOwnPropertyNames', {value: getOwnPropertyNames});\n\t    $defineProperty(Object, 'getOwnPropertyDescriptor', {value: getOwnPropertyDescriptor});\n\t    $defineProperty(Object.prototype, 'hasOwnProperty', {value: hasOwnProperty});\n\t    Object.getOwnPropertySymbols = getOwnPropertySymbols;\n\t    function is(left, right) {\n\t      if (left === right)\n\t        return left !== 0 || 1 / left === 1 / right;\n\t      return left !== left && right !== right;\n\t    }\n\t    $defineProperty(Object, 'is', method(is));\n\t    function assign(target, source) {\n\t      var props = $getOwnPropertyNames(source);\n\t      var p,\n\t          length = props.length;\n\t      for (p = 0; p < length; p++) {\n\t        target[props[p]] = source[props[p]];\n\t      }\n\t      return target;\n\t    }\n\t    $defineProperty(Object, 'assign', method(assign));\n\t    function mixin(target, source) {\n\t      var props = $getOwnPropertyNames(source);\n\t      var p,\n\t          descriptor,\n\t          length = props.length;\n\t      for (p = 0; p < length; p++) {\n\t        descriptor = $getOwnPropertyDescriptor(source, props[p]);\n\t        $defineProperty(target, props[p], descriptor);\n\t      }\n\t      return target;\n\t    }\n\t    $defineProperty(Object, 'mixin', method(mixin));\n\t  }\n\t  function exportStar(object) {\n\t    for (var i = 1; i < arguments.length; i++) {\n\t      var names = $getOwnPropertyNames(arguments[i]);\n\t      for (var j = 0; j < names.length; j++) {\n\t        (function(mod, name) {\n\t          $defineProperty(object, name, {\n\t            get: function() {\n\t              return mod[name];\n\t            },\n\t            enumerable: true\n\t          });\n\t        })(arguments[i], names[j]);\n\t      }\n\t    }\n\t    return object;\n\t  }\n\t  function toObject(value) {\n\t    if (value == null)\n\t      throw $TypeError();\n\t    return $Object(value);\n\t  }\n\t  function spread() {\n\t    var rv = [],\n\t        k = 0;\n\t    for (var i = 0; i < arguments.length; i++) {\n\t      var valueToSpread = toObject(arguments[i]);\n\t      for (var j = 0; j < valueToSpread.length; j++) {\n\t        rv[k++] = valueToSpread[j];\n\t      }\n\t    }\n\t    return rv;\n\t  }\n\t  function getPropertyDescriptor(object, name) {\n\t    while (object !== null) {\n\t      var result = $getOwnPropertyDescriptor(object, name);\n\t      if (result)\n\t        return result;\n\t      object = $getPrototypeOf(object);\n\t    }\n\t    return undefined;\n\t  }\n\t  function superDescriptor(homeObject, name) {\n\t    var proto = $getPrototypeOf(homeObject);\n\t    if (!proto)\n\t      throw $TypeError('super is null');\n\t    return getPropertyDescriptor(proto, name);\n\t  }\n\t  function superCall(self, homeObject, name, args) {\n\t    var descriptor = superDescriptor(homeObject, name);\n\t    if (descriptor) {\n\t      if ('value' in descriptor)\n\t        return descriptor.value.apply(self, args);\n\t      if (descriptor.get)\n\t        return descriptor.get.call(self).apply(self, args);\n\t    }\n\t    throw $TypeError(\"super has no method '\" + name + \"'.\");\n\t  }\n\t  function superGet(self, homeObject, name) {\n\t    var descriptor = superDescriptor(homeObject, name);\n\t    if (descriptor) {\n\t      if (descriptor.get)\n\t        return descriptor.get.call(self);\n\t      else if ('value' in descriptor)\n\t        return descriptor.value;\n\t    }\n\t    return undefined;\n\t  }\n\t  function superSet(self, homeObject, name, value) {\n\t    var descriptor = superDescriptor(homeObject, name);\n\t    if (descriptor && descriptor.set) {\n\t      descriptor.set.call(self, value);\n\t      return;\n\t    }\n\t    throw $TypeError(\"super has no setter '\" + name + \"'.\");\n\t  }\n\t  function getDescriptors(object) {\n\t    var descriptors = {},\n\t        name,\n\t        names = $getOwnPropertyNames(object);\n\t    for (var i = 0; i < names.length; i++) {\n\t      var name = names[i];\n\t      descriptors[name] = $getOwnPropertyDescriptor(object, name);\n\t    }\n\t    return descriptors;\n\t  }\n\t  function createClass(ctor, object, staticObject, superClass) {\n\t    $defineProperty(object, 'constructor', {\n\t      value: ctor,\n\t      configurable: true,\n\t      enumerable: false,\n\t      writable: true\n\t    });\n\t    if (arguments.length > 3) {\n\t      if (typeof superClass === 'function')\n\t        ctor.__proto__ = superClass;\n\t      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));\n\t    } else {\n\t      ctor.prototype = object;\n\t    }\n\t    $defineProperty(ctor, 'prototype', {\n\t      configurable: false,\n\t      writable: false\n\t    });\n\t    return $defineProperties(ctor, getDescriptors(staticObject));\n\t  }\n\t  function getProtoParent(superClass) {\n\t    if (typeof superClass === 'function') {\n\t      var prototype = superClass.prototype;\n\t      if ($Object(prototype) === prototype || prototype === null)\n\t        return superClass.prototype;\n\t    }\n\t    if (superClass === null)\n\t      return null;\n\t    throw new TypeError();\n\t  }\n\t  function defaultSuperCall(self, homeObject, args) {\n\t    if ($getPrototypeOf(homeObject) !== null)\n\t      superCall(self, homeObject, 'constructor', args);\n\t  }\n\t  var ST_NEWBORN = 0;\n\t  var ST_EXECUTING = 1;\n\t  var ST_SUSPENDED = 2;\n\t  var ST_CLOSED = 3;\n\t  var END_STATE = -3;\n\t  function addIterator(object) {\n\t    return defineProperty(object, Symbol.iterator, nonEnum(function() {\n\t      return this;\n\t    }));\n\t  }\n\t  function GeneratorContext() {\n\t    this.state = 0;\n\t    this.GState = ST_NEWBORN;\n\t    this.storedException = undefined;\n\t    this.finallyFallThrough = undefined;\n\t    this.sent = undefined;\n\t    this.returnValue = undefined;\n\t    this.tryStack_ = [];\n\t  }\n\t  GeneratorContext.prototype = {\n\t    pushTry: function(catchState, finallyState) {\n\t      if (finallyState !== null) {\n\t        var finallyFallThrough = null;\n\t        for (var i = this.tryStack_.length - 1; i >= 0; i--) {\n\t          if (this.tryStack_[i].catch !== undefined) {\n\t            finallyFallThrough = this.tryStack_[i].catch;\n\t            break;\n\t          }\n\t        }\n\t        if (finallyFallThrough === null)\n\t          finallyFallThrough = -3;\n\t        this.tryStack_.push({\n\t          finally: finallyState,\n\t          finallyFallThrough: finallyFallThrough\n\t        });\n\t      }\n\t      if (catchState !== null) {\n\t        this.tryStack_.push({catch: catchState});\n\t      }\n\t    },\n\t    popTry: function() {\n\t      this.tryStack_.pop();\n\t    }\n\t  };\n\t  function getNextOrThrow(ctx, moveNext, action) {\n\t    return function(x) {\n\t      switch (ctx.GState) {\n\t        case ST_EXECUTING:\n\t          throw new Error((\"\\\"\" + action + \"\\\" on executing generator\"));\n\t        case ST_CLOSED:\n\t          throw new Error((\"\\\"\" + action + \"\\\" on closed generator\"));\n\t        case ST_NEWBORN:\n\t          if (action === 'throw') {\n\t            ctx.GState = ST_CLOSED;\n\t            throw x;\n\t          }\n\t          if (x !== undefined)\n\t            throw $TypeError('Sent value to newborn generator');\n\t        case ST_SUSPENDED:\n\t          ctx.GState = ST_EXECUTING;\n\t          ctx.action = action;\n\t          ctx.sent = x;\n\t          var value = moveNext(ctx);\n\t          var done = value === ctx;\n\t          if (done)\n\t            value = ctx.returnValue;\n\t          ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;\n\t          return {\n\t            value: value,\n\t            done: done\n\t          };\n\t      }\n\t    };\n\t  }\n\t  function generatorWrap(innerFunction, self) {\n\t    var moveNext = getMoveNext(innerFunction, self);\n\t    var ctx = new GeneratorContext();\n\t    return addIterator({\n\t      next: getNextOrThrow(ctx, moveNext, 'next'),\n\t      throw: getNextOrThrow(ctx, moveNext, 'throw')\n\t    });\n\t  }\n\t  function AsyncFunctionContext() {\n\t    GeneratorContext.call(this);\n\t    this.err = undefined;\n\t    var ctx = this;\n\t    ctx.result = new Promise(function(resolve, reject) {\n\t      ctx.resolve = resolve;\n\t      ctx.reject = reject;\n\t    });\n\t  }\n\t  AsyncFunctionContext.prototype = Object.create(GeneratorContext.prototype);\n\t  function asyncWrap(innerFunction, self) {\n\t    var moveNext = getMoveNext(innerFunction, self);\n\t    var ctx = new AsyncFunctionContext();\n\t    ctx.createCallback = function(newState) {\n\t      return function(value) {\n\t        ctx.state = newState;\n\t        ctx.value = value;\n\t        moveNext(ctx);\n\t      };\n\t    };\n\t    ctx.createErrback = function(newState) {\n\t      return function(err) {\n\t        ctx.state = newState;\n\t        ctx.err = err;\n\t        moveNext(ctx);\n\t      };\n\t    };\n\t    moveNext(ctx);\n\t    return ctx.result;\n\t  }\n\t  function getMoveNext(innerFunction, self) {\n\t    return function(ctx) {\n\t      while (true) {\n\t        try {\n\t          return innerFunction.call(self, ctx);\n\t        } catch (ex) {\n\t          ctx.storedException = ex;\n\t          var last = ctx.tryStack_[ctx.tryStack_.length - 1];\n\t          if (!last) {\n\t            ctx.GState = ST_CLOSED;\n\t            ctx.state = END_STATE;\n\t            throw ex;\n\t          }\n\t          ctx.state = last.catch !== undefined ? last.catch : last.finally;\n\t          if (last.finallyFallThrough !== undefined)\n\t            ctx.finallyFallThrough = last.finallyFallThrough;\n\t        }\n\t      }\n\t    };\n\t  }\n\t  function setupGlobals(global) {\n\t    global.Symbol = Symbol;\n\t    polyfillObject(global.Object);\n\t  }\n\t  setupGlobals(global);\n\t  global.$traceurRuntime = {\n\t    asyncWrap: asyncWrap,\n\t    createClass: createClass,\n\t    defaultSuperCall: defaultSuperCall,\n\t    exportStar: exportStar,\n\t    generatorWrap: generatorWrap,\n\t    setProperty: setProperty,\n\t    setupGlobals: setupGlobals,\n\t    spread: spread,\n\t    superCall: superCall,\n\t    superGet: superGet,\n\t    superSet: superSet,\n\t    toObject: toObject,\n\t    toProperty: toProperty,\n\t    typeof: typeOf\n\t  };\n\t})(typeof global !== 'undefined' ? global : this);\n\t(function() {\n\t  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n\t    var out = [];\n\t    if (opt_scheme) {\n\t      out.push(opt_scheme, ':');\n\t    }\n\t    if (opt_domain) {\n\t      out.push('//');\n\t      if (opt_userInfo) {\n\t        out.push(opt_userInfo, '@');\n\t      }\n\t      out.push(opt_domain);\n\t      if (opt_port) {\n\t        out.push(':', opt_port);\n\t      }\n\t    }\n\t    if (opt_path) {\n\t      out.push(opt_path);\n\t    }\n\t    if (opt_queryData) {\n\t      out.push('?', opt_queryData);\n\t    }\n\t    if (opt_fragment) {\n\t      out.push('#', opt_fragment);\n\t    }\n\t    return out.join('');\n\t  }\n\t  ;\n\t  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\\\?([^#]*))?' + '(?:#(.*))?' + '$');\n\t  var ComponentIndex = {\n\t    SCHEME: 1,\n\t    USER_INFO: 2,\n\t    DOMAIN: 3,\n\t    PORT: 4,\n\t    PATH: 5,\n\t    QUERY_DATA: 6,\n\t    FRAGMENT: 7\n\t  };\n\t  function split(uri) {\n\t    return (uri.match(splitRe));\n\t  }\n\t  function removeDotSegments(path) {\n\t    if (path === '/')\n\t      return '/';\n\t    var leadingSlash = path[0] === '/' ? '/' : '';\n\t    var trailingSlash = path.slice(-1) === '/' ? '/' : '';\n\t    var segments = path.split('/');\n\t    var out = [];\n\t    var up = 0;\n\t    for (var pos = 0; pos < segments.length; pos++) {\n\t      var segment = segments[pos];\n\t      switch (segment) {\n\t        case '':\n\t        case '.':\n\t          break;\n\t        case '..':\n\t          if (out.length)\n\t            out.pop();\n\t          else\n\t            up++;\n\t          break;\n\t        default:\n\t          out.push(segment);\n\t      }\n\t    }\n\t    if (!leadingSlash) {\n\t      while (up-- > 0) {\n\t        out.unshift('..');\n\t      }\n\t      if (out.length === 0)\n\t        out.push('.');\n\t    }\n\t    return leadingSlash + out.join('/') + trailingSlash;\n\t  }\n\t  function joinAndCanonicalizePath(parts) {\n\t    var path = parts[ComponentIndex.PATH] || '';\n\t    path = removeDotSegments(path.replace(/\\/\\//.g, '/'));\n\t    parts[ComponentIndex.PATH] = path;\n\t    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);\n\t  }\n\t  function canonicalizeUrl(url) {\n\t    var parts = split(url);\n\t    return joinAndCanonicalizePath(parts);\n\t  }\n\t  function resolveUrl(base, url) {\n\t    var parts = split(url);\n\t    var baseParts = split(base);\n\t    if (parts[ComponentIndex.SCHEME]) {\n\t      return joinAndCanonicalizePath(parts);\n\t    } else {\n\t      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];\n\t    }\n\t    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {\n\t      if (!parts[i]) {\n\t        parts[i] = baseParts[i];\n\t      }\n\t    }\n\t    if (parts[ComponentIndex.PATH][0] == '/') {\n\t      return joinAndCanonicalizePath(parts);\n\t    }\n\t    var path = baseParts[ComponentIndex.PATH];\n\t    var index = path.lastIndexOf('/');\n\t    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];\n\t    parts[ComponentIndex.PATH] = path;\n\t    return joinAndCanonicalizePath(parts);\n\t  }\n\t  function isAbsolute(name) {\n\t    if (!name)\n\t      return false;\n\t    if (name[0] === '/')\n\t      return true;\n\t    var parts = split(name);\n\t    if (parts[ComponentIndex.SCHEME])\n\t      return true;\n\t    return false;\n\t  }\n\t  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;\n\t  $traceurRuntime.isAbsolute = isAbsolute;\n\t  $traceurRuntime.removeDotSegments = removeDotSegments;\n\t  $traceurRuntime.resolveUrl = resolveUrl;\n\t})();\n\t(function(global) {\n\t  'use strict';\n\t  var $__2 = $traceurRuntime,\n\t      canonicalizeUrl = $__2.canonicalizeUrl,\n\t      resolveUrl = $__2.resolveUrl,\n\t      isAbsolute = $__2.isAbsolute;\n\t  var moduleInstantiators = Object.create(null);\n\t  var baseURL;\n\t  if (global.location && global.location.href)\n\t    baseURL = resolveUrl(global.location.href, './');\n\t  else\n\t    baseURL = '';\n\t  var UncoatedModuleEntry = function UncoatedModuleEntry(url, uncoatedModule) {\n\t    this.url = url;\n\t    this.value_ = uncoatedModule;\n\t  };\n\t  ($traceurRuntime.createClass)(UncoatedModuleEntry, {}, {});\n\t  var UncoatedModuleInstantiator = function UncoatedModuleInstantiator(url, func) {\n\t    $traceurRuntime.superCall(this, $UncoatedModuleInstantiator.prototype, \"constructor\", [url, null]);\n\t    this.func = func;\n\t  };\n\t  var $UncoatedModuleInstantiator = UncoatedModuleInstantiator;\n\t  ($traceurRuntime.createClass)(UncoatedModuleInstantiator, {getUncoatedModule: function() {\n\t      if (this.value_)\n\t        return this.value_;\n\t      return this.value_ = this.func.call(global);\n\t    }}, {}, UncoatedModuleEntry);\n\t  function getUncoatedModuleInstantiator(name) {\n\t    if (!name)\n\t      return;\n\t    var url = ModuleStore.normalize(name);\n\t    return moduleInstantiators[url];\n\t  }\n\t  ;\n\t  var moduleInstances = Object.create(null);\n\t  var liveModuleSentinel = {};\n\t  function Module(uncoatedModule) {\n\t    var isLive = arguments[1];\n\t    var coatedModule = Object.create(null);\n\t    Object.getOwnPropertyNames(uncoatedModule).forEach((function(name) {\n\t      var getter,\n\t          value;\n\t      if (isLive === liveModuleSentinel) {\n\t        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);\n\t        if (descr.get)\n\t          getter = descr.get;\n\t      }\n\t      if (!getter) {\n\t        value = uncoatedModule[name];\n\t        getter = function() {\n\t          return value;\n\t        };\n\t      }\n\t      Object.defineProperty(coatedModule, name, {\n\t        get: getter,\n\t        enumerable: true\n\t      });\n\t    }));\n\t    Object.preventExtensions(coatedModule);\n\t    return coatedModule;\n\t  }\n\t  var ModuleStore = {\n\t    normalize: function(name, refererName, refererAddress) {\n\t      if (typeof name !== \"string\")\n\t        throw new TypeError(\"module name must be a string, not \" + typeof name);\n\t      if (isAbsolute(name))\n\t        return canonicalizeUrl(name);\n\t      if (/[^\\.]\\/\\.\\.\\//.test(name)) {\n\t        throw new Error('module name embeds /../: ' + name);\n\t      }\n\t      if (name[0] === '.' && refererName)\n\t        return resolveUrl(refererName, name);\n\t      return canonicalizeUrl(name);\n\t    },\n\t    get: function(normalizedName) {\n\t      var m = getUncoatedModuleInstantiator(normalizedName);\n\t      if (!m)\n\t        return undefined;\n\t      var moduleInstance = moduleInstances[m.url];\n\t      if (moduleInstance)\n\t        return moduleInstance;\n\t      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);\n\t      return moduleInstances[m.url] = moduleInstance;\n\t    },\n\t    set: function(normalizedName, module) {\n\t      normalizedName = String(normalizedName);\n\t      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, (function() {\n\t        return module;\n\t      }));\n\t      moduleInstances[normalizedName] = module;\n\t    },\n\t    get baseURL() {\n\t      return baseURL;\n\t    },\n\t    set baseURL(v) {\n\t      baseURL = String(v);\n\t    },\n\t    registerModule: function(name, func) {\n\t      var normalizedName = ModuleStore.normalize(name);\n\t      if (moduleInstantiators[normalizedName])\n\t        throw new Error('duplicate module named ' + normalizedName);\n\t      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);\n\t    },\n\t    bundleStore: Object.create(null),\n\t    register: function(name, deps, func) {\n\t      if (!deps || !deps.length) {\n\t        this.registerModule(name, func);\n\t      } else {\n\t        this.bundleStore[name] = {\n\t          deps: deps,\n\t          execute: func\n\t        };\n\t      }\n\t    },\n\t    getAnonymousModule: function(func) {\n\t      return new Module(func.call(global), liveModuleSentinel);\n\t    },\n\t    getForTesting: function(name) {\n\t      var $__0 = this;\n\t      if (!this.testingPrefix_) {\n\t        Object.keys(moduleInstances).some((function(key) {\n\t          var m = /(traceur@[^\\/]*\\/)/.exec(key);\n\t          if (m) {\n\t            $__0.testingPrefix_ = m[1];\n\t            return true;\n\t          }\n\t        }));\n\t      }\n\t      return this.get(this.testingPrefix_ + name);\n\t    }\n\t  };\n\t  ModuleStore.set('@traceur/src/runtime/ModuleStore', new Module({ModuleStore: ModuleStore}));\n\t  var setupGlobals = $traceurRuntime.setupGlobals;\n\t  $traceurRuntime.setupGlobals = function(global) {\n\t    setupGlobals(global);\n\t  };\n\t  $traceurRuntime.ModuleStore = ModuleStore;\n\t  global.System = {\n\t    register: ModuleStore.register.bind(ModuleStore),\n\t    get: ModuleStore.get,\n\t    set: ModuleStore.set,\n\t    normalize: ModuleStore.normalize\n\t  };\n\t  $traceurRuntime.getModuleImpl = function(name) {\n\t    var instantiator = getUncoatedModuleInstantiator(name);\n\t    return instantiator && instantiator.getUncoatedModule();\n\t  };\n\t})(typeof global !== 'undefined' ? global : this);\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/utils\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/utils\";\n\t  var toObject = $traceurRuntime.toObject;\n\t  function toUint32(x) {\n\t    return x | 0;\n\t  }\n\t  return {\n\t    get toObject() {\n\t      return toObject;\n\t    },\n\t    get toUint32() {\n\t      return toUint32;\n\t    }\n\t  };\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\", [], function() {\n\t  \"use strict\";\n\t  var $__4;\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\";\n\t  var $__5 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/utils\"),\n\t      toObject = $__5.toObject,\n\t      toUint32 = $__5.toUint32;\n\t  var ARRAY_ITERATOR_KIND_KEYS = 1;\n\t  var ARRAY_ITERATOR_KIND_VALUES = 2;\n\t  var ARRAY_ITERATOR_KIND_ENTRIES = 3;\n\t  var ArrayIterator = function ArrayIterator() {};\n\t  ($traceurRuntime.createClass)(ArrayIterator, ($__4 = {}, Object.defineProperty($__4, \"next\", {\n\t    value: function() {\n\t      var iterator = toObject(this);\n\t      var array = iterator.iteratorObject_;\n\t      if (!array) {\n\t        throw new TypeError('Object is not an ArrayIterator');\n\t      }\n\t      var index = iterator.arrayIteratorNextIndex_;\n\t      var itemKind = iterator.arrayIterationKind_;\n\t      var length = toUint32(array.length);\n\t      if (index >= length) {\n\t        iterator.arrayIteratorNextIndex_ = Infinity;\n\t        return createIteratorResultObject(undefined, true);\n\t      }\n\t      iterator.arrayIteratorNextIndex_ = index + 1;\n\t      if (itemKind == ARRAY_ITERATOR_KIND_VALUES)\n\t        return createIteratorResultObject(array[index], false);\n\t      if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)\n\t        return createIteratorResultObject([index, array[index]], false);\n\t      return createIteratorResultObject(index, false);\n\t    },\n\t    configurable: true,\n\t    enumerable: true,\n\t    writable: true\n\t  }), Object.defineProperty($__4, Symbol.iterator, {\n\t    value: function() {\n\t      return this;\n\t    },\n\t    configurable: true,\n\t    enumerable: true,\n\t    writable: true\n\t  }), $__4), {});\n\t  function createArrayIterator(array, kind) {\n\t    var object = toObject(array);\n\t    var iterator = new ArrayIterator;\n\t    iterator.iteratorObject_ = object;\n\t    iterator.arrayIteratorNextIndex_ = 0;\n\t    iterator.arrayIterationKind_ = kind;\n\t    return iterator;\n\t  }\n\t  function createIteratorResultObject(value, done) {\n\t    return {\n\t      value: value,\n\t      done: done\n\t    };\n\t  }\n\t  function entries() {\n\t    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);\n\t  }\n\t  function keys() {\n\t    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);\n\t  }\n\t  function values() {\n\t    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);\n\t  }\n\t  return {\n\t    get entries() {\n\t      return entries;\n\t    },\n\t    get keys() {\n\t      return keys;\n\t    },\n\t    get values() {\n\t      return values;\n\t    }\n\t  };\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\";\n\t  var $__default = function asap(callback, arg) {\n\t    var length = queue.push([callback, arg]);\n\t    if (length === 1) {\n\t      scheduleFlush();\n\t    }\n\t  };\n\t  var browserGlobal = (typeof window !== 'undefined') ? window : {};\n\t  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n\t  function useNextTick() {\n\t    return function() {\n\t      process.nextTick(flush);\n\t    };\n\t  }\n\t  function useMutationObserver() {\n\t    var iterations = 0;\n\t    var observer = new BrowserMutationObserver(flush);\n\t    var node = document.createTextNode('');\n\t    observer.observe(node, {characterData: true});\n\t    return function() {\n\t      node.data = (iterations = ++iterations % 2);\n\t    };\n\t  }\n\t  function useSetTimeout() {\n\t    return function() {\n\t      setTimeout(flush, 1);\n\t    };\n\t  }\n\t  var queue = [];\n\t  function flush() {\n\t    for (var i = 0; i < queue.length; i++) {\n\t      var tuple = queue[i];\n\t      var callback = tuple[0],\n\t          arg = tuple[1];\n\t      callback(arg);\n\t    }\n\t    queue = [];\n\t  }\n\t  var scheduleFlush;\n\t  if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n\t    scheduleFlush = useNextTick();\n\t  } else if (BrowserMutationObserver) {\n\t    scheduleFlush = useMutationObserver();\n\t  } else {\n\t    scheduleFlush = useSetTimeout();\n\t  }\n\t  return {get default() {\n\t      return $__default;\n\t    }};\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\";\n\t  var async = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\").default;\n\t  function isPromise(x) {\n\t    return x && typeof x === 'object' && x.status_ !== undefined;\n\t  }\n\t  function chain(promise) {\n\t    var onResolve = arguments[1] !== (void 0) ? arguments[1] : (function(x) {\n\t      return x;\n\t    });\n\t    var onReject = arguments[2] !== (void 0) ? arguments[2] : (function(e) {\n\t      throw e;\n\t    });\n\t    var deferred = getDeferred(promise.constructor);\n\t    switch (promise.status_) {\n\t      case undefined:\n\t        throw TypeError;\n\t      case 'pending':\n\t        promise.onResolve_.push([deferred, onResolve]);\n\t        promise.onReject_.push([deferred, onReject]);\n\t        break;\n\t      case 'resolved':\n\t        promiseReact(deferred, onResolve, promise.value_);\n\t        break;\n\t      case 'rejected':\n\t        promiseReact(deferred, onReject, promise.value_);\n\t        break;\n\t    }\n\t    return deferred.promise;\n\t  }\n\t  function getDeferred(C) {\n\t    var result = {};\n\t    result.promise = new C((function(resolve, reject) {\n\t      result.resolve = resolve;\n\t      result.reject = reject;\n\t    }));\n\t    return result;\n\t  }\n\t  var Promise = function Promise(resolver) {\n\t    var $__6 = this;\n\t    this.status_ = 'pending';\n\t    this.onResolve_ = [];\n\t    this.onReject_ = [];\n\t    resolver((function(x) {\n\t      promiseResolve($__6, x);\n\t    }), (function(r) {\n\t      promiseReject($__6, r);\n\t    }));\n\t  };\n\t  ($traceurRuntime.createClass)(Promise, {\n\t    catch: function(onReject) {\n\t      return this.then(undefined, onReject);\n\t    },\n\t    then: function() {\n\t      var onResolve = arguments[0] !== (void 0) ? arguments[0] : (function(x) {\n\t        return x;\n\t      });\n\t      var onReject = arguments[1];\n\t      var $__6 = this;\n\t      var constructor = this.constructor;\n\t      return chain(this, (function(x) {\n\t        x = promiseCoerce(constructor, x);\n\t        return x === $__6 ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);\n\t      }), onReject);\n\t    }\n\t  }, {\n\t    resolve: function(x) {\n\t      return new this((function(resolve, reject) {\n\t        resolve(x);\n\t      }));\n\t    },\n\t    reject: function(r) {\n\t      return new this((function(resolve, reject) {\n\t        reject(r);\n\t      }));\n\t    },\n\t    cast: function(x) {\n\t      if (x instanceof this)\n\t        return x;\n\t      if (isPromise(x)) {\n\t        var result = getDeferred(this);\n\t        chain(x, result.resolve, result.reject);\n\t        return result.promise;\n\t      }\n\t      return this.resolve(x);\n\t    },\n\t    all: function(values) {\n\t      var deferred = getDeferred(this);\n\t      var count = 0;\n\t      var resolutions = [];\n\t      try {\n\t        for (var i = 0; i < values.length; i++) {\n\t          ++count;\n\t          this.cast(values[i]).then(function(i, x) {\n\t            resolutions[i] = x;\n\t            if (--count === 0)\n\t              deferred.resolve(resolutions);\n\t          }.bind(undefined, i), (function(r) {\n\t            if (count > 0)\n\t              count = 0;\n\t            deferred.reject(r);\n\t          }));\n\t        }\n\t        if (count === 0)\n\t          deferred.resolve(resolutions);\n\t      } catch (e) {\n\t        deferred.reject(e);\n\t      }\n\t      return deferred.promise;\n\t    },\n\t    race: function(values) {\n\t      var deferred = getDeferred(this);\n\t      try {\n\t        for (var i = 0; i < values.length; i++) {\n\t          this.cast(values[i]).then((function(x) {\n\t            deferred.resolve(x);\n\t          }), (function(r) {\n\t            deferred.reject(r);\n\t          }));\n\t        }\n\t      } catch (e) {\n\t        deferred.reject(e);\n\t      }\n\t      return deferred.promise;\n\t    }\n\t  });\n\t  function promiseResolve(promise, x) {\n\t    promiseDone(promise, 'resolved', x, promise.onResolve_);\n\t  }\n\t  function promiseReject(promise, r) {\n\t    promiseDone(promise, 'rejected', r, promise.onReject_);\n\t  }\n\t  function promiseDone(promise, status, value, reactions) {\n\t    if (promise.status_ !== 'pending')\n\t      return;\n\t    for (var i = 0; i < reactions.length; i++) {\n\t      promiseReact(reactions[i][0], reactions[i][1], value);\n\t    }\n\t    promise.status_ = status;\n\t    promise.value_ = value;\n\t    promise.onResolve_ = promise.onReject_ = undefined;\n\t  }\n\t  function promiseReact(deferred, handler, x) {\n\t    async((function() {\n\t      try {\n\t        var y = handler(x);\n\t        if (y === deferred.promise)\n\t          throw new TypeError;\n\t        else if (isPromise(y))\n\t          chain(y, deferred.resolve, deferred.reject);\n\t        else\n\t          deferred.resolve(y);\n\t      } catch (e) {\n\t        deferred.reject(e);\n\t      }\n\t    }));\n\t  }\n\t  var thenableSymbol = '@@thenable';\n\t  function promiseCoerce(constructor, x) {\n\t    if (isPromise(x)) {\n\t      return x;\n\t    } else if (x && typeof x.then === 'function') {\n\t      var p = x[thenableSymbol];\n\t      if (p) {\n\t        return p;\n\t      } else {\n\t        var deferred = getDeferred(constructor);\n\t        x[thenableSymbol] = deferred.promise;\n\t        try {\n\t          x.then(deferred.resolve, deferred.reject);\n\t        } catch (e) {\n\t          deferred.reject(e);\n\t        }\n\t        return deferred.promise;\n\t      }\n\t    } else {\n\t      return x;\n\t    }\n\t  }\n\t  return {get Promise() {\n\t      return Promise;\n\t    }};\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/String\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/String\";\n\t  var $toString = Object.prototype.toString;\n\t  var $indexOf = String.prototype.indexOf;\n\t  var $lastIndexOf = String.prototype.lastIndexOf;\n\t  function startsWith(search) {\n\t    var string = String(this);\n\t    if (this == null || $toString.call(search) == '[object RegExp]') {\n\t      throw TypeError();\n\t    }\n\t    var stringLength = string.length;\n\t    var searchString = String(search);\n\t    var searchLength = searchString.length;\n\t    var position = arguments.length > 1 ? arguments[1] : undefined;\n\t    var pos = position ? Number(position) : 0;\n\t    if (isNaN(pos)) {\n\t      pos = 0;\n\t    }\n\t    var start = Math.min(Math.max(pos, 0), stringLength);\n\t    return $indexOf.call(string, searchString, pos) == start;\n\t  }\n\t  function endsWith(search) {\n\t    var string = String(this);\n\t    if (this == null || $toString.call(search) == '[object RegExp]') {\n\t      throw TypeError();\n\t    }\n\t    var stringLength = string.length;\n\t    var searchString = String(search);\n\t    var searchLength = searchString.length;\n\t    var pos = stringLength;\n\t    if (arguments.length > 1) {\n\t      var position = arguments[1];\n\t      if (position !== undefined) {\n\t        pos = position ? Number(position) : 0;\n\t        if (isNaN(pos)) {\n\t          pos = 0;\n\t        }\n\t      }\n\t    }\n\t    var end = Math.min(Math.max(pos, 0), stringLength);\n\t    var start = end - searchLength;\n\t    if (start < 0) {\n\t      return false;\n\t    }\n\t    return $lastIndexOf.call(string, searchString, start) == start;\n\t  }\n\t  function contains(search) {\n\t    if (this == null) {\n\t      throw TypeError();\n\t    }\n\t    var string = String(this);\n\t    var stringLength = string.length;\n\t    var searchString = String(search);\n\t    var searchLength = searchString.length;\n\t    var position = arguments.length > 1 ? arguments[1] : undefined;\n\t    var pos = position ? Number(position) : 0;\n\t    if (isNaN(pos)) {\n\t      pos = 0;\n\t    }\n\t    var start = Math.min(Math.max(pos, 0), stringLength);\n\t    return $indexOf.call(string, searchString, pos) != -1;\n\t  }\n\t  function repeat(count) {\n\t    if (this == null) {\n\t      throw TypeError();\n\t    }\n\t    var string = String(this);\n\t    var n = count ? Number(count) : 0;\n\t    if (isNaN(n)) {\n\t      n = 0;\n\t    }\n\t    if (n < 0 || n == Infinity) {\n\t      throw RangeError();\n\t    }\n\t    if (n == 0) {\n\t      return '';\n\t    }\n\t    var result = '';\n\t    while (n--) {\n\t      result += string;\n\t    }\n\t    return result;\n\t  }\n\t  function codePointAt(position) {\n\t    if (this == null) {\n\t      throw TypeError();\n\t    }\n\t    var string = String(this);\n\t    var size = string.length;\n\t    var index = position ? Number(position) : 0;\n\t    if (isNaN(index)) {\n\t      index = 0;\n\t    }\n\t    if (index < 0 || index >= size) {\n\t      return undefined;\n\t    }\n\t    var first = string.charCodeAt(index);\n\t    var second;\n\t    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {\n\t      second = string.charCodeAt(index + 1);\n\t      if (second >= 0xDC00 && second <= 0xDFFF) {\n\t        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n\t      }\n\t    }\n\t    return first;\n\t  }\n\t  function raw(callsite) {\n\t    var raw = callsite.raw;\n\t    var len = raw.length >>> 0;\n\t    if (len === 0)\n\t      return '';\n\t    var s = '';\n\t    var i = 0;\n\t    while (true) {\n\t      s += raw[i];\n\t      if (i + 1 === len)\n\t        return s;\n\t      s += arguments[++i];\n\t    }\n\t  }\n\t  function fromCodePoint() {\n\t    var codeUnits = [];\n\t    var floor = Math.floor;\n\t    var highSurrogate;\n\t    var lowSurrogate;\n\t    var index = -1;\n\t    var length = arguments.length;\n\t    if (!length) {\n\t      return '';\n\t    }\n\t    while (++index < length) {\n\t      var codePoint = Number(arguments[index]);\n\t      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {\n\t        throw RangeError('Invalid code point: ' + codePoint);\n\t      }\n\t      if (codePoint <= 0xFFFF) {\n\t        codeUnits.push(codePoint);\n\t      } else {\n\t        codePoint -= 0x10000;\n\t        highSurrogate = (codePoint >> 10) + 0xD800;\n\t        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n\t        codeUnits.push(highSurrogate, lowSurrogate);\n\t      }\n\t    }\n\t    return String.fromCharCode.apply(null, codeUnits);\n\t  }\n\t  return {\n\t    get startsWith() {\n\t      return startsWith;\n\t    },\n\t    get endsWith() {\n\t      return endsWith;\n\t    },\n\t    get contains() {\n\t      return contains;\n\t    },\n\t    get repeat() {\n\t      return repeat;\n\t    },\n\t    get codePointAt() {\n\t      return codePointAt;\n\t    },\n\t    get raw() {\n\t      return raw;\n\t    },\n\t    get fromCodePoint() {\n\t      return fromCodePoint;\n\t    }\n\t  };\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\";\n\t  var Promise = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\").Promise;\n\t  var $__9 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/String\"),\n\t      codePointAt = $__9.codePointAt,\n\t      contains = $__9.contains,\n\t      endsWith = $__9.endsWith,\n\t      fromCodePoint = $__9.fromCodePoint,\n\t      repeat = $__9.repeat,\n\t      raw = $__9.raw,\n\t      startsWith = $__9.startsWith;\n\t  var $__9 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\"),\n\t      entries = $__9.entries,\n\t      keys = $__9.keys,\n\t      values = $__9.values;\n\t  function maybeDefineMethod(object, name, value) {\n\t    if (!(name in object)) {\n\t      Object.defineProperty(object, name, {\n\t        value: value,\n\t        configurable: true,\n\t        enumerable: false,\n\t        writable: true\n\t      });\n\t    }\n\t  }\n\t  function maybeAddFunctions(object, functions) {\n\t    for (var i = 0; i < functions.length; i += 2) {\n\t      var name = functions[i];\n\t      var value = functions[i + 1];\n\t      maybeDefineMethod(object, name, value);\n\t    }\n\t  }\n\t  function polyfillPromise(global) {\n\t    if (!global.Promise)\n\t      global.Promise = Promise;\n\t  }\n\t  function polyfillString(String) {\n\t    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'contains', contains, 'endsWith', endsWith, 'startsWith', startsWith, 'repeat', repeat]);\n\t    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);\n\t  }\n\t  function polyfillArray(Array, Symbol) {\n\t    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values]);\n\t    if (Symbol && Symbol.iterator) {\n\t      Object.defineProperty(Array.prototype, Symbol.iterator, {\n\t        value: values,\n\t        configurable: true,\n\t        enumerable: false,\n\t        writable: true\n\t      });\n\t    }\n\t  }\n\t  function polyfill(global) {\n\t    polyfillPromise(global);\n\t    polyfillString(global.String);\n\t    polyfillArray(global.Array, global.Symbol);\n\t  }\n\t  polyfill(this);\n\t  var setupGlobals = $traceurRuntime.setupGlobals;\n\t  $traceurRuntime.setupGlobals = function(global) {\n\t    setupGlobals(global);\n\t    polyfill(global);\n\t  };\n\t  return {};\n\t});\n\tSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfill-import\", [], function() {\n\t  \"use strict\";\n\t  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfill-import\";\n\t  var $__11 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\");\n\t  return {};\n\t});\n\tSystem.get(\"traceur-runtime@0.0.25/src/runtime/polyfill-import\" + '');\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, require, (function() { return this; }()), require(3)))\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports = require.p + \"9ac7e2ff6b9792291e65269b982efa35.otf\"\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports = require.p + \"09ad3649cefc511e2e20b98991116a59.otf\"\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports = require.p + \"f0d7d673ef06ec9cf090dc00572d63e4.otf\"\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports = require.p + \"f02f3b1af0eda2c88d9a7ae67234c564.otf\"\n\n/***/ },\n/* 38 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports = require.p + \"819f56653a4197a7959c41ddfc8ff69b.ttf\"\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports = require.p + \"9ac6e3d2a7fb76468bd417ea40b6f8c4.ttf\"\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports = require.p + \"3bb8cd188e88dfe3b75c26c86dae0d79.svg\"\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, require) {\n\n\tvar EventEmitter = exports.EventEmitter = function EventEmitter() {};\n\tvar isArray = require(46);\n\tvar indexOf = require(45);\n\t\n\t\n\t\n\t// By default EventEmitters will print a warning if more than\n\t// 10 listeners are added to it. This is a useful default which\n\t// helps finding memory leaks.\n\t//\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tvar defaultMaxListeners = 10;\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!this._events) this._events = {};\n\t  this._maxListeners = n;\n\t};\n\t\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events || !this._events.error ||\n\t        (isArray(this._events.error) && !this._events.error.length))\n\t    {\n\t      if (arguments[1] instanceof Error) {\n\t        throw arguments[1]; // Unhandled 'error' event\n\t      } else {\n\t        throw new Error(\"Uncaught, unspecified 'error' event.\");\n\t      }\n\t      return false;\n\t    }\n\t  }\n\t\n\t  if (!this._events) return false;\n\t  var handler = this._events[type];\n\t  if (!handler) return false;\n\t\n\t  if (typeof handler == 'function') {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        var args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t    return true;\n\t\n\t  } else if (isArray(handler)) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t\n\t    var listeners = handler.slice();\n\t    for (var i = 0, l = listeners.length; i < l; i++) {\n\t      listeners[i].apply(this, args);\n\t    }\n\t    return true;\n\t\n\t  } else {\n\t    return false;\n\t  }\n\t};\n\t\n\t// EventEmitter is defined in src/node_events.cc\n\t// EventEmitter.prototype.emit() is also defined there.\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  if ('function' !== typeof listener) {\n\t    throw new Error('addListener only takes instances of Function');\n\t  }\n\t\n\t  if (!this._events) this._events = {};\n\t\n\t  // To avoid recursion in the case that type == \"newListeners\"! Before\n\t  // adding it to the listeners, first emit \"newListeners\".\n\t  this.emit('newListener', type, listener);\n\t  if (!this._events[type]) {\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  } else if (isArray(this._events[type])) {\n\t\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t\n\t  } else {\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t  }\n\t\n\t  // Check for listener leak\n\t  if (isArray(this._events[type]) && !this._events[type].warned) {\n\t    var m;\n\t    if (this._maxListeners !== undefined) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(events) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      console.trace();\n\t    }\n\t  }\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if ('function' !== typeof listener) {\n\t    throw new Error('.once only takes instances of Function');\n\t  }\n\t\n\t  var self = this;\n\t  function g() {\n\t    self.removeListener(type, g);\n\t    listener.apply(this, arguments);\n\t  }\n\t\n\t  g.listener = listener;\n\t  self.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  if ('function' !== typeof listener) {\n\t    throw new Error('removeListener only takes instances of Function');\n\t  }\n\t\n\t  // does not use listeners(), so no side effect of creating _events[type]\n\t  if (!this._events || !this._events[type]) return this;\n\t\n\t  var list = this._events[type];\n\t\n\t  if (isArray(list)) {\n\t    var position = -1;\n\t    for (var i = 0, length = list.length; i < length; i++) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener))\n\t      {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0) return this;\n\t    list.splice(position, 1);\n\t    if (list.length == 0)\n\t      delete this._events[type];\n\t  } else if (list === listener ||\n\t             (list.listener && list.listener === listener)) {\n\t    delete this._events[type];\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  if (arguments.length === 0) {\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  // does not use listeners(), so no side effect of creating _events[type]\n\t  if (type && this._events && this._events[type]) this._events[type] = null;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  if (!this._events) this._events = {};\n\t  if (!this._events[type]) this._events[type] = [];\n\t  if (!isArray(this._events[type])) {\n\t    this._events[type] = [this._events[type]];\n\t  }\n\t  return this._events[type];\n\t};\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, require) {\n\n\t/* WEBPACK VAR INJECTION */(function(require, process) {var filter = require(44);\n\t\n\t\n\t// resolves . and .. elements in a path array with directory names there\n\t// must be no slashes, empty elements, or device names (c:\\) in the array\n\t// (so also no leading and trailing slashes - it does not distinguish\n\t// relative and absolute paths)\n\tfunction normalizeArray(parts, allowAboveRoot) {\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = parts.length; i >= 0; i--) {\n\t    var last = parts[i];\n\t    if (last == '.') {\n\t      parts.splice(i, 1);\n\t    } else if (last === '..') {\n\t      parts.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      parts.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (allowAboveRoot) {\n\t    for (; up--; up) {\n\t      parts.unshift('..');\n\t    }\n\t  }\n\t\n\t  return parts;\n\t}\n\t\n\t// Regex to split a filename into [*, dir, basename, ext]\n\t// posix version\n\tvar splitPathRe =\n\t\t/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\t\n\t\n\t// path.resolve([from ...], to)\n\t// posix version\n\texports.resolve = function() {\n\tvar resolvedPath = '',\n\t    resolvedAbsolute = false;\n\t\n\tfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n\t  var path = (i >= 0)\n\t      ? arguments[i]\n\t      : process.cwd();\n\t\n\t  // Skip empty and invalid entries\n\t  if (typeof path !== 'string' || !path) {\n\t    continue;\n\t  }\n\t\n\t  resolvedPath = path + '/' + resolvedPath;\n\t  resolvedAbsolute = path.charAt(0) === '/';\n\t}\n\t\n\t// At this point the path should be resolved to a full absolute path, but\n\t// handle relative paths to be safe (might happen when process.cwd() fails)\n\t\n\t// Normalize the path\n\tresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n\t    return !!p;\n\t  }), !resolvedAbsolute).join('/');\n\t\n\t  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n\t};\n\t\n\t// path.normalize(path)\n\t// posix version\n\texports.normalize = function(path) {\n\tvar isAbsolute = path.charAt(0) === '/',\n\t    trailingSlash = path.slice(-1) === '/';\n\t\n\t// Normalize the path\n\tpath = normalizeArray(filter(path.split('/'), function(p) {\n\t    return !!p;\n\t  }), !isAbsolute).join('/');\n\t\n\t  if (!path && !isAbsolute) {\n\t    path = '.';\n\t  }\n\t  if (path && trailingSlash) {\n\t    path += '/';\n\t  }\n\t  \n\t  return (isAbsolute ? '/' : '') + path;\n\t};\n\t\n\t\n\t// posix version\n\texports.join = function() {\n\t  var paths = Array.prototype.slice.call(arguments, 0);\n\t  return exports.normalize(filter(paths, function(p, index) {\n\t    return p && typeof p === 'string';\n\t  }).join('/'));\n\t};\n\t\n\t\n\texports.dirname = function(path) {\n\t  var match = splitPathRe.exec(path);\n\t  var root = match[1] || '';\n\t  var dir = root + (match[2] || '');\n\t  var isWindows = false;\n\t  if (!dir) {\n\t    // No dirname\n\t    return '.';\n\t  } else if (dir.length === 1 ||\n\t      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n\t    // It is just a slash or a drive letter with a slash\n\t    return dir;\n\t  } else {\n\t    // It is a full dirname, strip trailing slash\n\t    return dir.substring(0, dir.length - 1);\n\t  }\n\t};\n\t\n\t\n\texports.basename = function(path, ext) {\n\t  var f = splitPathRe.exec(path)[3] || '';\n\t  if (ext && f.substr(-1 * ext.length) === ext) {\n\t    f = f.substr(0, f.length - ext.length);\n\t  }\n\t  return f;\n\t};\n\t\n\t\n\texports.extname = function(path) {\n\t  return splitPathRe.exec(path)[4] || '';\n\t};\n\t\n\texports.relative = function(from, to) {\n\t  from = exports.resolve(from).substr(1);\n\t  to = exports.resolve(to).substr(1);\n\t\n\t  function trim(arr) {\n\t    var start = 0;\n\t    for (; start < arr.length; start++) {\n\t      if (arr[start] !== '') break;\n\t    }\n\t\n\t    var end = arr.length - 1;\n\t    for (; end >= 0; end--) {\n\t      if (arr[end] !== '') break;\n\t    }\n\t\n\t    if (start > end) return [];\n\t    return arr.slice(start, end - start + 1);\n\t  }\n\t\n\t  var fromParts = trim(from.split('/'));\n\t  var toParts = trim(to.split('/'));\n\t\n\t  var length = Math.min(fromParts.length, toParts.length);\n\t  var samePartsLength = length;\n\t  for (var i = 0; i < length; i++) {\n\t    if (fromParts[i] !== toParts[i]) {\n\t      samePartsLength = i;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var outputParts = [];\n\t  for (var i = samePartsLength; i < fromParts.length; i++) {\n\t    outputParts.push('..');\n\t  }\n\t\n\t  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\t\n\t  return outputParts.join('/');\n\t};\n\t\n\texports.sep = '/';\n\t/* WEBPACK VAR INJECTION */}.call(exports, require, require(3)))\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, require) {\n\n\tvar Object_keys = function (obj) {\n\t    if (Object.keys) return Object.keys(obj)\n\t    else {\n\t        var res = [];\n\t        for (var key in obj) res.push(key)\n\t        return res;\n\t    }\n\t};\n\t\n\tvar forEach = function (xs, fn) {\n\t    if (xs.forEach) return xs.forEach(fn)\n\t    else for (var i = 0; i < xs.length; i++) {\n\t        fn(xs[i], i, xs);\n\t    }\n\t};\n\t\n\tvar Script = exports.Script = function NodeScript (code) {\n\t    if (!(this instanceof Script)) return new Script(code);\n\t    this.code = code;\n\t};\n\t\n\tScript.prototype.runInNewContext = function (context) {\n\t    if (!context) context = {};\n\t    \n\t    var iframe = document.createElement('iframe');\n\t    if (!iframe.style) iframe.style = {};\n\t    iframe.style.display = 'none';\n\t    \n\t    document.body.appendChild(iframe);\n\t    \n\t    var win = iframe.contentWindow;\n\t    \n\t    forEach(Object_keys(context), function (key) {\n\t        win[key] = context[key];\n\t    });\n\t     \n\t    if (!win.eval && win.execScript) {\n\t        // win.eval() magically appears when this is called in IE:\n\t        win.execScript('null');\n\t    }\n\t    \n\t    var res = win.eval(this.code);\n\t    \n\t    forEach(Object_keys(win), function (key) {\n\t        context[key] = win[key];\n\t    });\n\t    \n\t    document.body.removeChild(iframe);\n\t    \n\t    return res;\n\t};\n\t\n\tScript.prototype.runInThisContext = function () {\n\t    return eval(this.code); // maybe...\n\t};\n\t\n\tScript.prototype.runInContext = function (context) {\n\t    // seems to be just runInNewContext on magical context objects which are\n\t    // otherwise indistinguishable from objects except plain old objects\n\t    // for the parameter segfaults node\n\t    return this.runInNewContext(context);\n\t};\n\t\n\tforEach(Object_keys(Script.prototype), function (name) {\n\t    exports[name] = Script[name] = function (code) {\n\t        var s = Script(code);\n\t        return s[name].apply(s, [].slice.call(arguments, 1));\n\t    };\n\t});\n\t\n\texports.createScript = function (code) {\n\t    return exports.Script(code);\n\t};\n\t\n\texports.createContext = Script.createContext = function (context) {\n\t    // not really sure what this one does\n\t    // seems to just make a shallow copy\n\t    var copy = {};\n\t    if(typeof context === 'object') {\n\t        forEach(Object_keys(context), function (key) {\n\t            copy[key] = context[key];\n\t        });\n\t    }\n\t    return copy;\n\t};\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports = function filter (xs, fn) {\n\t    var res = [];\n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (fn(xs[i], i, xs)) res.push(xs[i]);\n\t    }\n\t    return res;\n\t}\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports = function indexOf (xs, x) {\n\t    if (xs.indexOf) return xs.indexOf(x);\n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (x === xs[i]) return i;\n\t    }\n\t    return -1;\n\t}\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, require) {\n\n\tmodule.exports = typeof Array.isArray === 'function'\n\t    ? Array.isArray\n\t    : function (xs) {\n\t        return Object.prototype.toString.call(xs) === '[object Array]'\n\t    }\n\t;\n\t\n\t/*\n\t\n\talternative\n\t\n\tfunction isArray(ar) {\n\t  return ar instanceof Array ||\n\t         Array.isArray(ar) ||\n\t         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n\t}\n\t\n\t*/\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, require) {\n\n\t/*global define:false */\n\t/**\n\t * Copyright 2013 Craig Campbell\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t * http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t *\n\t * Mousetrap is a simple keyboard shortcut library for Javascript with\n\t * no external dependencies\n\t *\n\t * @version 1.4.6\n\t * @url craig.is/killing/mice\n\t */\n\t/**\n\t * mapping of special keycodes to their corresponding keys\n\t *\n\t * everything in this dictionary cannot use keypress events\n\t * so it has to be here to map to the correct keycodes for\n\t * keyup/keydown events\n\t *\n\t * @type {Object}\n\t */\n\tvar _MAP = {\n\t  8: 'backspace',\n\t  9: 'tab',\n\t  13: 'enter',\n\t  16: 'shift',\n\t  17: 'ctrl',\n\t  18: 'alt',\n\t  20: 'capslock',\n\t  27: 'esc',\n\t  32: 'space',\n\t  33: 'pageup',\n\t  34: 'pagedown',\n\t  35: 'end',\n\t  36: 'home',\n\t  37: 'left',\n\t  38: 'up',\n\t  39: 'right',\n\t  40: 'down',\n\t  45: 'ins',\n\t  46: 'del',\n\t  91: 'meta',\n\t  93: 'meta',\n\t  224: 'meta'\n\t},\n\t\n\t    /**\n\t     * mapping for special characters so they can support\n\t     *\n\t     * this dictionary is only used incase you want to bind a\n\t     * keyup or keydown event to one of these keys\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _KEYCODE_MAP = {\n\t      106: '*',\n\t      107: '+',\n\t      109: '-',\n\t      110: '.',\n\t      111 : '/',\n\t      186: ';',\n\t      187: '=',\n\t      188: ',',\n\t      189: '-',\n\t      190: '.',\n\t      191: '/',\n\t      192: '`',\n\t      219: '[',\n\t      220: '\\\\',\n\t      221: ']',\n\t      222: '\\''\n\t    },\n\t\n\t    /**\n\t     * this is a mapping of keys that require shift on a US keypad\n\t     * back to the non shift equivelents\n\t     *\n\t     * this is so you can use keyup events with these keys\n\t     *\n\t     * note that this will only work reliably on US keyboards\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _SHIFT_MAP = {\n\t      '~': '`',\n\t      '!': '1',\n\t      '@': '2',\n\t      '#': '3',\n\t      '$': '4',\n\t      '%': '5',\n\t      '^': '6',\n\t      '&': '7',\n\t      '*': '8',\n\t      '(': '9',\n\t      ')': '0',\n\t      '_': '-',\n\t      '+': '=',\n\t      ':': ';',\n\t      '\\\"': '\\'',\n\t      '<': ',',\n\t      '>': '.',\n\t      '?': '/',\n\t      '|': '\\\\'\n\t    },\n\t\n\t    /**\n\t     * this is a list of special strings you can use to map\n\t     * to modifier keys when you specify your keyboard shortcuts\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _SPECIAL_ALIASES = {\n\t      'option': 'alt',\n\t      'command': 'meta',\n\t      'return': 'enter',\n\t      'escape': 'esc',\n\t      'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n\t    },\n\t\n\t    /**\n\t     * variable to store the flipped version of _MAP from above\n\t     * needed to check if we should use keypress or not when no action\n\t     * is specified\n\t     *\n\t     * @type {Object|undefined}\n\t     */\n\t    _REVERSE_MAP,\n\t\n\t    /**\n\t     * a list of all the callbacks setup via Mousetrap.bind()\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _callbacks = {},\n\t\n\t    /**\n\t     * direct map of string combinations to callbacks used for trigger()\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _directMap = {},\n\t\n\t    /**\n\t     * keeps track of what level each sequence is at since multiple\n\t     * sequences can start out with the same sequence\n\t     *\n\t     * @type {Object}\n\t     */\n\t    _sequenceLevels = {},\n\t\n\t    /**\n\t     * variable to store the setTimeout call\n\t     *\n\t     * @type {null|number}\n\t     */\n\t    _resetTimer,\n\t\n\t    /**\n\t     * temporary state where we will ignore the next keyup\n\t     *\n\t     * @type {boolean|string}\n\t     */\n\t    _ignoreNextKeyup = false,\n\t\n\t    /**\n\t     * temporary state where we will ignore the next keypress\n\t     *\n\t     * @type {boolean}\n\t     */\n\t    _ignoreNextKeypress = false,\n\t\n\t    /**\n\t     * are we currently inside of a sequence?\n\t     * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n\t     *\n\t     * @type {boolean|string}\n\t     */\n\t    _nextExpectedAction = false;\n\t\n\t/**\n\t * loop through the f keys, f1 to f19 and add them to the map\n\t * programatically\n\t */\n\tfor (var i = 1; i < 20; ++i) {\n\t  _MAP[111 + i] = 'f' + i;\n\t}\n\t\n\t/**\n\t * loop through to map numbers on the numeric keypad\n\t */\n\tfor (i = 0; i <= 9; ++i) {\n\t  _MAP[i + 96] = i;\n\t}\n\t\n\t/**\n\t * cross browser add event method\n\t *\n\t * @param {Element|HTMLDocument} object\n\t * @param {string} type\n\t * @param {Function} callback\n\t * @returns void\n\t */\n\tfunction _addEvent(object, type, callback) {\n\t  if (object.addEventListener) {\n\t    object.addEventListener(type, callback, false);\n\t    return;\n\t  }\n\t\n\t  object.attachEvent('on' + type, callback);\n\t}\n\t\n\t/**\n\t * takes the event and returns the key character\n\t *\n\t * @param {Event} e\n\t * @return {string}\n\t */\n\tfunction _characterFromEvent(e) {\n\t\n\t  // for keypress events we should return the character as is\n\t  if (e.type == 'keypress') {\n\t    var character = String.fromCharCode(e.which);\n\t\n\t    // if the shift key is not pressed then it is safe to assume\n\t    // that we want the character to be lowercase.  this means if\n\t    // you accidentally have caps lock on then your key bindings\n\t    // will continue to work\n\t    //\n\t    // the only side effect that might not be desired is if you\n\t    // bind something like 'A' cause you want to trigger an\n\t    // event when capital A is pressed caps lock will no longer\n\t    // trigger the event.  shift+a will though.\n\t    if (!e.shiftKey) {\n\t      character = character.toLowerCase();\n\t    }\n\t\n\t    return character;\n\t  }\n\t\n\t  // for non keypress events the special maps are needed\n\t  if (_MAP[e.which]) {\n\t    return _MAP[e.which];\n\t  }\n\t\n\t  if (_KEYCODE_MAP[e.which]) {\n\t    return _KEYCODE_MAP[e.which];\n\t  }\n\t\n\t  // if it is not in the special map\n\t\n\t  // with keydown and keyup events the character seems to always\n\t  // come in as an uppercase character whether you are pressing shift\n\t  // or not.  we should make sure it is always lowercase for comparisons\n\t  return String.fromCharCode(e.which).toLowerCase();\n\t}\n\t\n\t/**\n\t * checks if two arrays are equal\n\t *\n\t * @param {Array} modifiers1\n\t * @param {Array} modifiers2\n\t * @returns {boolean}\n\t */\n\tfunction _modifiersMatch(modifiers1, modifiers2) {\n\t  return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n\t}\n\t\n\t/**\n\t * resets all sequence counters except for the ones passed in\n\t *\n\t * @param {Object} doNotReset\n\t * @returns void\n\t */\n\tfunction _resetSequences(doNotReset) {\n\t  doNotReset = doNotReset || {};\n\t\n\t  var activeSequences = false,\n\t      key;\n\t\n\t  for (key in _sequenceLevels) {\n\t    if (doNotReset[key]) {\n\t      activeSequences = true;\n\t      continue;\n\t    }\n\t    _sequenceLevels[key] = 0;\n\t  }\n\t\n\t  if (!activeSequences) {\n\t    _nextExpectedAction = false;\n\t  }\n\t}\n\t\n\t/**\n\t * finds all callbacks that match based on the keycode, modifiers,\n\t * and action\n\t *\n\t * @param {string} character\n\t * @param {Array} modifiers\n\t * @param {Event|Object} e\n\t * @param {string=} sequenceName - name of the sequence we are looking for\n\t * @param {string=} combination\n\t * @param {number=} level\n\t * @returns {Array}\n\t */\n\tfunction _getMatches(character, modifiers, e, sequenceName, combination, level) {\n\t  var i,\n\t      callback,\n\t      matches = [],\n\t      action = e.type;\n\t\n\t  // if there are no events related to this keycode\n\t  if (!_callbacks[character]) {\n\t    return [];\n\t  }\n\t\n\t  // if a modifier key is coming up on its own we should allow it\n\t  if (action == 'keyup' && _isModifier(character)) {\n\t    modifiers = [character];\n\t  }\n\t\n\t  // loop through all callbacks for the key that was pressed\n\t  // and see if any of them match\n\t  for (i = 0; i < _callbacks[character].length; ++i) {\n\t    callback = _callbacks[character][i];\n\t\n\t    // if a sequence name is not specified, but this is a sequence at\n\t    // the wrong level then move onto the next match\n\t    if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n\t      continue;\n\t    }\n\t\n\t    // if the action we are looking for doesn't match the action we got\n\t    // then we should keep going\n\t    if (action != callback.action) {\n\t      continue;\n\t    }\n\t\n\t    // if this is a keypress event and the meta key and control key\n\t    // are not pressed that means that we need to only look at the\n\t    // character, otherwise check the modifiers as well\n\t    //\n\t    // chrome will not fire a keypress if meta or control is down\n\t    // safari will fire a keypress if meta or meta+shift is down\n\t    // firefox will fire a keypress if meta or control is down\n\t    if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\t\n\t      // when you bind a combination or sequence a second time it\n\t      // should overwrite the first one.  if a sequenceName or\n\t      // combination is specified in this call it does just that\n\t      //\n\t      // @todo make deleting its own method?\n\t      var deleteCombo = !sequenceName && callback.combo == combination;\n\t      var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n\t      if (deleteCombo || deleteSequence) {\n\t        _callbacks[character].splice(i, 1);\n\t      }\n\t\n\t      matches.push(callback);\n\t    }\n\t  }\n\t\n\t  return matches;\n\t}\n\t\n\t/**\n\t * takes a key event and figures out what the modifiers are\n\t *\n\t * @param {Event} e\n\t * @returns {Array}\n\t */\n\tfunction _eventModifiers(e) {\n\t  var modifiers = [];\n\t\n\t  if (e.shiftKey) {\n\t    modifiers.push('shift');\n\t  }\n\t\n\t  if (e.altKey) {\n\t    modifiers.push('alt');\n\t  }\n\t\n\t  if (e.ctrlKey) {\n\t    modifiers.push('ctrl');\n\t  }\n\t\n\t  if (e.metaKey) {\n\t    modifiers.push('meta');\n\t  }\n\t\n\t  return modifiers;\n\t}\n\t\n\t/**\n\t * prevents default for this event\n\t *\n\t * @param {Event} e\n\t * @returns void\n\t */\n\tfunction _preventDefault(e) {\n\t  if (e.preventDefault) {\n\t    e.preventDefault();\n\t    return;\n\t  }\n\t\n\t  e.returnValue = false;\n\t}\n\t\n\t/**\n\t * stops propogation for this event\n\t *\n\t * @param {Event} e\n\t * @returns void\n\t */\n\tfunction _stopPropagation(e) {\n\t  if (e.stopPropagation) {\n\t    e.stopPropagation();\n\t    return;\n\t  }\n\t\n\t  e.cancelBubble = true;\n\t}\n\t\n\t/**\n\t * actually calls the callback function\n\t *\n\t * if your callback function returns false this will use the jquery\n\t * convention - prevent default and stop propogation on the event\n\t *\n\t * @param {Function} callback\n\t * @param {Event} e\n\t * @returns void\n\t */\n\tfunction _fireCallback(callback, e, combo, sequence) {\n\t\n\t  // if this event should not happen stop here\n\t  if (Mousetrap.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n\t    return;\n\t  }\n\t\n\t  if (callback(e, combo) === false) {\n\t    _preventDefault(e);\n\t    _stopPropagation(e);\n\t  }\n\t}\n\t\n\t/**\n\t * handles a character key event\n\t *\n\t * @param {string} character\n\t * @param {Array} modifiers\n\t * @param {Event} e\n\t * @returns void\n\t */\n\tfunction _handleKey(character, modifiers, e) {\n\t  var callbacks = _getMatches(character, modifiers, e),\n\t      i,\n\t      doNotReset = {},\n\t      maxLevel = 0,\n\t      processedSequenceCallback = false;\n\t\n\t  // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n\t  for (i = 0; i < callbacks.length; ++i) {\n\t    if (callbacks[i].seq) {\n\t      maxLevel = Math.max(maxLevel, callbacks[i].level);\n\t    }\n\t  }\n\t\n\t  // loop through matching callbacks for this key event\n\t  for (i = 0; i < callbacks.length; ++i) {\n\t\n\t    // fire for all sequence callbacks\n\t    // this is because if for example you have multiple sequences\n\t    // bound such as \"g i\" and \"g t\" they both need to fire the\n\t    // callback for matching g cause otherwise you can only ever\n\t    // match the first one\n\t    if (callbacks[i].seq) {\n\t\n\t      // only fire callbacks for the maxLevel to prevent\n\t      // subsequences from also firing\n\t      //\n\t      // for example 'a option b' should not cause 'option b' to fire\n\t      // even though 'option b' is part of the other sequence\n\t      //\n\t      // any sequences that do not match here will be discarded\n\t      // below by the _resetSequences call\n\t      if (callbacks[i].level != maxLevel) {\n\t        continue;\n\t      }\n\t\n\t      processedSequenceCallback = true;\n\t\n\t      // keep a list of which sequences were matches for later\n\t      doNotReset[callbacks[i].seq] = 1;\n\t      _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n\t      continue;\n\t    }\n\t\n\t    // if there were no sequence matches but we are still here\n\t    // that means this is a regular match so we should fire that\n\t    if (!processedSequenceCallback) {\n\t      _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n\t    }\n\t  }\n\t\n\t  // if the key you pressed matches the type of sequence without\n\t  // being a modifier (ie \"keyup\" or \"keypress\") then we should\n\t  // reset all sequences that were not matched by this event\n\t  //\n\t  // this is so, for example, if you have the sequence \"h a t\" and you\n\t  // type \"h e a r t\" it does not match.  in this case the \"e\" will\n\t  // cause the sequence to reset\n\t  //\n\t  // modifier keys are ignored because you can have a sequence\n\t  // that contains modifiers such as \"enter ctrl+space\" and in most\n\t  // cases the modifier key will be pressed before the next key\n\t  //\n\t  // also if you have a sequence such as \"ctrl+b a\" then pressing the\n\t  // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n\t  //\n\t  // the \"keydown\" is expected when there is a modifier, but the\n\t  // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n\t  // after and that causes the sequence to reset\n\t  //\n\t  // we ignore keypresses in a sequence that directly follow a keydown\n\t  // for the same character\n\t  var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n\t  if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n\t    _resetSequences(doNotReset);\n\t  }\n\t\n\t  _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n\t}\n\t\n\t/**\n\t * handles a keydown event\n\t *\n\t * @param {Event} e\n\t * @returns void\n\t */\n\tfunction _handleKeyEvent(e) {\n\t\n\t  // normalize e.which for key events\n\t  // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n\t  if (typeof e.which !== 'number') {\n\t    e.which = e.keyCode;\n\t  }\n\t\n\t  var character = _characterFromEvent(e);\n\t\n\t  // no character found then stop\n\t  if (!character) {\n\t    return;\n\t  }\n\t\n\t  // need to use === for the character check because the character can be 0\n\t  if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n\t    _ignoreNextKeyup = false;\n\t    return;\n\t  }\n\t\n\t  Mousetrap.handleKey(character, _eventModifiers(e), e);\n\t}\n\t\n\t/**\n\t * determines if the keycode specified is a modifier key or not\n\t *\n\t * @param {string} key\n\t * @returns {boolean}\n\t */\n\tfunction _isModifier(key) {\n\t  return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n\t}\n\t\n\t/**\n\t * called to set a 1 second timeout on the specified sequence\n\t *\n\t * this is so after each key press in the sequence you have 1 second\n\t * to press the next key before you have to start over\n\t *\n\t * @returns void\n\t */\n\tfunction _resetSequenceTimer() {\n\t  clearTimeout(_resetTimer);\n\t  _resetTimer = setTimeout(_resetSequences, 1000);\n\t}\n\t\n\t/**\n\t * reverses the map lookup so that we can look for specific keys\n\t * to see what can and can't use keypress\n\t *\n\t * @return {Object}\n\t */\n\tfunction _getReverseMap() {\n\t  if (!_REVERSE_MAP) {\n\t    _REVERSE_MAP = {};\n\t    for (var key in _MAP) {\n\t\n\t      // pull out the numeric keypad from here cause keypress should\n\t      // be able to detect the keys from the character\n\t      if (key > 95 && key < 112) {\n\t        continue;\n\t      }\n\t\n\t      if (_MAP.hasOwnProperty(key)) {\n\t        _REVERSE_MAP[_MAP[key]] = key;\n\t      }\n\t    }\n\t  }\n\t  return _REVERSE_MAP;\n\t}\n\t\n\t/**\n\t * picks the best action based on the key combination\n\t *\n\t * @param {string} key - character for key\n\t * @param {Array} modifiers\n\t * @param {string=} action passed in\n\t */\n\tfunction _pickBestAction(key, modifiers, action) {\n\t\n\t  // if no action was picked in we should try to pick the one\n\t  // that we think would work best for this key\n\t  if (!action) {\n\t    action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n\t  }\n\t\n\t  // modifier keys don't work as expected with keypress,\n\t  // switch to keydown\n\t  if (action == 'keypress' && modifiers.length) {\n\t    action = 'keydown';\n\t  }\n\t\n\t  return action;\n\t}\n\t\n\t/**\n\t * binds a key sequence to an event\n\t *\n\t * @param {string} combo - combo specified in bind call\n\t * @param {Array} keys\n\t * @param {Function} callback\n\t * @param {string=} action\n\t * @returns void\n\t */\n\tfunction _bindSequence(combo, keys, callback, action) {\n\t\n\t  // start off by adding a sequence level record for this combination\n\t  // and setting the level to 0\n\t  _sequenceLevels[combo] = 0;\n\t\n\t  /**\n\t   * callback to increase the sequence level for this sequence and reset\n\t   * all other sequences that were active\n\t   *\n\t   * @param {string} nextAction\n\t   * @returns {Function}\n\t   */\n\t  function _increaseSequence(nextAction) {\n\t    return function() {\n\t      _nextExpectedAction = nextAction;\n\t      ++_sequenceLevels[combo];\n\t      _resetSequenceTimer();\n\t    };\n\t  }\n\t\n\t  /**\n\t   * wraps the specified callback inside of another function in order\n\t   * to reset all sequence counters as soon as this sequence is done\n\t   *\n\t   * @param {Event} e\n\t   * @returns void\n\t   */\n\t  function _callbackAndReset(e) {\n\t    _fireCallback(callback, e, combo);\n\t\n\t    // we should ignore the next key up if the action is key down\n\t    // or keypress.  this is so if you finish a sequence and\n\t    // release the key the final key will not trigger a keyup\n\t    if (action !== 'keyup') {\n\t      _ignoreNextKeyup = _characterFromEvent(e);\n\t    }\n\t\n\t    // weird race condition if a sequence ends with the key\n\t    // another sequence begins with\n\t    setTimeout(_resetSequences, 10);\n\t  }\n\t\n\t  // loop through keys one at a time and bind the appropriate callback\n\t  // function.  for any key leading up to the final one it should\n\t  // increase the sequence. after the final, it should reset all sequences\n\t  //\n\t  // if an action is specified in the original bind call then that will\n\t  // be used throughout.  otherwise we will pass the action that the\n\t  // next key in the sequence should match.  this allows a sequence\n\t  // to mix and match keypress and keydown events depending on which\n\t  // ones are better suited to the key provided\n\t  for (var i = 0; i < keys.length; ++i) {\n\t    var isFinal = i + 1 === keys.length;\n\t    var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n\t    _bindSingle(keys[i], wrappedCallback, action, combo, i);\n\t  }\n\t}\n\t\n\t/**\n\t * Converts from a string key combination to an array\n\t *\n\t * @param  {string} combination like \"command+shift+l\"\n\t * @return {Array}\n\t */\n\tfunction _keysFromString(combination) {\n\t  if (combination === '+') {\n\t    return ['+'];\n\t  }\n\t\n\t  return combination.split('+');\n\t}\n\t\n\t/**\n\t * Gets info for a specific key combination\n\t *\n\t * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n\t * @param  {string=} action\n\t * @returns {Object}\n\t */\n\tfunction _getKeyInfo(combination, action) {\n\t  var keys,\n\t      key,\n\t      i,\n\t      modifiers = [];\n\t\n\t  // take the keys from this pattern and figure out what the actual\n\t  // pattern is all about\n\t  keys = _keysFromString(combination);\n\t\n\t  for (i = 0; i < keys.length; ++i) {\n\t    key = keys[i];\n\t\n\t    // normalize key names\n\t    if (_SPECIAL_ALIASES[key]) {\n\t      key = _SPECIAL_ALIASES[key];\n\t    }\n\t\n\t    // if this is not a keypress event then we should\n\t    // be smart about using shift keys\n\t    // this will only work for US keyboards however\n\t    if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n\t      key = _SHIFT_MAP[key];\n\t      modifiers.push('shift');\n\t    }\n\t\n\t    // if this key is a modifier then add it to the list of modifiers\n\t    if (_isModifier(key)) {\n\t      modifiers.push(key);\n\t    }\n\t  }\n\t\n\t  // depending on what the key combination is\n\t  // we will try to pick the best event for it\n\t  action = _pickBestAction(key, modifiers, action);\n\t\n\t  return {\n\t    key: key,\n\t    modifiers: modifiers,\n\t    action: action\n\t  };\n\t}\n\t\n\t/**\n\t * binds a single keyboard combination\n\t *\n\t * @param {string} combination\n\t * @param {Function} callback\n\t * @param {string=} action\n\t * @param {string=} sequenceName - name of sequence if part of sequence\n\t * @param {number=} level - what part of the sequence the command is\n\t * @returns void\n\t */\n\tfunction _bindSingle(combination, callback, action, sequenceName, level) {\n\t\n\t  // store a direct mapped reference for use with Mousetrap.trigger\n\t  _directMap[combination + ':' + action] = callback;\n\t\n\t  // make sure multiple spaces in a row become a single space\n\t  combination = combination.replace(/\\s+/g, ' ');\n\t\n\t  var sequence = combination.split(' '),\n\t      info;\n\t\n\t  // if this pattern is a sequence of keys then run through this method\n\t  // to reprocess each pattern one key at a time\n\t  if (sequence.length > 1) {\n\t    _bindSequence(combination, sequence, callback, action);\n\t    return;\n\t  }\n\t\n\t  info = _getKeyInfo(combination, action);\n\t\n\t  // make sure to initialize array if this is the first time\n\t  // a callback is added for this key\n\t  _callbacks[info.key] = _callbacks[info.key] || [];\n\t\n\t  // remove an existing match if there is one\n\t  _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\t\n\t  // add this call back to the array\n\t  // if it is a sequence put it at the beginning\n\t  // if not put it at the end\n\t  //\n\t  // this is important because the way these are processed expects\n\t  // the sequence ones to come first\n\t  _callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n\t    callback: callback,\n\t    modifiers: info.modifiers,\n\t    action: info.action,\n\t    seq: sequenceName,\n\t    level: level,\n\t    combo: combination\n\t  });\n\t}\n\t\n\t/**\n\t * binds multiple combinations to the same callback\n\t *\n\t * @param {Array} combinations\n\t * @param {Function} callback\n\t * @param {string|undefined} action\n\t * @returns void\n\t */\n\tfunction _bindMultiple(combinations, callback, action) {\n\t  for (var i = 0; i < combinations.length; ++i) {\n\t    _bindSingle(combinations[i], callback, action);\n\t  }\n\t}\n\t\n\t// start!\n\t_addEvent(document, 'keypress', _handleKeyEvent);\n\t_addEvent(document, 'keydown', _handleKeyEvent);\n\t_addEvent(document, 'keyup', _handleKeyEvent);\n\t\n\tvar Mousetrap = {\n\t\n\t  /**\n\t   * binds an event to mousetrap\n\t   *\n\t   * can be a single key, a combination of keys separated with +,\n\t   * an array of keys, or a sequence of keys separated by spaces\n\t   *\n\t   * be sure to list the modifier keys first to make sure that the\n\t   * correct key ends up getting bound (the last key in the pattern)\n\t   *\n\t   * @param {string|Array} keys\n\t   * @param {Function} callback\n\t   * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n\t   * @returns void\n\t   */\n\t  bind: function(keys, callback, action) {\n\t    keys = keys instanceof Array ? keys : [keys];\n\t    _bindMultiple(keys, callback, action);\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * unbinds an event to mousetrap\n\t   *\n\t   * the unbinding sets the callback function of the specified key combo\n\t   * to an empty function and deletes the corresponding key in the\n\t   * _directMap dict.\n\t   *\n\t   * TODO: actually remove this from the _callbacks dictionary instead\n\t   * of binding an empty function\n\t   *\n\t   * the keycombo+action has to be exactly the same as\n\t   * it was defined in the bind method\n\t   *\n\t   * @param {string|Array} keys\n\t   * @param {string} action\n\t   * @returns void\n\t   */\n\t  unbind: function(keys, action) {\n\t    return Mousetrap.bind(keys, function() {}, action);\n\t  },\n\t\n\t  /**\n\t   * triggers an event that has already been bound\n\t   *\n\t   * @param {string} keys\n\t   * @param {string=} action\n\t   * @returns void\n\t   */\n\t  trigger: function(keys, action) {\n\t    if (_directMap[keys + ':' + action]) {\n\t      _directMap[keys + ':' + action]({}, keys);\n\t    }\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * resets the library back to its initial state.  this is useful\n\t   * if you want to clear out the current keyboard shortcuts and bind\n\t   * new ones - for example if you switch to another page\n\t   *\n\t   * @returns void\n\t   */\n\t  reset: function() {\n\t    _callbacks = {};\n\t    _directMap = {};\n\t    return this;\n\t  },\n\t\n\t  /**\n\t   * should we stop this event before firing off callbacks\n\t   *\n\t   * @param {Event} e\n\t   * @param {Element} element\n\t   * @return {boolean}\n\t   */\n\t  stopCallback: function(e, element) {\n\t\n\t    // if the element has the class \"mousetrap\" then no need to stop\n\t    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n\t      return false;\n\t    }\n\t\n\t    // stop for input, select, and textarea\n\t    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n\t  },\n\t\n\t  /**\n\t   * exposes _handleKey publicly so it can be overwritten by extensions\n\t   */\n\t  handleKey: _handleKey\n\t};\n\t\n\tmodule.exports = Mousetrap;\n\n\n/***/ }\n/******/ ])","\n// The module cache\nvar installedModules = {};\n\n// The require function\nfunction require(moduleId) {\n\t// Check if module is in cache\n\tif(installedModules[moduleId])\n\t\treturn installedModules[moduleId].exports;\n\t\n\t// Create a new module (and put it into the cache)\n\tvar module = installedModules[moduleId] = {\n\t\texports: {},\n\t\tid: moduleId,\n\t\tloaded: false\n\t};\n\t\n\t// Execute the module function\n\tmodules[moduleId].call(module.exports, module, module.exports, require);\n\t\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\t\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n\n// expose the modules object (__webpack_modules__)\nrequire.modules = modules;\n\n// expose the module cache\nrequire.cache = installedModules;\n\n// __webpack_public_path__\nrequire.p = \"build/\";\n\n\n// Load entry module and return exports\nreturn require(0);","\"use strict\";\nvar __moduleName = (void 0);\nwindow.global = window;\nrequire(\"traceur/bin/traceur-runtime\");\nrequire(\"./css/screen.less\");\nvar Deck = require(\"./deck\");\nwindow.deck = new Deck(document.getElementById(\"slides\"), {\n  \"editor\": require(\"./modules/editor\"),\n  \"background\": require(\"./modules/background\"),\n  \"image\": require(\"./modules/image\")\n});\n","window.global = window;\nrequire(\"traceur/bin/traceur-runtime\");\nrequire(\"./css/screen.less\");\nvar Deck = require(\"./deck\");\nwindow.deck = new Deck(document.getElementById(\"slides\"), {\n  \"editor\": require(\"./modules/editor\"),\n  \"background\": require(\"./modules/background\"),\n  \"image\": require(\"./modules/image\")\n});\n","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function addStyle(cssCode) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = cssCode;\r\n\t} else {\r\n\t\tstyleElement.appendChild(document.createTextNode(cssCode));\r\n\t}\r\n\tvar head = document.getElementsByTagName(\"head\")[0];\r\n\thead.appendChild(styleElement);\r\n\treturn function() {\r\n\t\thead.removeChild(styleElement);\r\n\t};\r\n}","\"use strict\";\nvar __moduleName = (void 0);\nvar cachedPrefix = null;\nfunction getPrefix() {\n  if (cachedPrefix)\n    return cachedPrefix;\n  var regex = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/;\n  var elem = document.body;\n  for (var $prop in elem.style) {\n    try {\n      throw undefined;\n    } catch (prop) {\n      prop = $prop;\n      if (regex.test(prop)) {\n        return cachedPrefix = prop.match(regex)[$traceurRuntime.toProperty(0)];\n      }\n    }\n  }\n  if ($traceurRuntime.toProperty(\"WebkitOpacity\") in elem.style) {\n    return cachedPrefix = \"Webkit\";\n  }\n  if ($traceurRuntime.toProperty(\"KhtmlOpacity\") in elem.style) {\n    return cachedPrefix = \"Khtml\";\n  }\n  return cachedPrefix = \"\";\n}\nvar cachedEvents = {};\nfunction vendorPrefix(prop) {\n  if (cachedEvents.hasOwnProperty(prop))\n    return cachedEvents[$traceurRuntime.toProperty(prop)];\n  var vp = getPrefix().toLowerCase();\n  var pp = (vp) ? (vp + prop) : prop.toLowerCase();\n  $traceurRuntime.setProperty(cachedEvents, prop, pp);\n  return pp;\n}\nfunction on(emitter, eventName, handler, context) {\n  handler = context ? handler.bind(context) : handler;\n  emitter.addEventListener(eventName, handler);\n  return handler;\n}\nfunction once(emitter, eventName, handler, context) {\n  handler = context ? handler.bind(context) : handler;\n  var wrapper = function onceHandler(event) {\n    emitter.removeEventListener(eventName, onceHandler);\n    handler(event);\n  };\n  emitter.addEventListener(eventName, wrapper);\n  return wrapper;\n}\nfunction until(emitter, eventName, handler, context) {\n  handler = context ? handler.bind(context) : handler;\n  var wrapper = function untilHandler(event) {\n    if (handler(event))\n      emitter.removeEventListener(eventName, untilHandler);\n  };\n  emitter.addEventListener(eventName, wrapper);\n  return wrapper;\n}\nfunction off(emitter, eventName, handler) {\n  emitter.removeEventListener(eventName, handler);\n}\nmodule.exports = {\n  on: on,\n  once: once,\n  until: until,\n  off: off,\n  vendorPrefix: vendorPrefix\n};\n","// Thanks http://lea.verou.me/2009/02/find-the-vendor-prefix-of-the-current-browser/\nvar cachedPrefix = null;\n\nfunction getPrefix() {\n  if (cachedPrefix) return cachedPrefix;\n  const regex = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/;\n  const elem = document.body;\n  for (let prop in elem.style) {\n    if (regex.test(prop)) {\n      return cachedPrefix = prop.match(regex)[0];\n    }\n  }\n  if (\"WebkitOpacity\" in elem.style) {\n    return cachedPrefix = \"Webkit\";\n  }\n  if (\"KhtmlOpacity\" in elem.style) {\n    return cachedPrefix = \"Khtml\";\n  }\n  return cachedPrefix = \"\";\n}\n\nvar cachedEvents = {};\n\nfunction vendorPrefix(prop) {\n  if (cachedEvents.hasOwnProperty(prop)) return cachedEvents[prop];\n  const vp = getPrefix().toLowerCase();\n  const pp = (vp) ? (vp + prop) : prop.toLowerCase();\n  cachedEvents[prop] = pp;\n  return pp;\n}\n\n// Register to receive events.\nfunction on(emitter, eventName, handler, context) {\n  handler = context ? handler.bind(context) : handler;\n  emitter.addEventListener(eventName, handler);\n  return handler;\n}\n\n// Register to receive one single event.\nfunction once(emitter, eventName, handler, context) {\n  handler = context ? handler.bind(context) : handler;\n  let wrapper = function onceHandler(event) {\n    emitter.removeEventListener(eventName, onceHandler);\n    handler(event);\n  };\n  emitter.addEventListener(eventName, wrapper);\n  return wrapper;\n}\n\n// Register to receive events until the handler function returns true.\nfunction until(emitter, eventName, handler, context) {\n  handler = context ? handler.bind(context) : handler;\n  let wrapper = function untilHandler(event) {\n    if (handler(event))\n      emitter.removeEventListener(eventName, untilHandler);\n  };\n  emitter.addEventListener(eventName, wrapper);\n  return wrapper;\n}\n\n// Unregister an event handler.\nfunction off(emitter, eventName, handler) {\n  emitter.removeEventListener(eventName, handler);\n}\n\nmodule.exports = {\n  on: on, once: once, until: until, off: off, vendorPrefix: vendorPrefix\n};\n","$traceurRuntime.setProperty($__placeholder__0,\n          $__placeholder__1, $__placeholder__2)","var __moduleName = $__placeholder__0;","var events = require(\"events\");\n\nexports = module.exports = new events.EventEmitter();\n\nexports.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nexports.platform = exports.arch = \nexports.execPath = exports.title = 'browser';\nexports.pid = 1;\nexports.browser = true;\nexports.env = {};\nexports.argv = [];\n\nexports.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    exports.cwd = function () { return cwd };\n    exports.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\nexports.exit = exports.kill = \nexports.umask = exports.dlopen = \nexports.uptime = exports.memoryUsage = \nexports.uvCounters = function() {};\nexports.features = {};\n","\"use strict\";\nvar __moduleName = (void 0);\nvar events = require(\"./lib/events\");\nvar mousetrap = require(\"./lib/mousetrap\");\nfunction toArray(indexable) {\n  var out = [],\n      l = indexable.length;\n  {\n    try {\n      throw undefined;\n    } catch ($i) {\n      $i = 0;\n      for (; $i < l; $i++) {\n        try {\n          throw undefined;\n        } catch (i) {\n          i = $i;\n          try {\n            out.push(indexable[$traceurRuntime.toProperty(i)]);\n          } finally {\n            $i = i;\n          }\n        }\n      }\n    }\n  }\n  return out;\n}\nfunction Deck(container, deckModules) {\n  var $__0 = this;\n  var slides = toArray(container.querySelectorAll(\"section\"));\n  this.currentSlide = null;\n  slides.forEach((function(slide) {\n    var children = toArray(slide.childNodes);\n    var container = document.createElement(\"div\");\n    container.classList.add(\"slideContainer\");\n    children.forEach((function(child) {\n      slide.removeChild(child);\n      container.appendChild(child);\n    }));\n    slide.appendChild(container);\n  }));\n  function slideIndex(slide) {\n    return slides.indexOf(slide);\n  }\n  this.deactivateSlide = (function(slide) {\n    if (slide.classList.contains(\"current\")) {\n      slide.classList.add(\"out\");\n      slide.classList.remove(\"current\");\n    }\n    $__0.currentSlide = null;\n  });\n  this.activateSlide = (function(slide) {\n    if (slide.classList.contains(\"out\")) {\n      $__0.cleanupModules(slide);\n      slide.classList.remove(\"out\");\n    }\n    if ($__0.currentSlide !== null)\n      $__0.deactivateSlide(slides[$traceurRuntime.toProperty($__0.currentSlide)]);\n    $__0.currentSlide = slideIndex(slide);\n    $__0.activateModules(slide);\n    slide.classList.add(\"current\");\n    slide.classList.add(\"in\");\n    window.location.hash = \"\" + $__0.currentSlide;\n  });\n  this.nextSlide = (function() {\n    var nextSlide = $__0.currentSlide !== null ? $__0.currentSlide + 1 : 0;\n    if (nextSlide >= slides.length)\n      nextSlide = slides.length - 1;\n    if (nextSlide !== $__0.currentSlide)\n      $__0.activateSlide(slides[$traceurRuntime.toProperty(nextSlide)]);\n  });\n  this.previousSlide = (function() {\n    var prevSlide = $__0.currentSlide !== null ? $__0.currentSlide - 1 : 0;\n    if (prevSlide < 0)\n      prevSlide = 0;\n    if (prevSlide !== $__0.currentSlide)\n      $__0.activateSlide(slides[$traceurRuntime.toProperty(prevSlide)]);\n  });\n  this.initModules = (function(slide) {\n    var slideData = slide.dataset,\n        deckData = container.dataset;\n    var mods = [],\n        mod;\n    for (mod in deckModules) {\n      if (deckModules.hasOwnProperty(mod)) {\n        try {\n          throw undefined;\n        } catch (arg) {\n          arg = slideData.hasOwnProperty(mod) ? slideData[$traceurRuntime.toProperty(mod)] : deckData.hasOwnProperty(mod) ? deckData[$traceurRuntime.toProperty(mod)] : null;\n          if (arg)\n            mods.push(new deckModules[$traceurRuntime.toProperty(mod)](slide, arg));\n        }\n      }\n    }\n    slide._deck_modules = mods;\n  });\n  this.activateModules = (function(slide) {\n    slide._deck_modules.forEach((function(mod) {\n      return mod.activate && mod.activate();\n    }));\n  });\n  this.stabiliseModules = (function(slide) {\n    slide._deck_modules.forEach((function(mod) {\n      return mod.stabilise && mod.stabilise();\n    }));\n  });\n  this.cleanupModules = (function(slide) {\n    slide._deck_modules.forEach((function(mod) {\n      return mod.cleanup && mod.cleanup();\n    }));\n  });\n  this.transitionEnd = (function(e) {\n    var slide = e.target;\n    if (slide.classList.contains(\"out\")) {\n      slide.classList.remove(\"out\");\n      $__0.cleanupModules(slide);\n    } else if (slide.classList.contains(\"in\")) {\n      slide.classList.remove(\"in\");\n      $__0.stabiliseModules(slide);\n    }\n  });\n  slides.forEach(((function(slide) {\n    return $__0.initModules(slide);\n  })).bind(this));\n  events.on(container, events.vendorPrefix(\"TransitionEnd\"), this.transitionEnd, this);\n  this.bind = (function(binding, callback) {\n    mousetrap.bind(binding, callback.bind($__0));\n  });\n  this.bind([\"pageup\", \"left\"], this.previousSlide);\n  this.bind([\"pagedown\", \"space\", \"right\"], this.nextSlide);\n  setTimeout((function() {\n    var match = /^#(\\d+)$/.exec(window.location.hash);\n    if (match) {\n      $__0.activateSlide(slides[$traceurRuntime.toProperty(parseInt(match[$traceurRuntime.toProperty(1)], 10))]);\n    } else {\n      $__0.nextSlide();\n    }\n  }), 1);\n}\nmodule.exports = Deck;\n","/*global setTimeout */\n\nvar events = require(\"./lib/events\");\nvar mousetrap = require(\"./lib/mousetrap\");\n\nfunction toArray(indexable) {\n  const out = [], l = indexable.length;\n  for (let i = 0; i < l; i++) {\n    out.push(indexable[i]);\n  }\n  return out;\n}\n\nfunction Deck(container, deckModules) {\n\n  const slides = toArray(container.querySelectorAll(\"section\"));\n  this.currentSlide = null;\n\n  slides.forEach((slide) => {\n    const children = toArray(slide.childNodes);\n    const container = document.createElement(\"div\");\n    container.classList.add(\"slideContainer\");\n    children.forEach((child) => {\n      slide.removeChild(child);\n      container.appendChild(child);\n    });\n    slide.appendChild(container);\n  });\n\n  function slideIndex(slide) {\n    return slides.indexOf(slide);\n  }\n\n  this.deactivateSlide = (slide) => {\n    if (slide.classList.contains(\"current\")) {\n      slide.classList.add(\"out\");\n      slide.classList.remove(\"current\");\n    }\n    this.currentSlide = null;\n  }\n\n  this.activateSlide = (slide) => {\n    if (slide.classList.contains(\"out\")) {\n      this.cleanupModules(slide);\n      slide.classList.remove(\"out\");\n    }\n    if (this.currentSlide !== null) this.deactivateSlide(slides[this.currentSlide]);\n    this.currentSlide = slideIndex(slide);\n\n    this.activateModules(slide);\n\n    slide.classList.add(\"current\");\n    slide.classList.add(\"in\");\n    window.location.hash = \"\" + this.currentSlide;\n  }\n\n  this.nextSlide = () => {\n    let nextSlide = this.currentSlide !== null ? this.currentSlide + 1 : 0;\n    if (nextSlide >= slides.length) nextSlide = slides.length - 1;\n    if (nextSlide !== this.currentSlide) this.activateSlide(slides[nextSlide]);\n  }\n\n  this.previousSlide = () => {\n    let prevSlide = this.currentSlide !== null ? this.currentSlide - 1 : 0;\n    if (prevSlide < 0) prevSlide = 0;\n    if (prevSlide !== this.currentSlide) this.activateSlide(slides[prevSlide]);\n  }\n\n  this.initModules = (slide) => {\n    let slideData = slide.dataset,\n        deckData = container.dataset;\n    let mods = [], mod;\n    for (mod in deckModules) {\n      if (deckModules.hasOwnProperty(mod)) {\n        let arg = slideData.hasOwnProperty(mod) ? slideData[mod] :\n              deckData.hasOwnProperty(mod) ? deckData[mod] : null;\n        if (arg) mods.push(new deckModules[mod](slide, arg));\n      }\n    }\n    slide._deck_modules = mods;\n  }\n\n  this.activateModules = (slide) => {\n    slide._deck_modules.forEach((mod) => mod.activate && mod.activate());\n  }\n\n  this.stabiliseModules = (slide) => {\n    slide._deck_modules.forEach((mod) => mod.stabilise && mod.stabilise());\n  }\n\n  this.cleanupModules = (slide) => {\n    slide._deck_modules.forEach((mod) => mod.cleanup && mod.cleanup());\n  }\n\n  this.transitionEnd = (e) => {\n    let slide = e.target;\n    if (slide.classList.contains(\"out\")) {\n      slide.classList.remove(\"out\");\n      this.cleanupModules(slide);\n    } else if (slide.classList.contains(\"in\")) {\n      slide.classList.remove(\"in\");\n      this.stabiliseModules(slide);\n    }\n  }\n\n  slides.forEach(((slide) => this.initModules(slide)).bind(this));\n\n  events.on(container, events.vendorPrefix(\"TransitionEnd\"), this.transitionEnd, this);\n\n  this.bind = (binding, callback) => {\n    mousetrap.bind(binding, callback.bind(this));\n  };\n\n  this.bind([\"pageup\", \"left\"], this.previousSlide);\n  this.bind([\"pagedown\", \"space\", \"right\"], this.nextSlide);\n\n  setTimeout(() => {\n    let match = /^#(\\d+)$/.exec(window.location.hash);\n    if (match) {\n      this.activateSlide(slides[parseInt(match[1], 10)]);\n    } else {\n      this.nextSlide();\n    }\n  }, 1);\n\n}\n\nmodule.exports = Deck;\n","\"use strict\";\nvar __moduleName = (void 0);\nfunction minIndent(text) {\n  return text.split(\"\\n\").reduce(function(min, line) {\n    if (line.trim().length === 0)\n      return min;\n    var indent = line.length - line.trimLeft().length;\n    return min === null ? indent : Math.min(min, indent);\n  }, null);\n}\nfunction alignIndents(text) {\n  var indent = minIndent(text);\n  return text.split(\"\\n\").map(function(line) {\n    return line.slice(indent).trimRight();\n  }).join(\"\\n\");\n}\nfunction cleanText(text) {\n  text = alignIndents(text);\n  while (text[$traceurRuntime.toProperty(0)] === \"\\n\")\n    text = text.slice(1);\n  while (text[$traceurRuntime.toProperty(text.length - 1)] === \"\\n\")\n    text = text.slice(0, text.length - 1);\n  return text + \"\\n\";\n}\nmodule.exports = {cleanText: cleanText};\n","function minIndent(text) {\n  return text.split(\"\\n\").reduce(function(min, line) {\n    if (line.trim().length === 0) return min;\n    var indent = line.length - line.trimLeft().length;\n    return min === null ? indent : Math.min(min, indent);\n  }, null);\n}\n\nfunction alignIndents(text) {\n  var indent = minIndent(text);\n  return text.split(\"\\n\").map(function(line) {\n    return line.slice(indent).trimRight();\n  }).join(\"\\n\");\n}\n\nfunction cleanText(text) {\n  text = alignIndents(text);\n  while (text[0] === \"\\n\") text = text.slice(1);\n  while (text[text.length-1] === \"\\n\") text = text.slice(0, text.length - 1);\n  return text + \"\\n\";\n}\n\nmodule.exports = { cleanText: cleanText };\n","\"use strict\";\nvar __moduleName = (void 0);\nvar events = require(\"../lib/events\");\nfunction Background(slide, url) {\n  var $__0 = this;\n  var preload = document.createElement(\"img\");\n  preload.src = url;\n  this.activate = (function() {\n    if ($__0.background)\n      $__0.background.parentNode.removeChild($__0.background);\n    $__0.background = document.createElement(\"div\");\n    $__0.background.classList.add(\"background\");\n    $__0.background.style.backgroundImage = \"url(\" + url + \")\";\n    slide.parentNode.appendChild($__0.background);\n    setTimeout(((function() {\n      $__0.background.classList.add(\"active\");\n    })).bind($__0), 1);\n  });\n  this.cleanup = (function() {\n    events.once($__0.background, events.vendorPrefix(\"TransitionEnd\"), (function() {\n      $__0.background.parentNode.removeChild($__0.background);\n      $__0.background = null;\n    }), $__0);\n    $__0.background.classList.remove(\"active\");\n  });\n}\nmodule.exports = Background;\n","/*global setTimeout */\n\nvar events = require(\"../lib/events\");\n\nfunction Background(slide, url) {\n\n  const preload = document.createElement(\"img\");\n  preload.src = url;\n\n  // --- activate\n\n  this.activate = () => {\n    if (this.background) this.background.parentNode.removeChild(this.background);\n    this.background = document.createElement(\"div\");\n    this.background.classList.add(\"background\");\n    this.background.style.backgroundImage = \"url(\" + url + \")\";\n    slide.parentNode.appendChild(this.background);\n    setTimeout((() => {\n      this.background.classList.add(\"active\");\n    }).bind(this), 1);\n  }\n\n  // --- cleanup\n\n  this.cleanup = () => {\n    events.once(this.background, events.vendorPrefix(\"TransitionEnd\"), () => {\n      this.background.parentNode.removeChild(this.background);\n      this.background = null;\n    }, this);\n    this.background.classList.remove(\"active\");\n  }\n\n}\n\nmodule.exports = Background;\n","\"use strict\";\nvar __moduleName = (void 0);\nrequire(\"codemirror/lib/codemirror.js\");\nrequire(\"codemirror/lib/codemirror.css\");\nrequire(\"codemirror/addon/edit/matchbrackets.js\");\nrequire(\"codemirror/addon/edit/closebrackets.js\");\nrequire(\"codemirror/addon/hint/show-hint.js\");\nrequire(\"codemirror/addon/hint/show-hint.css\");\nrequire(\"codemirror/addon/hint/javascript-hint.js\");\nrequire(\"codemirror/addon/hint/anyword-hint.js\");\nrequire(\"codemirror/addon/search/match-highlighter.js\");\nrequire(\"codemirror/addon/lint/lint.js\");\nrequire(\"codemirror/addon/lint/lint.css\");\nrequire(\"codemirror/addon/selection/active-line.js\");\nrequire(\"codemirror/mode/javascript/javascript.js\");\nrequire(\"codemirror/theme/xq-light.css\");\nvar CodeMirror = window.CodeMirror;\nvar events = require(\"../lib/events\");\nvar text = require(\"../lib/text\");\nvar emacs = require(\"./editor/emacs\");\nvar Spinner = require(\"spin.js\");\nfunction Editor(slide, mode) {\n  var $__0 = this;\n  var args = slide.dataset;\n  var target = slide.querySelector(\".slideContainer\");\n  var initialCode = target.innerHTML;\n  var keymap = {};\n  $traceurRuntime.setProperty(keymap, \"Ctrl-Space\", (function() {\n    console.log(arguments);\n    this.send({key: \"Ctrl-Space\"});\n  }).bind(this));\n  $traceurRuntime.setProperty(keymap, \"Ctrl-K\", emacs.kill);\n  $traceurRuntime.setProperty(keymap, \"Ctrl-Y\", emacs.yank);\n  keymap.Tab = (function(cm) {\n    return cm.indentLine(cm.getDoc().getCursor().line);\n  });\n  $traceurRuntime.setProperty(keymap, \"Ctrl-\\\\\", (function(cm) {\n    return CodeMirror.showHint(cm);\n  }));\n  keymap.Esc = (function(cm) {\n    var input = document.createElement(\"input\");\n    input.setAttribute(\"type\", \"text\");\n    document.body.appendChild(input);\n    input.focus();\n    input.parentNode.removeChild(input);\n  });\n  var options = {\n    value: text.cleanText(initialCode),\n    mode: mode,\n    extraKeys: keymap,\n    lineWrapping: true,\n    matchBrackets: true,\n    autoCloseBrackets: true,\n    styleActiveLine: true,\n    theme: \"xq-light\"\n  };\n  this.send = (function(message) {\n    $__0.targetFrame.contentWindow.postMessage(JSON.stringify(message), \"*\");\n  });\n  this.activate = (function() {\n    slide.classList.add(\"editor\");\n    target.innerHTML = \"\";\n    $__0.editorFrame = document.createElement(\"div\");\n    $__0.editorFrame.classList.add(\"editorFrame\");\n    target.appendChild($__0.editorFrame);\n    $__0.targetContainer = document.createElement(\"div\");\n    $__0.targetContainer.classList.add(\"targetFrame\");\n    $__0.targetFrame = document.createElement(\"iframe\");\n    $__0.loaderFrame = document.createElement(\"div\");\n    $__0.loaderFrame.classList.add(\"loaderFrame\");\n    $__0.targetContainer.appendChild($__0.loaderFrame);\n    target.appendChild($__0.targetContainer);\n    var factor = Math.min($__0.loaderFrame.clientWidth, $__0.loaderFrame.clientHeight) / 13.25;\n    $__0.spinner = new Spinner({\n      color: \"white\",\n      shadow: true,\n      hwaccel: true,\n      length: factor * 2,\n      radius: factor * 2,\n      width: factor,\n      trail: 40,\n      lines: 12\n    }).spin($__0.loaderFrame);\n    $__0.cm = CodeMirror($__0.editorFrame, options);\n    $__0.cm.setSize(\"100%\", \"100%\");\n  });\n  this.stabilise = (function() {\n    $__0.targetFrame.style.display = \"none\";\n    $__0.targetFrame.setAttribute(\"src\", args.href);\n    $__0.targetContainer.appendChild($__0.targetFrame);\n    events.until($__0.targetFrame.contentWindow, \"message\", function(e) {\n      if (e.data === \"rdy lol\") {\n        this.spinner.stop();\n        this.targetFrame.style.display = \"\";\n        this.targetContainer.removeChild(this.loaderFrame);\n        this.loaderFrame = this.spinner = null;\n        return true;\n      }\n    }, $__0);\n    $__0.cm.refresh();\n  });\n  this.cleanup = (function() {\n    $__0.cm = null;\n    target.innerHTML = initialCode;\n    target.classList.remove(\"editor\");\n  });\n}\nmodule.exports = Editor;\n","require(\"codemirror/lib/codemirror.js\");\nrequire(\"codemirror/lib/codemirror.css\");\nrequire(\"codemirror/addon/edit/matchbrackets.js\");\nrequire(\"codemirror/addon/edit/closebrackets.js\");\n// require(\"codemirror/addon/comment/comments.js\");\nrequire(\"codemirror/addon/hint/show-hint.js\");\nrequire(\"codemirror/addon/hint/show-hint.css\");\nrequire(\"codemirror/addon/hint/javascript-hint.js\");\nrequire(\"codemirror/addon/hint/anyword-hint.js\");\nrequire(\"codemirror/addon/search/match-highlighter.js\");\nrequire(\"codemirror/addon/lint/lint.js\");\nrequire(\"codemirror/addon/lint/lint.css\");\nrequire(\"codemirror/addon/selection/active-line.js\");\nrequire(\"codemirror/mode/javascript/javascript.js\");\nrequire(\"codemirror/theme/xq-light.css\");\n\nlet CodeMirror = window.CodeMirror; // :(\n\nvar events = require(\"../lib/events\");\nvar text = require(\"../lib/text\");\nvar emacs = require(\"./editor/emacs\");\nvar Spinner = require(\"spin.js\");\n\nfunction Editor(slide, mode) {\n  const args = slide.dataset;\n  const target = slide.querySelector(\".slideContainer\");\n  const initialCode = target.innerHTML;\n\n  // --- keybindings\n\n  const keymap = {};\n  keymap[\"Ctrl-Space\"] = (function() {\n    console.log(arguments);\n    this.send({key: \"Ctrl-Space\"});\n  }).bind(this);\n  keymap[\"Ctrl-K\"] = emacs.kill;\n  keymap[\"Ctrl-Y\"] = emacs.yank;\n  keymap.Tab = (cm) => cm.indentLine(cm.getDoc().getCursor().line);\n  keymap[\"Ctrl-\\\\\"] = (cm) => CodeMirror.showHint(cm);\n  keymap.Esc = (cm) => {\n    // wow, much hack\n    const input = document.createElement(\"input\");\n    input.setAttribute(\"type\", \"text\");\n    document.body.appendChild(input);\n    input.focus();\n    input.parentNode.removeChild(input);\n  };\n\n  // --- CodeMirror config\n\n  const options = {\n    value: text.cleanText(initialCode),\n    mode: mode,\n    extraKeys: keymap,\n    lineWrapping: true,\n    matchBrackets: true,\n    autoCloseBrackets: true,\n    styleActiveLine: true,\n    theme: \"xq-light\"\n  };\n\n  this.send = (message) => {\n    this.targetFrame.contentWindow.postMessage(JSON.stringify(message), \"*\");\n  };\n\n  // --- activate\n\n  this.activate = () => {\n    slide.classList.add(\"editor\");\n    target.innerHTML = \"\";\n\n    this.editorFrame = document.createElement(\"div\");\n    this.editorFrame.classList.add(\"editorFrame\");\n    target.appendChild(this.editorFrame);\n\n    this.targetContainer = document.createElement(\"div\");\n    this.targetContainer.classList.add(\"targetFrame\");\n\n    this.targetFrame = document.createElement(\"iframe\");\n\n    this.loaderFrame = document.createElement(\"div\");\n    this.loaderFrame.classList.add(\"loaderFrame\");\n    this.targetContainer.appendChild(this.loaderFrame);\n    target.appendChild(this.targetContainer);\n\n    const factor = Math.min(this.loaderFrame.clientWidth,\n                            this.loaderFrame.clientHeight) / 13.25;\n    this.spinner = new Spinner({\n      color: \"white\",\n      shadow: true,\n      hwaccel: true,\n      length: factor * 2,\n      radius: factor * 2,\n      width: factor,\n      trail: 40,\n      lines: 12\n    }).spin(this.loaderFrame);\n\n    this.cm = CodeMirror(this.editorFrame, options);\n    this.cm.setSize(\"100%\", \"100%\");\n  }\n\n  // --- stabilise\n\n  this.stabilise = () => {\n    this.targetFrame.style.display = \"none\";\n    this.targetFrame.setAttribute(\"src\", args.href);\n    this.targetContainer.appendChild(this.targetFrame);\n    events.until(this.targetFrame.contentWindow, \"message\", function(e) {\n      if (e.data === \"rdy lol\") {\n        this.spinner.stop();\n        this.targetFrame.style.display = \"\";\n        this.targetContainer.removeChild(this.loaderFrame);\n        this.loaderFrame = this.spinner = null;\n        return true;\n      }\n    }, this);\n    this.cm.refresh();\n  }\n\n  // --- cleanup\n\n  this.cleanup = () => {\n    this.cm = null;\n    target.innerHTML = initialCode;\n    target.classList.remove(\"editor\");\n  }\n\n}\n\nmodule.exports = Editor;\n","\"use strict\";\nvar __moduleName = (void 0);\nvar killRing = [];\nfunction addToRing(str) {\n  killRing.push(str);\n  if (killRing.length > 50)\n    killRing.shift();\n}\nfunction growRingTop(str) {\n  var $__0;\n  if (!killRing.length)\n    return addToRing(str);\n  ($__0 = killRing.length - 1, $traceurRuntime.setProperty(killRing, $__0, killRing[$traceurRuntime.toProperty($__0)] + str));\n}\nfunction getFromRing(n) {\n  return killRing[$traceurRuntime.toProperty(killRing.length - (n ? Math.min(n, 1) : 1))] || \"\";\n}\nfunction popFromRing() {\n  if (killRing.length > 1)\n    killRing.pop();\n  return getFromRing();\n}\nvar lastKill = null;\nfunction posEq(a, b) {\n  return a.line == b.line && a.ch == b.ch;\n}\nfunction kill(cm, from, to, mayGrow, text) {\n  if (text == null)\n    text = cm.getRange(from, to);\n  if (mayGrow && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n    growRingTop(text);\n  else\n    addToRing(text);\n  cm.replaceRange(\"\", from, to, \"+delete\");\n  if (mayGrow)\n    lastKill = {\n      cm: cm,\n      pos: from,\n      gen: cm.changeGeneration()\n    };\n  else\n    lastKill = null;\n}\nfunction getPrefix(cm, precise) {\n  var digits = cm.state.emacsPrefix;\n  if (!digits)\n    return precise ? null : 1;\n  clearPrefix(cm);\n  return digits == \"-\" ? -1 : Number(digits);\n}\nvar prefixPreservingKeys = {\n  \"Alt-G\": true,\n  \"Ctrl-X\": true,\n  \"Ctrl-Q\": true,\n  \"Ctrl-U\": true\n};\nfunction maybeClearPrefix(cm, arg) {\n  if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n    clearPrefix(cm);\n}\nfunction clearPrefix(cm) {\n  cm.state.emacsPrefix = null;\n  cm.off(\"keyHandled\", maybeClearPrefix);\n  cm.off(\"inputRead\", maybeDuplicateInput);\n}\nfunction maybeDuplicateInput(cm, event) {\n  var dup = getPrefix(cm);\n  if (dup > 1 && event.origin == \"+input\") {\n    var one = event.text.join(\"\\n\"),\n        txt = \"\";\n    for (var i = 1; i < dup; ++i)\n      txt += one;\n    cm.replaceSelection(txt, \"end\", \"+input\");\n  }\n}\nfunction repeated(cmd) {\n  var f = (typeof cmd === 'undefined' ? 'undefined' : $traceurRuntime.typeof(cmd)) == \"string\" ? function(cm) {\n    cm.execCommand(cmd);\n  } : cmd;\n  return function(cm) {\n    var prefix = getPrefix(cm);\n    f(cm);\n    for (var i = 1; i < prefix; ++i)\n      f(cm);\n  };\n}\nvar killKey = repeated((function(cm) {\n  var start = cm.getCursor(),\n      end = cm.clipPos(CodeMirror.Pos(start.line));\n  var text = cm.getRange(start, end);\n  if (!/\\S/.test(text)) {\n    text += \"\\n\";\n    end = CodeMirror.Pos(start.line + 1, 0);\n  }\n  kill(cm, start, end, true, text);\n}));\nvar yankKey = (function(cm) {\n  var start = cm.getCursor();\n  cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n  cm.setSelection(start, cm.getCursor());\n});\nmodule.exports = {\n  kill: killKey,\n  yank: yankKey\n};\n","/*global CodeMirror */\n\n// Copied from CodeMirror's Emacs keymap:\nvar killRing = [];\nfunction addToRing(str) {\n  killRing.push(str);\n  if (killRing.length > 50) killRing.shift();\n}\nfunction growRingTop(str) {\n  if (!killRing.length) return addToRing(str);\n  killRing[killRing.length - 1] += str;\n}\nfunction getFromRing(n) { return killRing[killRing.length - (n ? Math.min(n, 1) : 1)] || \"\"; }\nfunction popFromRing() { if (killRing.length > 1) killRing.pop(); return getFromRing(); }\n\nvar lastKill = null;\n\nfunction posEq(a, b) { return a.line == b.line && a.ch == b.ch; }\n\nfunction kill(cm, from, to, mayGrow, text) {\n  if (text == null) text = cm.getRange(from, to);\n\n  if (mayGrow && lastKill && lastKill.cm == cm && posEq(from, lastKill.pos) && cm.isClean(lastKill.gen))\n    growRingTop(text);\n  else\n    addToRing(text);\n  cm.replaceRange(\"\", from, to, \"+delete\");\n\n  if (mayGrow) lastKill = {cm: cm, pos: from, gen: cm.changeGeneration()};\n  else lastKill = null;\n}\n\nfunction getPrefix(cm, precise) {\n  var digits = cm.state.emacsPrefix;\n  if (!digits) return precise ? null : 1;\n  clearPrefix(cm);\n  return digits == \"-\" ? -1 : Number(digits);\n}\n\nvar prefixPreservingKeys = {\"Alt-G\": true, \"Ctrl-X\": true, \"Ctrl-Q\": true, \"Ctrl-U\": true};\n\nfunction maybeClearPrefix(cm, arg) {\n  if (!cm.state.emacsPrefixMap && !prefixPreservingKeys.hasOwnProperty(arg))\n    clearPrefix(cm);\n}\n\nfunction clearPrefix(cm) {\n  cm.state.emacsPrefix = null;\n  cm.off(\"keyHandled\", maybeClearPrefix);\n  cm.off(\"inputRead\", maybeDuplicateInput);\n}\n\nfunction maybeDuplicateInput(cm, event) {\n  var dup = getPrefix(cm);\n  if (dup > 1 && event.origin == \"+input\") {\n    var one = event.text.join(\"\\n\"), txt = \"\";\n    for (var i = 1; i < dup; ++i) txt += one;\n    cm.replaceSelection(txt, \"end\", \"+input\");\n  }\n}\n\nfunction repeated(cmd) {\n  var f = typeof cmd == \"string\" ? function(cm) { cm.execCommand(cmd); } : cmd;\n  return function(cm) {\n    var prefix = getPrefix(cm);\n    f(cm);\n    for (var i = 1; i < prefix; ++i) f(cm);\n  };\n}\n\nconst killKey = repeated((cm) => {\n  var start = cm.getCursor(), end = cm.clipPos(CodeMirror.Pos(start.line));\n  var text = cm.getRange(start, end);\n  if (!/\\S/.test(text)) {\n    text += \"\\n\";\n    end = CodeMirror.Pos(start.line + 1, 0);\n  }\n  kill(cm, start, end, true, text);\n});\n\nconst yankKey = (cm) => {\n  var start = cm.getCursor();\n  cm.replaceRange(getFromRing(getPrefix(cm)), start, start, \"paste\");\n  cm.setSelection(start, cm.getCursor());\n};\n\nmodule.exports = {\n  kill: killKey,\n  yank: yankKey\n};\n","\"use strict\";\nvar __moduleName = (void 0);\nfunction Image(slide, url) {\n  slide.style.backgroundImage = \"url(\" + url + \")\";\n}\nmodule.exports = Image;\n","function Image(slide, url) {\n\n  slide.style.backgroundImage = \"url(\" + url + \")\";\n\n}\n\nmodule.exports = Image;\n","(function() {\n  var DEFAULT_BRACKETS = \"()[]{}''\\\"\\\"\";\n  var DEFAULT_EXPLODE_ON_ENTER = \"[]{}\";\n  var SPACE_CHAR_REGEX = /\\s/;\n\n  CodeMirror.defineOption(\"autoCloseBrackets\", false, function(cm, val, old) {\n    if (old != CodeMirror.Init && old)\n      cm.removeKeyMap(\"autoCloseBrackets\");\n    if (!val) return;\n    var pairs = DEFAULT_BRACKETS, explode = DEFAULT_EXPLODE_ON_ENTER;\n    if (typeof val == \"string\") pairs = val;\n    else if (typeof val == \"object\") {\n      if (val.pairs != null) pairs = val.pairs;\n      if (val.explode != null) explode = val.explode;\n    }\n    var map = buildKeymap(pairs);\n    if (explode) map.Enter = buildExplodeHandler(explode);\n    cm.addKeyMap(map);\n  });\n\n  function charsAround(cm, pos) {\n    var str = cm.getRange(CodeMirror.Pos(pos.line, pos.ch - 1),\n                          CodeMirror.Pos(pos.line, pos.ch + 1));\n    return str.length == 2 ? str : null;\n  }\n\n  function buildKeymap(pairs) {\n    var map = {\n      name : \"autoCloseBrackets\",\n      Backspace: function(cm) {\n        if (cm.somethingSelected() || cm.getOption(\"disableInput\")) return CodeMirror.Pass;\n        var cur = cm.getCursor(), around = charsAround(cm, cur);\n        if (around && pairs.indexOf(around) % 2 == 0)\n          cm.replaceRange(\"\", CodeMirror.Pos(cur.line, cur.ch - 1), CodeMirror.Pos(cur.line, cur.ch + 1));\n        else\n          return CodeMirror.Pass;\n      }\n    };\n    var closingBrackets = \"\";\n    for (var i = 0; i < pairs.length; i += 2) (function(left, right) {\n      if (left != right) closingBrackets += right;\n      function surround(cm) {\n        var selection = cm.getSelection();\n        cm.replaceSelection(left + selection + right);\n      }\n      function maybeOverwrite(cm) {\n        var cur = cm.getCursor(), ahead = cm.getRange(cur, CodeMirror.Pos(cur.line, cur.ch + 1));\n        if (ahead != right || cm.somethingSelected()) return CodeMirror.Pass;\n        else cm.execCommand(\"goCharRight\");\n      }\n      map[\"'\" + left + \"'\"] = function(cm) {\n        if (left == \"'\" && cm.getTokenAt(cm.getCursor()).type == \"comment\" ||\n            cm.getOption(\"disableInput\"))\n          return CodeMirror.Pass;\n        if (cm.somethingSelected()) return surround(cm);\n        if (left == right && maybeOverwrite(cm) != CodeMirror.Pass) return;\n        var cur = cm.getCursor(), ahead = CodeMirror.Pos(cur.line, cur.ch + 1);\n        var line = cm.getLine(cur.line), nextChar = line.charAt(cur.ch), curChar = cur.ch > 0 ? line.charAt(cur.ch - 1) : \"\";\n        if (left == right && CodeMirror.isWordChar(curChar))\n          return CodeMirror.Pass;\n        if (line.length == cur.ch || closingBrackets.indexOf(nextChar) >= 0 || SPACE_CHAR_REGEX.test(nextChar))\n          cm.replaceSelection(left + right, {head: ahead, anchor: ahead});\n        else\n          return CodeMirror.Pass;\n      };\n      if (left != right) map[\"'\" + right + \"'\"] = maybeOverwrite;\n    })(pairs.charAt(i), pairs.charAt(i + 1));\n    return map;\n  }\n\n  function buildExplodeHandler(pairs) {\n    return function(cm) {\n      var cur = cm.getCursor(), around = charsAround(cm, cur);\n      if (!around || pairs.indexOf(around) % 2 != 0 || cm.getOption(\"disableInput\"))\n        return CodeMirror.Pass;\n      cm.operation(function() {\n        var newPos = CodeMirror.Pos(cur.line + 1, 0);\n        cm.replaceSelection(\"\\n\\n\", {anchor: newPos, head: newPos}, \"+input\");\n        cm.indentLine(cur.line + 1, null, true);\n        cm.indentLine(cur.line + 2, null, true);\n      });\n    };\n  }\n})();\n","(function() {\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\n    (document.documentMode == null || document.documentMode < 8);\n\n  var Pos = CodeMirror.Pos;\n\n  var matching = {\"(\": \")>\", \")\": \"(<\", \"[\": \"]>\", \"]\": \"[<\", \"{\": \"}>\", \"}\": \"{<\"};\n  function findMatchingBracket(cm, where, strict) {\n    var state = cm.state.matchBrackets;\n    var maxScanLen = (state && state.maxScanLineLength) || 10000;\n    var maxScanLines = (state && state.maxScanLines) || 100;\n\n    var cur = where || cm.getCursor(), line = cm.getLineHandle(cur.line), pos = cur.ch - 1;\n    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\n    if (!match) return null;\n    var forward = match.charAt(1) == \">\", d = forward ? 1 : -1;\n    if (strict && forward != (pos == cur.ch)) return null;\n    var style = cm.getTokenTypeAt(Pos(cur.line, pos + 1));\n\n    var stack = [line.text.charAt(pos)], re = /[(){}[\\]]/;\n    function scan(line, lineNo, start) {\n      if (!line.text) return;\n      var pos = forward ? 0 : line.text.length - 1, end = forward ? line.text.length : -1;\n      if (line.text.length > maxScanLen) return null;\n      if (start != null) pos = start + d;\n      for (; pos != end; pos += d) {\n        var ch = line.text.charAt(pos);\n        if (re.test(ch) && cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style) {\n          var match = matching[ch];\n          if (match.charAt(1) == \">\" == forward) stack.push(ch);\n          else if (stack.pop() != match.charAt(0)) return {pos: pos, match: false};\n          else if (!stack.length) return {pos: pos, match: true};\n        }\n      }\n    }\n    for (var i = cur.line, found, e = forward ? Math.min(i + maxScanLines, cm.lineCount()) : Math.max(-1, i - maxScanLines); i != e; i+=d) {\n      if (i == cur.line) found = scan(line, i, pos);\n      else found = scan(cm.getLineHandle(i), i);\n      if (found) break;\n    }\n    return {from: Pos(cur.line, pos), to: found && Pos(i, found.pos),\n            match: found && found.match, forward: forward};\n  }\n\n  function matchBrackets(cm, autoclear) {\n    // Disable brace matching in long lines, since it'll cause hugely slow updates\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\n    var found = findMatchingBracket(cm);\n    if (!found || cm.getLine(found.from.line).length > maxHighlightLen ||\n       found.to && cm.getLine(found.to.line).length > maxHighlightLen)\n      return;\n\n    var style = found.match ? \"CodeMirror-matchingbracket\" : \"CodeMirror-nonmatchingbracket\";\n    var one = cm.markText(found.from, Pos(found.from.line, found.from.ch + 1), {className: style});\n    var two = found.to && cm.markText(found.to, Pos(found.to.line, found.to.ch + 1), {className: style});\n    // Kludge to work around the IE bug from issue #1193, where text\n    // input stops going to the textarea whenever this fires.\n    if (ie_lt8 && cm.state.focused) cm.display.input.focus();\n    var clear = function() {\n      cm.operation(function() { one.clear(); two && two.clear(); });\n    };\n    if (autoclear) setTimeout(clear, 800);\n    else return clear;\n  }\n\n  var currentlyHighlighted = null;\n  function doMatchBrackets(cm) {\n    cm.operation(function() {\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\n      if (!cm.somethingSelected()) currentlyHighlighted = matchBrackets(cm, false);\n    });\n  }\n\n  CodeMirror.defineOption(\"matchBrackets\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init)\n      cm.off(\"cursorActivity\", doMatchBrackets);\n    if (val) {\n      cm.state.matchBrackets = typeof val == \"object\" ? val : {};\n      cm.on(\"cursorActivity\", doMatchBrackets);\n    }\n  });\n\n  CodeMirror.defineExtension(\"matchBrackets\", function() {matchBrackets(this, true);});\n  CodeMirror.defineExtension(\"findMatchingBracket\", function(pos, strict){\n    return findMatchingBracket(this, pos, strict);\n  });\n})();\n","(function() {\n  \"use strict\";\n\n  var WORD = /[\\w$]+/, RANGE = 500;\n\n  CodeMirror.registerHelper(\"hint\", \"anyword\", function(editor, options) {\n    var word = options && options.word || WORD;\n    var range = options && options.range || RANGE;\n    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\n    var start = cur.ch, end = start;\n    while (end < curLine.length && word.test(curLine.charAt(end))) ++end;\n    while (start && word.test(curLine.charAt(start - 1))) --start;\n    var curWord = start != end && curLine.slice(start, end);\n\n    var list = [], seen = {};\n    var re = new RegExp(word.source, \"g\");\n    for (var dir = -1; dir <= 1; dir += 2) {\n      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\n      for (; line != endLine; line += dir) {\n        var text = editor.getLine(line), m;\n        while (m = re.exec(text)) {\n          if (line == cur.line && m[0] === curWord) continue;\n          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\n            seen[m[0]] = true;\n            list.push(m[0]);\n          }\n        }\n      }\n    }\n    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};\n  });\n})();\n","(function () {\n  var Pos = CodeMirror.Pos;\n\n  function forEach(arr, f) {\n    for (var i = 0, e = arr.length; i < e; ++i) f(arr[i]);\n  }\n\n  function arrayContains(arr, item) {\n    if (!Array.prototype.indexOf) {\n      var i = arr.length;\n      while (i--) {\n        if (arr[i] === item) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return arr.indexOf(item) != -1;\n  }\n\n  function scriptHint(editor, keywords, getToken, options) {\n    // Find the token at the cursor\n    var cur = editor.getCursor(), token = getToken(editor, cur), tprop = token;\n    if (/\\b(?:string|comment)\\b/.test(token.type)) return;\n    token.state = CodeMirror.innerMode(editor.getMode(), token.state).state;\n\n    // If it's not a 'word-style' token, ignore the token.\n    if (!/^[\\w$_]*$/.test(token.string)) {\n      token = tprop = {start: cur.ch, end: cur.ch, string: \"\", state: token.state,\n                       type: token.string == \".\" ? \"property\" : null};\n    }\n    // If it is a property, find out what it is a property of.\n    while (tprop.type == \"property\") {\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (tprop.string != \".\") return;\n      tprop = getToken(editor, Pos(cur.line, tprop.start));\n      if (!context) var context = [];\n      context.push(tprop);\n    }\n    return {list: getCompletions(token, context, keywords, options),\n            from: Pos(cur.line, token.start),\n            to: Pos(cur.line, token.end)};\n  }\n\n  function javascriptHint(editor, options) {\n    return scriptHint(editor, javascriptKeywords,\n                      function (e, cur) {return e.getTokenAt(cur);},\n                      options);\n  };\n  CodeMirror.javascriptHint = javascriptHint; // deprecated\n  CodeMirror.registerHelper(\"hint\", \"javascript\", javascriptHint);\n\n  function getCoffeeScriptToken(editor, cur) {\n  // This getToken, it is for coffeescript, imitates the behavior of\n  // getTokenAt method in javascript.js, that is, returning \"property\"\n  // type and treat \".\" as indepenent token.\n    var token = editor.getTokenAt(cur);\n    if (cur.ch == token.start + 1 && token.string.charAt(0) == '.') {\n      token.end = token.start;\n      token.string = '.';\n      token.type = \"property\";\n    }\n    else if (/^\\.[\\w$_]*$/.test(token.string)) {\n      token.type = \"property\";\n      token.start++;\n      token.string = token.string.replace(/\\./, '');\n    }\n    return token;\n  }\n\n  function coffeescriptHint(editor, options) {\n    return scriptHint(editor, coffeescriptKeywords, getCoffeeScriptToken, options);\n  }\n  CodeMirror.coffeescriptHint = coffeescriptHint; // deprecated\n  CodeMirror.registerHelper(\"hint\", \"coffeescript\", coffeescriptHint);\n\n  var stringProps = (\"charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight \" +\n                     \"toUpperCase toLowerCase split concat match replace search\").split(\" \");\n  var arrayProps = (\"length concat join splice push pop shift unshift slice reverse sort indexOf \" +\n                    \"lastIndexOf every some filter forEach map reduce reduceRight \").split(\" \");\n  var funcProps = \"prototype apply call bind\".split(\" \");\n  var javascriptKeywords = (\"break case catch continue debugger default delete do else false finally for function \" +\n                  \"if in instanceof new null return switch throw true try typeof var void while with\").split(\" \");\n  var coffeescriptKeywords = (\"and break catch class continue delete do else extends false finally for \" +\n                  \"if in instanceof isnt new no not null of off on or return switch then throw true try typeof until void while with yes\").split(\" \");\n\n  function getCompletions(token, context, keywords, options) {\n    var found = [], start = token.string;\n    function maybeAdd(str) {\n      if (str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);\n    }\n    function gatherCompletions(obj) {\n      if (typeof obj == \"string\") forEach(stringProps, maybeAdd);\n      else if (obj instanceof Array) forEach(arrayProps, maybeAdd);\n      else if (obj instanceof Function) forEach(funcProps, maybeAdd);\n      for (var name in obj) maybeAdd(name);\n    }\n\n    if (context && context.length) {\n      // If this is a property, see if it belongs to some object we can\n      // find in the current environment.\n      var obj = context.pop(), base;\n      if (obj.type && obj.type.indexOf(\"variable\") === 0) {\n        if (options && options.additionalContext)\n          base = options.additionalContext[obj.string];\n        base = base || window[obj.string];\n      } else if (obj.type == \"string\") {\n        base = \"\";\n      } else if (obj.type == \"atom\") {\n        base = 1;\n      } else if (obj.type == \"function\") {\n        if (window.jQuery != null && (obj.string == '$' || obj.string == 'jQuery') &&\n            (typeof window.jQuery == 'function'))\n          base = window.jQuery();\n        else if (window._ != null && (obj.string == '_') && (typeof window._ == 'function'))\n          base = window._();\n      }\n      while (base != null && context.length)\n        base = base[context.pop().string];\n      if (base != null) gatherCompletions(base);\n    } else {\n      // If not, just look in the window object and any local scope\n      // (reading into JS mode internals to get at the local and global variables)\n      for (var v = token.state.localVars; v; v = v.next) maybeAdd(v.name);\n      for (var v = token.state.globalVars; v; v = v.next) maybeAdd(v.name);\n      gatherCompletions(window);\n      forEach(keywords, maybeAdd);\n    }\n    return found;\n  }\n})();\n","(function() {\n  \"use strict\";\n\n  var HINT_ELEMENT_CLASS        = \"CodeMirror-hint\";\n  var ACTIVE_HINT_ELEMENT_CLASS = \"CodeMirror-hint-active\";\n\n  CodeMirror.showHint = function(cm, getHints, options) {\n    // We want a single cursor position.\n    if (cm.somethingSelected()) return;\n    if (getHints == null) {\n      if (options && options.async) return;\n      else getHints = CodeMirror.hint.auto;\n    }\n\n    if (cm.state.completionActive) cm.state.completionActive.close();\n\n    var completion = cm.state.completionActive = new Completion(cm, getHints, options || {});\n    CodeMirror.signal(cm, \"startCompletion\", cm);\n    if (completion.options.async)\n      getHints(cm, function(hints) { completion.showHints(hints); }, completion.options);\n    else\n      return completion.showHints(getHints(cm, completion.options));\n  };\n\n  function Completion(cm, getHints, options) {\n    this.cm = cm;\n    this.getHints = getHints;\n    this.options = options;\n    this.widget = this.onClose = null;\n  }\n\n  Completion.prototype = {\n    close: function() {\n      if (!this.active()) return;\n      this.cm.state.completionActive = null;\n\n      if (this.widget) this.widget.close();\n      if (this.onClose) this.onClose();\n      CodeMirror.signal(this.cm, \"endCompletion\", this.cm);\n    },\n\n    active: function() {\n      return this.cm.state.completionActive == this;\n    },\n\n    pick: function(data, i) {\n      var completion = data.list[i];\n      if (completion.hint) completion.hint(this.cm, data, completion);\n      else this.cm.replaceRange(getText(completion), completion.from||data.from, completion.to||data.to);\n      CodeMirror.signal(data, \"pick\", completion);\n      this.close();\n    },\n\n    showHints: function(data) {\n      if (!data || !data.list.length || !this.active()) return this.close();\n\n      if (this.options.completeSingle != false && data.list.length == 1)\n        this.pick(data, 0);\n      else\n        this.showWidget(data);\n    },\n\n    showWidget: function(data) {\n      this.widget = new Widget(this, data);\n      CodeMirror.signal(data, \"shown\");\n\n      var debounce = 0, completion = this, finished;\n      var closeOn = this.options.closeCharacters || /[\\s()\\[\\]{};:>,]/;\n      var startPos = this.cm.getCursor(), startLen = this.cm.getLine(startPos.line).length;\n\n      var requestAnimationFrame = window.requestAnimationFrame || function(fn) {\n        return setTimeout(fn, 1000/60);\n      };\n      var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;\n\n      function done() {\n        if (finished) return;\n        finished = true;\n        completion.close();\n        completion.cm.off(\"cursorActivity\", activity);\n        if (data) CodeMirror.signal(data, \"close\");\n      }\n\n      function update() {\n        if (finished) return;\n        CodeMirror.signal(data, \"update\");\n        if (completion.options.async)\n          completion.getHints(completion.cm, finishUpdate, completion.options);\n        else\n          finishUpdate(completion.getHints(completion.cm, completion.options));\n      }\n      function finishUpdate(data_) {\n        data = data_;\n        if (finished) return;\n        if (!data || !data.list.length) return done();\n        completion.widget = new Widget(completion, data);\n      }\n\n      function clearDebounce() {\n        if (debounce) {\n          cancelAnimationFrame(debounce);\n          debounce = 0;\n        }\n      }\n\n      function activity() {\n        clearDebounce();\n        var pos = completion.cm.getCursor(), line = completion.cm.getLine(pos.line);\n        if (pos.line != startPos.line || line.length - pos.ch != startLen - startPos.ch ||\n            pos.ch < startPos.ch || completion.cm.somethingSelected() ||\n            (pos.ch && closeOn.test(line.charAt(pos.ch - 1)))) {\n          completion.close();\n        } else {\n          debounce = requestAnimationFrame(update);\n          if (completion.widget) completion.widget.close();\n        }\n      }\n      this.cm.on(\"cursorActivity\", activity);\n      this.onClose = done;\n    }\n  };\n\n  function getText(completion) {\n    if (typeof completion == \"string\") return completion;\n    else return completion.text;\n  }\n\n  function buildKeyMap(options, handle) {\n    var baseMap = {\n      Up: function() {handle.moveFocus(-1);},\n      Down: function() {handle.moveFocus(1);},\n      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},\n      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},\n      Home: function() {handle.setFocus(0);},\n      End: function() {handle.setFocus(handle.length - 1);},\n      Enter: handle.pick,\n      Tab: handle.pick,\n      Esc: handle.close\n    };\n    var ourMap = options.customKeys ? {} : baseMap;\n    function addBinding(key, val) {\n      var bound;\n      if (typeof val != \"string\")\n        bound = function(cm) { return val(cm, handle); };\n      // This mechanism is deprecated\n      else if (baseMap.hasOwnProperty(val))\n        bound = baseMap[val];\n      else\n        bound = val;\n      ourMap[key] = bound;\n    }\n    if (options.customKeys)\n      for (var key in options.customKeys) if (options.customKeys.hasOwnProperty(key))\n        addBinding(key, options.customKeys[key]);\n    if (options.extraKeys)\n      for (var key in options.extraKeys) if (options.extraKeys.hasOwnProperty(key))\n        addBinding(key, options.extraKeys[key]);\n    return ourMap;\n  }\n\n  function getHintElement(hintsElement, el) {\n    while (el && el != hintsElement) {\n      if (el.nodeName.toUpperCase() === \"LI\" && el.parentNode == hintsElement) return el;\n      el = el.parentNode;\n    }\n  }\n\n  function Widget(completion, data) {\n    this.completion = completion;\n    this.data = data;\n    var widget = this, cm = completion.cm, options = completion.options;\n\n    var hints = this.hints = document.createElement(\"ul\");\n    hints.className = \"CodeMirror-hints\";\n    this.selectedHint = options.getDefaultSelection ? options.getDefaultSelection(cm,options,data) : 0;\n\n    var completions = data.list;\n    for (var i = 0; i < completions.length; ++i) {\n      var elt = hints.appendChild(document.createElement(\"li\")), cur = completions[i];\n      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? \"\" : \" \" + ACTIVE_HINT_ELEMENT_CLASS);\n      if (cur.className != null) className = cur.className + \" \" + className;\n      elt.className = className;\n      if (cur.render) cur.render(elt, data, cur);\n      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));\n      elt.hintId = i;\n    }\n\n    var pos = cm.cursorCoords(options.alignWithWord !== false ? data.from : null);\n    var left = pos.left, top = pos.bottom, below = true;\n    hints.style.left = left + \"px\";\n    hints.style.top = top + \"px\";\n    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.\n    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);\n    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);\n    (options.container || document.body).appendChild(hints);\n    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;\n    if (overlapY > 0) {\n      var height = box.bottom - box.top, curTop = box.top - (pos.bottom - pos.top);\n      if (curTop - height > 0) { // Fits above cursor\n        hints.style.top = (top = curTop - height) + \"px\";\n        below = false;\n      } else if (height > winH) {\n        hints.style.height = (winH - 5) + \"px\";\n        hints.style.top = (top = pos.bottom - box.top) + \"px\";\n        var cursor = cm.getCursor();\n        if (data.from.ch != cursor.ch) {\n          pos = cm.cursorCoords(cursor);\n          hints.style.left = (left = pos.left) + \"px\";\n          box = hints.getBoundingClientRect();\n        }\n      }\n    }\n    var overlapX = box.left - winW;\n    if (overlapX > 0) {\n      if (box.right - box.left > winW) {\n        hints.style.width = (winW - 5) + \"px\";\n        overlapX -= (box.right - box.left) - winW;\n      }\n      hints.style.left = (left = pos.left - overlapX) + \"px\";\n    }\n\n    cm.addKeyMap(this.keyMap = buildKeyMap(options, {\n      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },\n      setFocus: function(n) { widget.changeActive(n); },\n      menuSize: function() { return widget.screenAmount(); },\n      length: completions.length,\n      close: function() { completion.close(); },\n      pick: function() { widget.pick(); },\n      data: data\n    }));\n\n    if (options.closeOnUnfocus !== false) {\n      var closingOnBlur;\n      cm.on(\"blur\", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });\n      cm.on(\"focus\", this.onFocus = function() { clearTimeout(closingOnBlur); });\n    }\n\n    var startScroll = cm.getScrollInfo();\n    cm.on(\"scroll\", this.onScroll = function() {\n      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();\n      var newTop = top + startScroll.top - curScroll.top;\n      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);\n      if (!below) point += hints.offsetHeight;\n      if (point <= editor.top || point >= editor.bottom) return completion.close();\n      hints.style.top = newTop + \"px\";\n      hints.style.left = (left + startScroll.left - curScroll.left) + \"px\";\n    });\n\n    CodeMirror.on(hints, \"dblclick\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}\n    });\n\n    CodeMirror.on(hints, \"click\", function(e) {\n      var t = getHintElement(hints, e.target || e.srcElement);\n      if (t && t.hintId != null) {\n        widget.changeActive(t.hintId);\n        if (options.completeOnSingleClick) widget.pick();\n      }\n    });\n\n    CodeMirror.on(hints, \"mousedown\", function() {\n      setTimeout(function(){cm.focus();}, 20);\n    });\n\n    CodeMirror.signal(data, \"select\", completions[0], hints.firstChild);\n    return true;\n  }\n\n  Widget.prototype = {\n    close: function() {\n      if (this.completion.widget != this) return;\n      this.completion.widget = null;\n      this.hints.parentNode.removeChild(this.hints);\n      this.completion.cm.removeKeyMap(this.keyMap);\n\n      var cm = this.completion.cm;\n      if (this.completion.options.closeOnUnfocus !== false) {\n        cm.off(\"blur\", this.onBlur);\n        cm.off(\"focus\", this.onFocus);\n      }\n      cm.off(\"scroll\", this.onScroll);\n    },\n\n    pick: function() {\n      this.completion.pick(this.data, this.selectedHint);\n    },\n\n    changeActive: function(i, avoidWrap) {\n      if (i >= this.data.list.length)\n        i = avoidWrap ? this.data.list.length - 1 : 0;\n      else if (i < 0)\n        i = avoidWrap ? 0  : this.data.list.length - 1;\n      if (this.selectedHint == i) return;\n      var node = this.hints.childNodes[this.selectedHint];\n      node.className = node.className.replace(\" \" + ACTIVE_HINT_ELEMENT_CLASS, \"\");\n      node = this.hints.childNodes[this.selectedHint = i];\n      node.className += \" \" + ACTIVE_HINT_ELEMENT_CLASS;\n      if (node.offsetTop < this.hints.scrollTop)\n        this.hints.scrollTop = node.offsetTop - 3;\n      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)\n        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;\n      CodeMirror.signal(this.data, \"select\", this.data.list[this.selectedHint], node);\n    },\n\n    screenAmount: function() {\n      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;\n    }\n  };\n\n  CodeMirror.registerHelper(\"hint\", \"auto\", function(cm, options) {\n    var helpers = cm.getHelpers(cm.getCursor(), \"hint\"), words;\n    if (helpers.length) {\n      for (var i = 0; i < helpers.length; i++) {\n        var cur = helpers[i](cm, options);\n        if (cur && cur.list.length) return cur;\n      }\n    } else if (words = cm.getHelper(cm.getCursor(), \"hintWords\")) {\n      if (words) return CodeMirror.hint.fromList(cm, {words: words});\n    } else if (CodeMirror.hint.anyword) {\n      return CodeMirror.hint.anyword(cm, options);\n    }\n  });\n\n  CodeMirror.registerHelper(\"hint\", \"fromList\", function(cm, options) {\n    var cur = cm.getCursor(), token = cm.getTokenAt(cur);\n    var found = [];\n    for (var i = 0; i < options.words.length; i++) {\n      var word = options.words[i];\n      if (word.slice(0, token.string.length) == token.string)\n        found.push(word);\n    }\n\n    if (found.length) return {\n      list: found,\n      from: CodeMirror.Pos(cur.line, token.start),\n            to: CodeMirror.Pos(cur.line, token.end)\n    };\n  });\n\n  CodeMirror.commands.autocomplete = CodeMirror.showHint;\n})();\n","(function() {\n  \"use strict\";\n  var GUTTER_ID = \"CodeMirror-lint-markers\";\n  var SEVERITIES = /^(?:error|warning)$/;\n\n  function showTooltip(e, content) {\n    var tt = document.createElement(\"div\");\n    tt.className = \"CodeMirror-lint-tooltip\";\n    tt.appendChild(content.cloneNode(true));\n    document.body.appendChild(tt);\n\n    function position(e) {\n      if (!tt.parentNode) return CodeMirror.off(document, \"mousemove\", position);\n      tt.style.top = Math.max(0, e.clientY - tt.offsetHeight - 5) + \"px\";\n      tt.style.left = (e.clientX + 5) + \"px\";\n    }\n    CodeMirror.on(document, \"mousemove\", position);\n    position(e);\n    if (tt.style.opacity != null) tt.style.opacity = 1;\n    return tt;\n  }\n  function rm(elt) {\n    if (elt.parentNode) elt.parentNode.removeChild(elt);\n  }\n  function hideTooltip(tt) {\n    if (!tt.parentNode) return;\n    if (tt.style.opacity == null) rm(tt);\n    tt.style.opacity = 0;\n    setTimeout(function() { rm(tt); }, 600);\n  }\n\n  function showTooltipFor(e, content, node) {\n    var tooltip = showTooltip(e, content);\n    function hide() {\n      CodeMirror.off(node, \"mouseout\", hide);\n      if (tooltip) { hideTooltip(tooltip); tooltip = null; }\n    }\n    var poll = setInterval(function() {\n      if (tooltip) for (var n = node;; n = n.parentNode) {\n        if (n == document.body) return;\n        if (!n) { hide(); break; }\n      }\n      if (!tooltip) return clearInterval(poll);\n    }, 400);\n    CodeMirror.on(node, \"mouseout\", hide);\n  }\n\n  function LintState(cm, options, hasGutter) {\n    this.marked = [];\n    this.options = options;\n    this.timeout = null;\n    this.hasGutter = hasGutter;\n    this.onMouseOver = function(e) { onMouseOver(cm, e); };\n  }\n\n  function parseOptions(cm, options) {\n    if (options instanceof Function) return {getAnnotations: options};\n    if (!options || options === true) options = {};\n    if (!options.getAnnotations) options.getAnnotations = cm.getHelper(CodeMirror.Pos(0, 0), \"lint\");\n    if (!options.getAnnotations) throw new Error(\"Required option 'getAnnotations' missing (lint addon)\");\n    return options;\n  }\n\n  function clearMarks(cm) {\n    var state = cm.state.lint;\n    if (state.hasGutter) cm.clearGutter(GUTTER_ID);\n    for (var i = 0; i < state.marked.length; ++i)\n      state.marked[i].clear();\n    state.marked.length = 0;\n  }\n\n  function makeMarker(labels, severity, multiple, tooltips) {\n    var marker = document.createElement(\"div\"), inner = marker;\n    marker.className = \"CodeMirror-lint-marker-\" + severity;\n    if (multiple) {\n      inner = marker.appendChild(document.createElement(\"div\"));\n      inner.className = \"CodeMirror-lint-marker-multiple\";\n    }\n\n    if (tooltips != false) CodeMirror.on(inner, \"mouseover\", function(e) {\n      showTooltipFor(e, labels, inner);\n    });\n\n    return marker;\n  }\n\n  function getMaxSeverity(a, b) {\n    if (a == \"error\") return a;\n    else return b;\n  }\n\n  function groupByLine(annotations) {\n    var lines = [];\n    for (var i = 0; i < annotations.length; ++i) {\n      var ann = annotations[i], line = ann.from.line;\n      (lines[line] || (lines[line] = [])).push(ann);\n    }\n    return lines;\n  }\n\n  function annotationTooltip(ann) {\n    var severity = ann.severity;\n    if (!SEVERITIES.test(severity)) severity = \"error\";\n    var tip = document.createElement(\"div\");\n    tip.className = \"CodeMirror-lint-message-\" + severity;\n    tip.appendChild(document.createTextNode(ann.message));\n    return tip;\n  }\n\n  function startLinting(cm) {\n    var state = cm.state.lint, options = state.options;\n    if (options.async)\n      options.getAnnotations(cm, updateLinting, options);\n    else\n      updateLinting(cm, options.getAnnotations(cm.getValue(), options.options));\n  }\n\n  function updateLinting(cm, annotationsNotSorted) {\n    clearMarks(cm);\n    var state = cm.state.lint, options = state.options;\n\n    var annotations = groupByLine(annotationsNotSorted);\n\n    for (var line = 0; line < annotations.length; ++line) {\n      var anns = annotations[line];\n      if (!anns) continue;\n\n      var maxSeverity = null;\n      var tipLabel = state.hasGutter && document.createDocumentFragment();\n\n      for (var i = 0; i < anns.length; ++i) {\n        var ann = anns[i];\n        var severity = ann.severity;\n        if (!SEVERITIES.test(severity)) severity = \"error\";\n        maxSeverity = getMaxSeverity(maxSeverity, severity);\n\n        if (options.formatAnnotation) ann = options.formatAnnotation(ann);\n        if (state.hasGutter) tipLabel.appendChild(annotationTooltip(ann));\n\n        if (ann.to) state.marked.push(cm.markText(ann.from, ann.to, {\n          className: \"CodeMirror-lint-mark-\" + severity,\n          __annotation: ann\n        }));\n      }\n\n      if (state.hasGutter)\n        cm.setGutterMarker(line, GUTTER_ID, makeMarker(tipLabel, maxSeverity, anns.length > 1,\n                                                       state.options.tooltips));\n    }\n    if (options.onUpdateLinting) options.onUpdateLinting(annotationsNotSorted, annotations, cm);\n  }\n\n  function onChange(cm) {\n    var state = cm.state.lint;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function(){startLinting(cm);}, state.options.delay || 500);\n  }\n\n  function popupSpanTooltip(ann, e) {\n    var target = e.target || e.srcElement;\n    showTooltipFor(e, annotationTooltip(ann), target);\n  }\n\n  // When the mouseover fires, the cursor might not actually be over\n  // the character itself yet. These pairs of x,y offsets are used to\n  // probe a few nearby points when no suitable marked range is found.\n  var nearby = [0, 0, 0, 5, 0, -5, 5, 0, -5, 0];\n\n  function onMouseOver(cm, e) {\n    if (!/\\bCodeMirror-lint-mark-/.test((e.target || e.srcElement).className)) return;\n    for (var i = 0; i < nearby.length; i += 2) {\n      var spans = cm.findMarksAt(cm.coordsChar({left: e.clientX + nearby[i],\n                                                top: e.clientY + nearby[i + 1]}));\n      for (var j = 0; j < spans.length; ++j) {\n        var span = spans[j], ann = span.__annotation;\n        if (ann) return popupSpanTooltip(ann, e);\n      }\n    }\n  }\n\n  function optionHandler(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      clearMarks(cm);\n      cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getWrapperElement(), \"mouseover\", cm.state.lint.onMouseOver);\n      delete cm.state.lint;\n    }\n\n    if (val) {\n      var gutters = cm.getOption(\"gutters\"), hasLintGutter = false;\n      for (var i = 0; i < gutters.length; ++i) if (gutters[i] == GUTTER_ID) hasLintGutter = true;\n      var state = cm.state.lint = new LintState(cm, parseOptions(cm, val), hasLintGutter);\n      cm.on(\"change\", onChange);\n      if (state.options.tooltips != false)\n        CodeMirror.on(cm.getWrapperElement(), \"mouseover\", state.onMouseOver);\n\n      startLinting(cm);\n    }\n  }\n\n  CodeMirror.defineOption(\"lintWith\", false, optionHandler); // deprecated\n  CodeMirror.defineOption(\"lint\", false, optionHandler); // deprecated\n})();\n","// Highlighting text that matches the selection\n//\n// Defines an option highlightSelectionMatches, which, when enabled,\n// will style strings that match the selection throughout the\n// document.\n//\n// The option can be set to true to simply enable it, or to a\n// {minChars, style, showToken} object to explicitly configure it.\n// minChars is the minimum amount of characters that should be\n// selected for the behavior to occur, and style is the token style to\n// apply to the matches. This will be prefixed by \"cm-\" to create an\n// actual CSS class name. showToken, when enabled, will cause the\n// current token to be highlighted when nothing is selected.\n\n(function() {\n  var DEFAULT_MIN_CHARS = 2;\n  var DEFAULT_TOKEN_STYLE = \"matchhighlight\";\n  var DEFAULT_DELAY = 100;\n\n  function State(options) {\n    if (typeof options == \"object\") {\n      this.minChars = options.minChars;\n      this.style = options.style;\n      this.showToken = options.showToken;\n      this.delay = options.delay;\n    }\n    if (this.style == null) this.style = DEFAULT_TOKEN_STYLE;\n    if (this.minChars == null) this.minChars = DEFAULT_MIN_CHARS;\n    if (this.delay == null) this.delay = DEFAULT_DELAY;\n    this.overlay = this.timeout = null;\n  }\n\n  CodeMirror.defineOption(\"highlightSelectionMatches\", false, function(cm, val, old) {\n    if (old && old != CodeMirror.Init) {\n      var over = cm.state.matchHighlighter.overlay;\n      if (over) cm.removeOverlay(over);\n      clearTimeout(cm.state.matchHighlighter.timeout);\n      cm.state.matchHighlighter = null;\n      cm.off(\"cursorActivity\", cursorActivity);\n    }\n    if (val) {\n      cm.state.matchHighlighter = new State(val);\n      highlightMatches(cm);\n      cm.on(\"cursorActivity\", cursorActivity);\n    }\n  });\n\n  function cursorActivity(cm) {\n    var state = cm.state.matchHighlighter;\n    clearTimeout(state.timeout);\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.delay);\n  }\n\n  function highlightMatches(cm) {\n    cm.operation(function() {\n      var state = cm.state.matchHighlighter;\n      if (state.overlay) {\n        cm.removeOverlay(state.overlay);\n        state.overlay = null;\n      }\n      if (!cm.somethingSelected() && state.showToken) {\n        var re = state.showToken === true ? /[\\w$]/ : state.showToken;\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\n        while (start && re.test(line.charAt(start - 1))) --start;\n        while (end < line.length && re.test(line.charAt(end))) ++end;\n        if (start < end)\n          cm.addOverlay(state.overlay = makeOverlay(line.slice(start, end), re, state.style));\n        return;\n      }\n      if (cm.getCursor(\"head\").line != cm.getCursor(\"anchor\").line) return;\n      var selection = cm.getSelection().replace(/^\\s+|\\s+$/g, \"\");\n      if (selection.length >= state.minChars)\n        cm.addOverlay(state.overlay = makeOverlay(selection, false, state.style));\n    });\n  }\n\n  function boundariesAround(stream, re) {\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\n  }\n\n  function makeOverlay(query, hasBoundary, style) {\n    return {token: function(stream) {\n      if (stream.match(query) &&\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\n        return style;\n      stream.next();\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\n    }};\n  }\n})();\n","// Because sometimes you need to style the cursor's line.\n//\n// Adds an option 'styleActiveLine' which, when enabled, gives the\n// active line's wrapping <div> the CSS class \"CodeMirror-activeline\",\n// and gives its background <div> the class \"CodeMirror-activeline-background\".\n\n(function() {\n  \"use strict\";\n  var WRAP_CLASS = \"CodeMirror-activeline\";\n  var BACK_CLASS = \"CodeMirror-activeline-background\";\n\n  CodeMirror.defineOption(\"styleActiveLine\", false, function(cm, val, old) {\n    var prev = old && old != CodeMirror.Init;\n    if (val && !prev) {\n      updateActiveLine(cm, cm.getCursor().line);\n      cm.on(\"beforeSelectionChange\", selectionChange);\n    } else if (!val && prev) {\n      cm.off(\"beforeSelectionChange\", selectionChange);\n      clearActiveLine(cm);\n      delete cm.state.activeLine;\n    }\n  });\n\n  function clearActiveLine(cm) {\n    if (\"activeLine\" in cm.state) {\n      cm.removeLineClass(cm.state.activeLine, \"wrap\", WRAP_CLASS);\n      cm.removeLineClass(cm.state.activeLine, \"background\", BACK_CLASS);\n    }\n  }\n\n  function updateActiveLine(cm, selectedLine) {\n    var line = cm.getLineHandleVisualStart(selectedLine);\n    if (cm.state.activeLine == line) return;\n    cm.operation(function() {\n      clearActiveLine(cm);\n      cm.addLineClass(line, \"wrap\", WRAP_CLASS);\n      cm.addLineClass(line, \"background\", BACK_CLASS);\n      cm.state.activeLine = line;\n    });\n  }\n\n  function selectionChange(cm, sel) {\n    updateActiveLine(cm, sel.head.line);\n  }\n})();\n","// CodeMirror is the only global var we claim\nwindow.CodeMirror = (function() {\n  \"use strict\";\n\n  // BROWSER SNIFFING\n\n  // Crude, but necessary to handle a number of hard-to-feature-detect\n  // bugs and behavior differences.\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\n  // IE11 currently doesn't count as 'ie', since it has almost none of\n  // the same bugs as earlier versions. Use ie_gt10 to handle\n  // incompatibilities in that version.\n  var old_ie = /MSIE \\d/.test(navigator.userAgent);\n  var ie_lt8 = old_ie && (document.documentMode == null || document.documentMode < 8);\n  var ie_lt9 = old_ie && (document.documentMode == null || document.documentMode < 9);\n  var ie_lt10 = old_ie && (document.documentMode == null || document.documentMode < 10);\n  var ie_gt10 = /Trident\\/([7-9]|\\d{2,})\\./.test(navigator.userAgent);\n  var ie = old_ie || ie_gt10;\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var opera = /Opera\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n  var mac_geLion = /Mac OS X 1\\d\\D([7-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var phantom = /PhantomJS/.test(navigator.userAgent);\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var windows = /win/i.test(navigator.platform);\n\n  var opera_version = opera && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (opera_version) opera_version = Number(opera_version[1]);\n  if (opera_version && opera_version >= 15) { opera = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));\n  var captureMiddleClick = gecko || (ie && !ie_lt9);\n\n  // Optimize some code when these features are not used\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // CONSTRUCTOR\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options || {};\n    // Determine effective options based on given values and defaults.\n    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))\n      options[opt] = defaults[opt];\n    setGuttersForLineNumbers(options);\n\n    var docStart = typeof options.value == \"string\" ? 0 : options.value.first;\n    var display = this.display = makeDisplay(place, docStart);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    if (options.autofocus && !mobile) focusInput(this);\n\n    this.state = {keyMaps: [],\n                  overlays: [],\n                  modeGen: 0,\n                  overwrite: false, focused: false,\n                  suppressEdits: false,\n                  pasteIncoming: false, cutIncoming: false,\n                  draggingText: false,\n                  highlight: new Delayed()};\n\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n\n    var doc = options.value;\n    if (typeof doc == \"string\") doc = new Doc(options.value, options.mode);\n    operation(this, attachDoc)(this, doc);\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (old_ie) setTimeout(bind(resetInput, this, true), 20);\n\n    registerEventHandlers(this);\n    // IE throws unspecified error in certain cases, when\n    // trying to access activeElement before onload\n    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }\n    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);\n    else onBlur(this);\n\n    operation(this, function() {\n      for (var opt in optionHandlers)\n        if (optionHandlers.propertyIsEnumerable(opt))\n          optionHandlers[opt](this, options[opt], Init);\n      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    })();\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  function makeDisplay(place, docStart) {\n    var d = {};\n\n    var input = d.input = elt(\"textarea\", null, null, \"position: absolute; padding: 0; width: 1px; height: 1em; outline: none\");\n    if (webkit) input.style.width = \"1000px\";\n    else input.setAttribute(\"wrap\", \"off\");\n    // if border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) input.style.border = \"1px solid black\";\n    input.setAttribute(\"autocorrect\", \"off\"); input.setAttribute(\"autocapitalize\", \"off\"); input.setAttribute(\"spellcheck\", \"false\");\n\n    // Wraps and hides input textarea\n    d.inputDiv = elt(\"div\", [input], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The actual fake scrollbars.\n    d.scrollbarH = elt(\"div\", [elt(\"div\", null, null, \"height: 1px\")], \"CodeMirror-hscrollbar\");\n    d.scrollbarV = elt(\"div\", [elt(\"div\", null, null, \"width: 1px\")], \"CodeMirror-vscrollbar\");\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    // DIVs containing the selection and the actual code\n    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    // Blinky cursor, and element used to ensure cursor fits at the end of a line\n    d.cursor = elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\");\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    d.otherCursor = elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\");\n    // Used to measure text size\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt(\"div\", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],\n                         null, \"position: relative; outline: none\");\n    // Moved around its parent to cover visible view\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the text, causes scrolling\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerCutOff + \"px; width: 1px;\");\n    // Will contain the gutters, if any\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Provides scrolling\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.inputDiv, d.scrollbarH, d.scrollbarV,\n                            d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n    // Work around IE7 z-index bug\n    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = \"0px\";\n    if (!webkit) d.scroller.draggable = true;\n    // Needed to handle Tab key in KHTML\n    if (khtml) { d.inputDiv.style.height = \"1px\"; d.inputDiv.style.position = \"absolute\"; }\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = \"18px\";\n\n    // Current visible range (may be bigger than the view window).\n    d.viewOffset = d.lastSizeC = 0;\n    d.showingFrom = d.showingTo = docStart;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // See readInput and resetInput\n    d.prevInput = \"\";\n    // Set to true when a non-horizontal-scrolling widget is added. As\n    // an optimization, widget aligning is skipped when d is false.\n    d.alignWidgets = false;\n    // Flag that indicates whether we currently expect input to appear\n    // (after some event like 'keypress' or 'input') and are polling\n    // intensively.\n    d.pollingFast = false;\n    // Self-resetting timeout for the poller\n    d.poll = new Delayed();\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.measureLineCache = [];\n    d.measureLineCachePos = 0;\n\n    // Tracks when resetInput has punted to just putting a short\n    // string instead of the (large) selection.\n    d.inaccurateSelection = false;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    return d;\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      cm.display.wrapper.className += \" CodeMirror-wrap\";\n      cm.display.sizer.style.minWidth = \"\";\n    } else {\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(\" CodeMirror-wrap\", \"\");\n      computeMaxLength(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line))\n        return 0;\n      else if (wrapping)\n        return (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function keyMapChanged(cm) {\n    var map = keyMap[cm.options.keyMap], style = map.style;\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, \"\") +\n      (style ? \" cm-keymap-\" + style : \"\");\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n  }\n\n  function lineLength(doc, line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find();\n      cur = getLine(doc, found.from.line);\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find();\n      len -= cur.text.length - found.from.ch;\n      cur = getLine(doc, found.to.line);\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  function computeMaxLength(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(doc, d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(doc, line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content. Optionally force a scrollTop.\n  function updateScrollbars(cm) {\n    var d = cm.display, docHeight = cm.doc.height;\n    var totalHeight = docHeight + paddingVert(d);\n    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + \"px\";\n    d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + \"px\";\n    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);\n    var needsH = d.scroller.scrollWidth > (d.scroller.clientWidth + 1);\n    var needsV = scrollHeight > (d.scroller.clientHeight + 1);\n    if (needsV) {\n      d.scrollbarV.style.display = \"block\";\n      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + \"px\" : \"0\";\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      d.scrollbarV.firstChild.style.height =\n        Math.max(0, scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + \"px\";\n    } else {\n      d.scrollbarV.style.display = \"\";\n      d.scrollbarV.firstChild.style.height = \"0\";\n    }\n    if (needsH) {\n      d.scrollbarH.style.display = \"block\";\n      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + \"px\" : \"0\";\n      d.scrollbarH.firstChild.style.width =\n        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + \"px\";\n    } else {\n      d.scrollbarH.style.display = \"\";\n      d.scrollbarH.firstChild.style.width = \"0\";\n    }\n    if (needsH && needsV) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = scrollbarWidth(d.measure) + \"px\";\n      d.gutterFiller.style.width = d.gutters.offsetWidth + \"px\";\n    } else d.gutterFiller.style.display = \"\";\n\n    if (mac_geLion && scrollbarWidth(d.measure) === 0) {\n      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? \"18px\" : \"12px\";\n      d.scrollbarV.style.pointerEvents = d.scrollbarH.style.pointerEvents = \"none\";\n    }\n  }\n\n  function visibleLines(display, doc, viewPort) {\n    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;\n    if (typeof viewPort == \"number\") top = viewPort;\n    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}\n    top = Math.floor(top - paddingTop(display));\n    var bottom = Math.ceil(top + height);\n    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};\n  }\n\n  // LINE NUMBERS\n\n  function alignHorizontally(cm) {\n    var display = cm.display;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, l = comp + \"px\";\n    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {\n      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + \"px\";\n  }\n\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n  function compensateForHScroll(display) {\n    return getRect(display.scroller).left - getRect(display.sizer).left;\n  }\n\n  // DISPLAY DRAWING\n\n  function updateDisplay(cm, changes, viewPort, forced) {\n    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;\n    var visible = visibleLines(cm.display, cm.doc, viewPort);\n    for (var first = true;; first = false) {\n      var oldWidth = cm.display.scroller.clientWidth;\n      if (!updateDisplayInner(cm, changes, visible, forced)) break;\n      updated = true;\n      changes = [];\n      updateSelection(cm);\n      updateScrollbars(cm);\n      if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {\n        forced = true;\n        continue;\n      }\n      forced = false;\n\n      // Clip forced viewport to actual scrollable area\n      if (viewPort)\n        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight,\n                            typeof viewPort == \"number\" ? viewPort : viewPort.top);\n      visible = visibleLines(cm.display, cm.doc, viewPort);\n      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)\n        break;\n    }\n\n    if (updated) {\n      signalLater(cm, \"update\", cm);\n      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)\n        signalLater(cm, \"viewportChange\", cm, cm.display.showingFrom, cm.display.showingTo);\n    }\n    return updated;\n  }\n\n  // Uses a set of changes plus the current scroll position to\n  // determine which DOM updates have to be made, and makes the\n  // updates.\n  function updateDisplayInner(cm, changes, visible, forced) {\n    var display = cm.display, doc = cm.doc;\n    if (!display.wrapper.offsetWidth) {\n      display.showingFrom = display.showingTo = doc.first;\n      display.viewOffset = 0;\n      return;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!forced && changes.length == 0 &&\n        visible.from > display.showingFrom && visible.to < display.showingTo)\n      return;\n\n    if (maybeUpdateLineNumberWidth(cm))\n      changes = [{from: doc.first, to: doc.first + doc.size}];\n    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + \"px\";\n    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : \"0\";\n\n    // Used to determine which lines need their line numbers updated\n    var positionsChangedFrom = Infinity;\n    if (cm.options.lineNumbers)\n      for (var i = 0; i < changes.length; ++i)\n        if (changes[i].diff && changes[i].from < positionsChangedFrom) { positionsChangedFrom = changes[i].from; }\n\n    var end = doc.first + doc.size;\n    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, visible.to + cm.options.viewportMargin);\n    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);\n    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);\n    if (sawCollapsedSpans) {\n      from = lineNo(visualLine(doc, getLine(doc, from)));\n      while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;\n    }\n\n    // Create a range of theoretically intact lines, and punch holes\n    // in that using the change info.\n    var intact = [{from: Math.max(display.showingFrom, doc.first),\n                   to: Math.min(display.showingTo, end)}];\n    if (intact[0].from >= intact[0].to) intact = [];\n    else intact = computeIntact(intact, changes);\n    // When merged lines are present, we might have to reduce the\n    // intact ranges because changes in continued fragments of the\n    // intact lines do require the lines to be redrawn.\n    if (sawCollapsedSpans)\n      for (var i = 0; i < intact.length; ++i) {\n        var range = intact[i], merged;\n        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {\n          var newTo = merged.find().from.line;\n          if (newTo > range.from) range.to = newTo;\n          else { intact.splice(i--, 1); break; }\n        }\n      }\n\n    // Clip off the parts that won't be visible\n    var intactLines = 0;\n    for (var i = 0; i < intact.length; ++i) {\n      var range = intact[i];\n      if (range.from < from) range.from = from;\n      if (range.to > to) range.to = to;\n      if (range.from >= range.to) intact.splice(i--, 1);\n      else intactLines += range.to - range.from;\n    }\n    if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) {\n      updateViewOffset(cm);\n      return;\n    }\n    intact.sort(function(a, b) {return a.from - b.from;});\n\n    // Avoid crashing on IE's \"unspecified error\" when in iframes\n    try {\n      var focused = document.activeElement;\n    } catch(e) {}\n    if (intactLines < (to - from) * .7) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, from, to, intact, positionsChangedFrom);\n    display.lineDiv.style.display = \"\";\n    if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();\n\n    var different = from != display.showingFrom || to != display.showingTo ||\n      display.lastSizeC != display.wrapper.clientHeight;\n    // This is just a bogus formula that detects when the editor is\n    // resized or the font size changes.\n    if (different) {\n      display.lastSizeC = display.wrapper.clientHeight;\n      startWorker(cm, 400);\n    }\n    display.showingFrom = from; display.showingTo = to;\n\n    display.gutters.style.height = \"\";\n    updateHeightsInViewport(cm);\n    updateViewOffset(cm);\n\n    return true;\n  }\n\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {\n      if (ie_lt8) {\n        var bot = node.offsetTop + node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = getRect(node);\n        height = box.bottom - box.top;\n      }\n      var diff = node.lineObj.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(node.lineObj, height);\n        var widgets = node.lineObj.widgets;\n        if (widgets) for (var i = 0; i < widgets.length; ++i)\n          widgets[i].height = widgets[i].node.offsetHeight;\n      }\n    }\n  }\n\n  function updateViewOffset(cm) {\n    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));\n    // Position the mover div to align with the current virtual scroll position\n    cm.display.mover.style.top = off + \"px\";\n  }\n\n  function computeIntact(intact, changes) {\n    for (var i = 0, l = changes.length || 0; i < l; ++i) {\n      var change = changes[i], intact2 = [], diff = change.diff || 0;\n      for (var j = 0, l2 = intact.length; j < l2; ++j) {\n        var range = intact[j];\n        if (change.to <= range.from && change.diff) {\n          intact2.push({from: range.from + diff, to: range.to + diff});\n        } else if (change.to <= range.from || change.from >= range.to) {\n          intact2.push(range);\n        } else {\n          if (change.from > range.from)\n            intact2.push({from: range.from, to: change.from});\n          if (change.to < range.to)\n            intact2.push({from: change.to + diff, to: range.to + diff});\n        }\n      }\n      intact = intact2;\n    }\n    return intact;\n  }\n\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft;\n      width[cm.options.gutters[i]] = n.offsetWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {\n    var dims = getDimensions(cm);\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))\n      removeChildren(display.lineDiv);\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      if (webkit && mac && cm.display.currentWheelTarget == node) {\n        node.style.display = \"none\";\n        node.lineObj = null;\n      } else {\n        node.parentNode.removeChild(node);\n      }\n      return next;\n    }\n\n    var nextIntact = intact.shift(), lineN = from;\n    cm.doc.iter(from, to, function(line) {\n      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();\n      if (lineIsHidden(cm.doc, line)) {\n        if (line.height != 0) updateLineHeight(line, 0);\n        if (line.widgets && cur && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {\n          var w = line.widgets[i];\n          if (w.showIfHidden) {\n            var prev = cur.previousSibling;\n            if (/pre/i.test(prev.nodeName)) {\n              var wrap = elt(\"div\", null, null, \"position: relative\");\n              prev.parentNode.replaceChild(wrap, prev);\n              wrap.appendChild(prev);\n              prev = wrap;\n            }\n            var wnode = prev.appendChild(elt(\"div\", [w.node], \"CodeMirror-linewidget\"));\n            if (!w.handleMouseEvents) wnode.ignoreEvents = true;\n            positionLineWidget(w, wnode, prev, dims);\n          }\n        }\n      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {\n        // This line is intact. Skip to the actual node. Update its\n        // line number if needed.\n        while (cur.lineObj != line) cur = rm(cur);\n        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)\n          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));\n        cur = cur.nextSibling;\n      } else {\n        // For lines with widgets, make an attempt to find and reuse\n        // the existing element, so that widgets aren't needlessly\n        // removed and re-inserted into the dom\n        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)\n          if (search.lineObj == line && /div/i.test(search.nodeName)) { reuse = search; break; }\n        // This line needs to be generated.\n        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);\n        if (lineNode != reuse) {\n          container.insertBefore(lineNode, cur);\n        } else {\n          while (cur != reuse) cur = rm(cur);\n          cur = cur.nextSibling;\n        }\n\n        lineNode.lineObj = line;\n      }\n      ++lineN;\n    });\n    while (cur) cur = rm(cur);\n  }\n\n  function buildLineElement(cm, line, lineNo, dims, reuse) {\n    var built = buildLineContent(cm, line), lineElement = built.pre;\n    var markers = line.gutterMarkers, display = cm.display, wrap;\n\n    var bgClass = built.bgClass ? built.bgClass + \" \" + (line.bgClass || \"\") : line.bgClass;\n    if (!cm.options.lineNumbers && !markers && !bgClass && !line.wrapClass && !line.widgets)\n      return lineElement;\n\n    // Lines with gutter elements, widgets or a background class need\n    // to be wrapped again, and have the extra elements added to the\n    // wrapper div\n\n    if (reuse) {\n      reuse.alignable = null;\n      var isOk = true, widgetsSeen = 0, insertBefore = null;\n      for (var n = reuse.firstChild, next; n; n = next) {\n        next = n.nextSibling;\n        if (!/\\bCodeMirror-linewidget\\b/.test(n.className)) {\n          reuse.removeChild(n);\n        } else {\n          for (var i = 0; i < line.widgets.length; ++i) {\n            var widget = line.widgets[i];\n            if (widget.node == n.firstChild) {\n              if (!widget.above && !insertBefore) insertBefore = n;\n              positionLineWidget(widget, n, reuse, dims);\n              ++widgetsSeen;\n              break;\n            }\n          }\n          if (i == line.widgets.length) { isOk = false; break; }\n        }\n      }\n      reuse.insertBefore(lineElement, insertBefore);\n      if (isOk && widgetsSeen == line.widgets.length) {\n        wrap = reuse;\n        reuse.className = line.wrapClass || \"\";\n      }\n    }\n    if (!wrap) {\n      wrap = elt(\"div\", null, line.wrapClass, \"position: relative\");\n      wrap.appendChild(lineElement);\n    }\n    // Kludge to make sure the styled element lies behind the selection (by z-index)\n    if (bgClass)\n      wrap.insertBefore(elt(\"div\", null, bgClass + \" CodeMirror-linebackground\"), wrap.firstChild);\n    if (cm.options.lineNumbers || markers) {\n      var gutterWrap = wrap.insertBefore(elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"position: absolute; left: \" +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"),\n                                         lineElement);\n      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        wrap.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineNo),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n              + display.lineNumInnerWidth + \"px\"));\n      if (markers)\n        for (var k = 0; k < cm.options.gutters.length; ++k) {\n          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n          if (found)\n            gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n                                       dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n        }\n    }\n    if (ie_lt8) wrap.style.zIndex = 2;\n    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) node.ignoreEvents = true;\n      positionLineWidget(widget, node, wrap, dims);\n      if (widget.above)\n        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, \"redraw\");\n    }\n    return wrap;\n  }\n\n  function positionLineWidget(widget, node, wrap, dims) {\n    if (widget.noHScroll) {\n      (wrap.alignable || (wrap.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n    }\n  }\n\n  // SELECTION / CURSOR\n\n  function updateSelection(cm) {\n    var display = cm.display;\n    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      updateSelectionCursor(cm);\n    else\n      display.cursor.style.display = display.otherCursor.style.display = \"none\";\n    if (!collapsed)\n      updateSelectionRange(cm);\n    else\n      display.selectionDiv.style.display = \"none\";\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, cm.doc.sel.head, \"div\");\n      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);\n      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                                        headPos.top + lineOff.top - wrapOff.top)) + \"px\";\n      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                                         headPos.left + lineOff.left - wrapOff.left)) + \"px\";\n    }\n  }\n\n  // No selection, plain cursor\n  function updateSelectionCursor(cm) {\n    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, \"div\");\n    display.cursor.style.left = pos.left + \"px\";\n    display.cursor.style.top = pos.top + \"px\";\n    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n    display.cursor.style.display = \"\";\n\n    if (pos.other) {\n      display.otherCursor.style.display = \"\";\n      display.otherCursor.style.left = pos.other.left + \"px\";\n      display.otherCursor.style.top = pos.other.top + \"px\";\n      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    } else { display.otherCursor.style.display = \"none\"; }\n  }\n\n  // Highlight selection\n  function updateSelectionRange(cm) {\n    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left, rightSide = display.lineSpace.offsetWidth - padding.right;\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n                               \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, \"left\"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, \"right\");\n          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = leftSide;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = leftSide;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = rightSide;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < leftSide + 1) left = leftSide;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    if (sel.from.line == sel.to.line) {\n      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);\n    } else {\n      var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);\n      var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);\n      var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;\n      var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n    }\n\n    removeChildrenAndAdd(display.selectionDiv, fragment);\n    display.selectionDiv.style.display = \"\";\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursor.style.visibility = display.otherCursor.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.showingTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changed = [], prevChange;\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function(line) {\n      if (doc.frontier >= cm.display.showingFrom) { // Visible\n        var oldStyles = line.styles;\n        line.styles = highlightLine(cm, line, state, true);\n        var ischange = !oldStyles || oldStyles.length != line.styles.length;\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) {\n          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;\n          else changed.push(prevChange = {start: doc.frontier, end: doc.frontier + 1});\n        }\n        line.stateAfter = copyState(doc.mode, state);\n      } else {\n        processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changed.length)\n      operation(cm, function() {\n        for (var i = 0; i < changed.length; ++i)\n          regChange(this, changed[i].start, changed[i].end);\n      })();\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingH(display) {\n    if (display.cachedPaddingH) return display.cachedPaddingH;\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    return display.cachedPaddingH = {left: parseInt(style.paddingLeft),\n                                     right: parseInt(style.paddingRight)};\n  }\n\n  function measureChar(cm, line, ch, data, bias) {\n    var dir = -1;\n    data = data || measureLine(cm, line);\n    if (data.crude) {\n      var left = data.left + ch * data.width;\n      return {left: left, right: left + data.width, top: data.top, bottom: data.bottom};\n    }\n\n    for (var pos = ch;; pos += dir) {\n      var r = data[pos];\n      if (r) break;\n      if (dir < 0 && pos == 0) dir = 1;\n    }\n    bias = pos > ch ? \"left\" : pos < ch ? \"right\" : bias;\n    if (bias == \"left\" && r.leftSide) r = r.leftSide;\n    else if (bias == \"right\" && r.rightSide) r = r.rightSide;\n    return {left: pos < ch ? r.right : r.left,\n            right: pos > ch ? r.left : r.right,\n            top: r.top,\n            bottom: r.bottom};\n  }\n\n  function findCachedMeasurement(cm, line) {\n    var cache = cm.display.measureLineCache;\n    for (var i = 0; i < cache.length; ++i) {\n      var memo = cache[i];\n      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&\n          cm.display.scroller.clientWidth == memo.width &&\n          memo.classes == line.textClass + \"|\" + line.wrapClass)\n        return memo;\n    }\n  }\n\n  function clearCachedMeasurement(cm, line) {\n    var exists = findCachedMeasurement(cm, line);\n    if (exists) exists.text = exists.measure = exists.markedSpans = null;\n  }\n\n  function measureLine(cm, line) {\n    // First look in the cache\n    var cached = findCachedMeasurement(cm, line);\n    if (cached) return cached.measure;\n\n    // Failing that, recompute and store result in cache\n    var measure = measureLineInner(cm, line);\n    var cache = cm.display.measureLineCache;\n    var memo = {text: line.text, width: cm.display.scroller.clientWidth,\n                markedSpans: line.markedSpans, measure: measure,\n                classes: line.textClass + \"|\" + line.wrapClass};\n    if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;\n    else cache.push(memo);\n    return measure;\n  }\n\n  function measureLineInner(cm, line) {\n    if (!cm.options.lineWrapping && line.text.length >= cm.options.crudeMeasuringFrom)\n      return crudelyMeasureLine(cm, line);\n\n    var display = cm.display, measure = emptyArray(line.text.length);\n    var pre = buildLineContent(cm, line, measure, true).pre;\n\n    // IE does not cache element positions of inline elements between\n    // calls to getBoundingClientRect. This makes the loop below,\n    // which gathers the positions of all the characters on the line,\n    // do an amount of layout work quadratic to the number of\n    // characters. When line wrapping is off, we try to improve things\n    // by first subdividing the line into a bunch of inline blocks, so\n    // that IE can reuse most of the layout information from caches\n    // for those blocks. This does interfere with line wrapping, so it\n    // doesn't work when wrapping is on, but in that case the\n    // situation is slightly better, since IE does cache line-wrapping\n    // information and only recomputes per-line.\n    if (old_ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {\n      var fragment = document.createDocumentFragment();\n      var chunk = 10, n = pre.childNodes.length;\n      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {\n        var wrap = elt(\"div\", null, null, \"display: inline-block\");\n        for (var j = 0; j < chunk && n; ++j) {\n          wrap.appendChild(pre.firstChild);\n          --n;\n        }\n        fragment.appendChild(wrap);\n      }\n      pre.appendChild(fragment);\n    }\n\n    removeChildrenAndAdd(display.measure, pre);\n\n    var outer = getRect(display.lineDiv);\n    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;\n    // Work around an IE7/8 bug where it will sometimes have randomly\n    // replaced our pre with a clone at this point.\n    if (ie_lt9 && display.measure.first != pre)\n      removeChildrenAndAdd(display.measure, pre);\n\n    function measureRect(rect) {\n      var top = rect.top - outer.top, bot = rect.bottom - outer.top;\n      if (bot > maxBot) bot = maxBot;\n      if (top < 0) top = 0;\n      for (var i = vranges.length - 2; i >= 0; i -= 2) {\n        var rtop = vranges[i], rbot = vranges[i+1];\n        if (rtop > bot || rbot < top) continue;\n        if (rtop <= top && rbot >= bot ||\n            top <= rtop && bot >= rbot ||\n            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {\n          vranges[i] = Math.min(top, rtop);\n          vranges[i+1] = Math.max(bot, rbot);\n          break;\n        }\n      }\n      if (i < 0) { i = vranges.length; vranges.push(top, bot); }\n      return {left: rect.left - outer.left,\n              right: rect.right - outer.left,\n              top: i, bottom: null};\n    }\n    function finishRect(rect) {\n      rect.bottom = vranges[rect.top+1];\n      rect.top = vranges[rect.top];\n    }\n\n    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {\n      var node = cur, rect = null;\n      // A widget might wrap, needs special care\n      if (/\\bCodeMirror-widget\\b/.test(cur.className) && cur.getClientRects) {\n        if (cur.firstChild.nodeType == 1) node = cur.firstChild;\n        var rects = node.getClientRects();\n        if (rects.length > 1) {\n          rect = data[i] = measureRect(rects[0]);\n          rect.rightSide = measureRect(rects[rects.length - 1]);\n        }\n      }\n      if (!rect) rect = data[i] = measureRect(getRect(node));\n      if (cur.measureRight) rect.right = getRect(cur.measureRight).left - outer.left;\n      if (cur.leftSide) rect.leftSide = measureRect(getRect(cur.leftSide));\n    }\n    removeChildren(cm.display.measure);\n    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {\n      finishRect(cur);\n      if (cur.leftSide) finishRect(cur.leftSide);\n      if (cur.rightSide) finishRect(cur.rightSide);\n    }\n    return data;\n  }\n\n  function crudelyMeasureLine(cm, line) {\n    var copy = new Line(line.text.slice(0, 100), null);\n    if (line.textClass) copy.textClass = line.textClass;\n    var measure = measureLineInner(cm, copy);\n    var left = measureChar(cm, copy, 0, measure, \"left\");\n    var right = measureChar(cm, copy, 99, measure, \"right\");\n    return {crude: true, top: left.top, left: left.left, bottom: left.bottom, width: (right.right - left.left) / 100};\n  }\n\n  function measureLineWidth(cm, line) {\n    var hasBadSpan = false;\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {\n      var sp = line.markedSpans[i];\n      if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;\n    }\n    var cached = !hasBadSpan && findCachedMeasurement(cm, line);\n    if (cached || line.text.length >= cm.options.crudeMeasuringFrom)\n      return measureChar(cm, line, line.text.length, cached && cached.measure, \"right\").right;\n\n    var pre = buildLineContent(cm, line, null, true).pre;\n    var end = pre.appendChild(zeroWidthElement(cm.display.measure));\n    removeChildrenAndAdd(cm.display.measure, pre);\n    return getRect(end).right - getRect(cm.display.lineDiv).left;\n  }\n\n  function clearCaches(cm) {\n    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Context is one of \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), or \"page\"\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(cm, lineObj);\n    if (context == \"local\") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == \"page\" || context == \"window\") {\n      var lOff = getRect(cm.display.lineSpace);\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Context may be \"window\", \"page\", \"div\", or \"local\"/null\n  // Result is in \"div\" coords\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = getRect(cm.display.sizer);\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = getRect(cm.display.lineSpace);\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);\n  }\n\n  function cursorCoords(cm, pos, context, lineObj, measurement) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!measurement) measurement = measureLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureChar(cm, lineObj, ch, measurement, right ? \"right\" : \"left\");\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = new Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Coords must be lineSpace-local\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineNo > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    for (;;) {\n      var lineObj = getLine(doc, lineNo);\n      var found = coordsCharInner(cm, lineObj, lineNo, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find();\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineNo = mergedPos.to.line;\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(cm, lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var measurement = measureLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\",\n                            lineObj, measurement);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n                              xDiff < 0 ? -1 : xDiff ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"x\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var width = anchor.offsetWidth;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap changes in such a way that each\n  // change won't have to update the cursor and display (which would\n  // be awkward, slow, and error-prone), but instead updates are\n  // batched and then all combined and executed at once.\n\n  var nextOpId = 0;\n  function startOperation(cm) {\n    cm.curOp = {\n      // An array of ranges of lines that have to be updated. See\n      // updateDisplay.\n      changes: [],\n      forceUpdate: false,\n      updateInput: null,\n      userSelChange: null,\n      textChanged: null,\n      selectionChanged: false,\n      cursorActivity: false,\n      updateMaxLine: false,\n      updateScrollPos: false,\n      id: ++nextOpId\n    };\n    if (!delayedCallbackDepth++) delayedCallbacks = [];\n  }\n\n  function endOperation(cm) {\n    var op = cm.curOp, doc = cm.doc, display = cm.display;\n    cm.curOp = null;\n\n    if (op.updateMaxLine) computeMaxLength(cm);\n    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {\n      var width = measureLineWidth(cm, display.maxLine);\n      display.sizer.style.minWidth = Math.max(0, width + 3) + \"px\";\n      display.maxLineChanged = false;\n      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);\n      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)\n        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);\n    }\n    var newScrollPos, updated;\n    if (op.updateScrollPos) {\n      newScrollPos = op.updateScrollPos;\n    } else if (op.selectionChanged && display.scroller.clientHeight) { // don't rescroll if not visible\n      var coords = cursorCoords(cm, doc.sel.head);\n      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);\n    }\n    if (op.changes.length || op.forceUpdate || newScrollPos && newScrollPos.scrollTop != null) {\n      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate);\n      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;\n    }\n    if (!updated && op.selectionChanged) updateSelection(cm);\n    if (op.updateScrollPos) {\n      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, newScrollPos.scrollTop));\n      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, newScrollPos.scrollLeft));\n      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;\n      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;\n      alignHorizontally(cm);\n      if (op.scrollToPos)\n        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from),\n                          clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);\n    } else if (newScrollPos) {\n      scrollCursorIntoView(cm);\n    }\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      resetInput(cm, op.userSelChange);\n\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\n    var delayed;\n    if (!--delayedCallbackDepth) {\n      delayed = delayedCallbacks;\n      delayedCallbacks = null;\n    }\n    if (op.textChanged)\n      signal(cm, \"change\", cm, op.textChanged);\n    if (op.cursorActivity) signal(cm, \"cursorActivity\", cm);\n    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm1, f) {\n    return function() {\n      var cm = cm1 || this, withOp = !cm.curOp;\n      if (withOp) startOperation(cm);\n      try { var result = f.apply(cm, arguments); }\n      finally { if (withOp) endOperation(cm); }\n      return result;\n    };\n  }\n  function docOperation(f) {\n    return function() {\n      var withOp = this.cm && !this.cm.curOp, result;\n      if (withOp) startOperation(this.cm);\n      try { result = f.apply(this, arguments); }\n      finally { if (withOp) endOperation(this.cm); }\n      return result;\n    };\n  }\n  function runInOp(cm, f) {\n    var withOp = !cm.curOp, result;\n    if (withOp) startOperation(cm);\n    try { result = f(); }\n    finally { if (withOp) endOperation(cm); }\n    return result;\n  }\n\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    cm.curOp.changes.push({from: from, to: to, diff: lendiff});\n  }\n\n  // INPUT HANDLING\n\n  function slowPoll(cm) {\n    if (cm.display.pollingFast) return;\n    cm.display.poll.set(cm.options.pollInterval, function() {\n      readInput(cm);\n      if (cm.state.focused) slowPoll(cm);\n    });\n  }\n\n  function fastPoll(cm) {\n    var missed = false;\n    cm.display.pollingFast = true;\n    function p() {\n      var changed = readInput(cm);\n      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}\n      else {cm.display.pollingFast = false; slowPoll(cm);}\n    }\n    cm.display.poll.set(20, p);\n  }\n\n  // prevInput is a hack to work with IME. If we reset the textarea\n  // on every change, that breaks IME. So we look for changes\n  // compared to the previous content instead. (Modern browsers have\n  // events that indicate IME taking place, but these are not widely\n  // supported or compatible enough yet to rely on.)\n  function readInput(cm) {\n    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;\n    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.options.disableInput) return false;\n    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {\n      input.value = input.value.substring(0, input.value.length - 1);\n      cm.state.fakedLastChar = false;\n    }\n    var text = input.value;\n    if (text == prevInput && posEq(sel.from, sel.to)) return false;\n    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {\n      resetInput(cm, true);\n      return false;\n    }\n\n    var withOp = !cm.curOp;\n    if (withOp) startOperation(cm);\n    sel.shift = false;\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n    var from = sel.from, to = sel.to;\n    var inserted = text.slice(same);\n    if (same < prevInput.length)\n      from = Pos(from.line, from.ch - (prevInput.length - same));\n    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)\n      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + inserted.length));\n\n    var updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: splitLines(inserted),\n                       origin: cm.state.pasteIncoming ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\"};\n    makeChange(cm.doc, changeEvent, \"end\");\n    cm.curOp.updateInput = updateInput;\n    signalLater(cm, \"inputRead\", cm, changeEvent);\n    if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&\n        cm.options.smartIndent && sel.head.ch < 100) {\n      var electric = cm.getModeAt(sel.head).electricChars;\n      if (electric) for (var i = 0; i < electric.length; i++)\n        if (inserted.indexOf(electric.charAt(i)) > -1) {\n          indentLine(cm, sel.head.line, \"smart\");\n          break;\n        }\n    }\n\n    if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = cm.display.prevInput = \"\";\n    else cm.display.prevInput = text;\n    if (withOp) endOperation(cm);\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n    return true;\n  }\n\n  function resetInput(cm, user) {\n    var minimal, selected, doc = cm.doc;\n    if (!posEq(doc.sel.from, doc.sel.to)) {\n      cm.display.prevInput = \"\";\n      minimal = hasCopyEvent &&\n        (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);\n      var content = minimal ? \"-\" : selected || cm.getSelection();\n      cm.display.input.value = content;\n      if (cm.state.focused) selectInput(cm.display.input);\n      if (ie && !ie_lt9) cm.display.inputHasSelection = content;\n    } else if (user) {\n      cm.display.prevInput = cm.display.input.value = \"\";\n      if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    }\n    cm.display.inaccurateSelection = minimal;\n  }\n\n  function focusInput(cm) {\n    if (cm.options.readOnly != \"nocursor\" && (!mobile || document.activeElement != cm.display.input))\n      cm.display.input.focus();\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { focusInput(cm); onFocus(cm); }\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.doc.cantEdit;\n  }\n\n  // EVENT HANDLERS\n\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    if (old_ie)\n      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);\n        extendSelection(cm.doc, word.from, word.to);\n      }));\n    else\n      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    on(d.lineSpace, \"selectstart\", function(e) {\n      if (!eventInWidget(d, e)) e_preventDefault(e);\n    });\n    // Gecko browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for Gecko.\n    if (!captureMiddleClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\n    on(d.scroller, \"scroll\", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n    on(d.scrollbarV, \"scroll\", function() {\n      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);\n    });\n    on(d.scrollbarH, \"scroll\", function() {\n      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);\n    });\n\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\n    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }\n    on(d.scrollbarH, \"mousedown\", reFocus);\n    on(d.scrollbarV, \"mousedown\", reFocus);\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    var resizeTimer;\n    function onResize() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        // Might be a text scaling operation, clear size caches.\n        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = knownScrollbarWidth = null;\n        clearCaches(cm);\n        runInOp(cm, bind(regChange, cm));\n      }, 100);\n    }\n    on(window, \"resize\", onResize);\n    // Above handler holds on to the editor and its data structures.\n    // Here we poll to unregister it when the editor is no longer in\n    // the document, so that it can be garbage-collected.\n    function unregister() {\n      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}\n      if (p) setTimeout(unregister, 5000);\n      else off(window, \"resize\", onResize);\n    }\n    setTimeout(unregister, 5000);\n\n    on(d.input, \"keyup\", operation(cm, onKeyUp));\n    on(d.input, \"input\", function() {\n      if (ie && !ie_lt9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;\n      fastPoll(cm);\n    });\n    on(d.input, \"keydown\", operation(cm, onKeyDown));\n    on(d.input, \"keypress\", operation(cm, onKeyPress));\n    on(d.input, \"focus\", bind(onFocus, cm));\n    on(d.input, \"blur\", bind(onBlur, cm));\n\n    function drag_(e) {\n      if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;\n      e_stop(e);\n    }\n    if (cm.options.dragDrop) {\n      on(d.scroller, \"dragstart\", function(e){onDragStart(cm, e);});\n      on(d.scroller, \"dragenter\", drag_);\n      on(d.scroller, \"dragover\", drag_);\n      on(d.scroller, \"drop\", operation(cm, onDrop));\n    }\n    on(d.scroller, \"paste\", function(e) {\n      if (eventInWidget(d, e)) return;\n      focusInput(cm);\n      fastPoll(cm);\n    });\n    on(d.input, \"paste\", function() {\n      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206\n      // Add a char to the end of textarea before paste occur so that\n      // selection doesn't span to the end of textarea.\n      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {\n        var start = d.input.selectionStart, end = d.input.selectionEnd;\n        d.input.value += \"$\";\n        d.input.selectionStart = start;\n        d.input.selectionEnd = end;\n        cm.state.fakedLastChar = true;\n      }\n      cm.state.pasteIncoming = true;\n      fastPoll(cm);\n    });\n\n    function prepareCopy(e) {\n      if (d.inaccurateSelection) {\n        d.prevInput = \"\";\n        d.inaccurateSelection = false;\n        d.input.value = cm.getSelection();\n        selectInput(d.input);\n      }\n      if (e.type == \"cut\") cm.state.cutIncoming = true;\n    }\n    on(d.input, \"cut\", prepareCopy);\n    on(d.input, \"copy\", prepareCopy);\n\n    // Needed to handle Tab key in KHTML\n    if (khtml) on(d.sizer, \"mouseup\", function() {\n      if (document.activeElement == d.input) d.input.blur();\n      focusInput(cm);\n    });\n  }\n\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;\n    }\n  }\n\n  function posFromMouse(cm, e, liberal) {\n    var display = cm.display;\n    if (!liberal) {\n      var target = e_target(e);\n      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||\n          target == display.scrollbarV || target == display.scrollbarV.firstChild ||\n          target == display.scrollbarFiller || target == display.gutterFiller) return null;\n    }\n    var x, y, space = getRect(display.lineSpace);\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n    return coordsChar(cm, x - space.left, y - space.top);\n  }\n\n  var lastClick, lastDoubleClick;\n  function onMouseDown(e) {\n    if (signalDOMEvent(this, e)) return;\n    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;\n    sel.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n    window.focus();\n\n    switch (e_button(e)) {\n    case 3:\n      if (captureMiddleClick) onContextMenu.call(cm, cm, e);\n      return;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(bind(focusInput, cm), 20);\n      e_preventDefault(e);\n      return;\n    }\n    // For button 1, if it was clicked inside the editor\n    // (posFromMouse returning non-null), we have to adjust the\n    // selection.\n    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}\n\n    setTimeout(bind(ensureFocus, cm), 0);\n\n    var now = +new Date, type = \"single\";\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n      type = \"triple\";\n      e_preventDefault(e);\n      setTimeout(bind(focusInput, cm), 20);\n      selectLine(cm, start.line);\n    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n      type = \"double\";\n      lastDoubleClick = {time: now, pos: start};\n      e_preventDefault(e);\n      var word = findWordAt(getLine(doc, start.line).text, start);\n      extendSelection(cm.doc, word.from, word.to);\n    } else { lastClick = {time: now, pos: start}; }\n\n    var last = start;\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&\n        !posLess(start, sel.from) && !posLess(sel.to, start) && type == \"single\") {\n      var dragEnd = operation(cm, function(e2) {\n        if (webkit) display.scroller.draggable = false;\n        cm.state.draggingText = false;\n        off(document, \"mouseup\", dragEnd);\n        off(display.scroller, \"drop\", dragEnd);\n        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n          e_preventDefault(e2);\n          extendSelection(cm.doc, start);\n          focusInput(cm);\n          // Work around unexplainable focus problem in IE9 (#2127)\n          if (old_ie && !ie_lt9)\n            setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);\n        }\n      });\n      // Let the drag handler handle this.\n      if (webkit) display.scroller.draggable = true;\n      cm.state.draggingText = dragEnd;\n      // IE's approach to draggable\n      if (display.scroller.dragDrop) display.scroller.dragDrop();\n      on(document, \"mouseup\", dragEnd);\n      on(display.scroller, \"drop\", dragEnd);\n      return;\n    }\n    e_preventDefault(e);\n    if (type == \"single\") extendSelection(cm.doc, clipPos(doc, start));\n\n    var startstart = sel.from, startend = sel.to, lastPos = start;\n\n    function doSelect(cur) {\n      if (posEq(lastPos, cur)) return;\n      lastPos = cur;\n\n      if (type == \"single\") {\n        extendSelection(cm.doc, clipPos(doc, start), cur);\n        return;\n      }\n\n      startstart = clipPos(doc, startstart);\n      startend = clipPos(doc, startend);\n      if (type == \"double\") {\n        var word = findWordAt(getLine(doc, cur.line).text, cur);\n        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);\n        else extendSelection(cm.doc, startstart, word.to);\n      } else if (type == \"triple\") {\n        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));\n        else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));\n      }\n    }\n\n    var editorSize = getRect(display.wrapper);\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true);\n      if (!cur) return;\n      if (!posEq(cur, last)) {\n        ensureFocus(cm);\n        last = cur;\n        doSelect(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      counter = Infinity;\n      e_preventDefault(e);\n      focusInput(cm);\n      off(document, \"mousemove\", move);\n      off(document, \"mouseup\", up);\n    }\n\n    var move = operation(cm, function(e) {\n      if ((ie && !ie_lt10) ?  !e.buttons : !e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    on(document, \"mousemove\", move);\n    on(document, \"mouseup\", up);\n  }\n\n  function gutterEvent(cm, e, type, prevent, signalfn) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(getRect(cm.display.gutters).right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = getRect(display.lineDiv);\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && getRect(g).right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signalfn(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n    return gutterEvent(cm, e, \"gutterContextMenu\", false, signal);\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true, signalLater);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        var reader = new FileReader;\n        reader.onload = function() {\n          text[i] = reader.result;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            makeChange(cm.doc, {from: pos, to: pos, text: splitLines(text.join(\"\\n\")), origin: \"paste\"}, \"around\");\n          }\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else {\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(bind(focusInput, cm), 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n        if (text) {\n          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;\n          setSelection(cm.doc, pos, pos);\n          if (cm.state.draggingText) replaceRange(cm.doc, \"\", curFrom, curTo, \"paste\");\n          cm.replaceSelection(text, null, \"paste\");\n          focusInput(cm);\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    var txt = cm.getSelection();\n    e.dataTransfer.setData(\"Text\", txt);\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (opera) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (opera) img.parentNode.removeChild(img);\n    }\n  }\n\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplay(cm, [], val);\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\n    if (gecko) updateDisplay(cm, []);\n    startWorker(cm, 100);\n  }\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  function onScrollWheel(cm, e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||\n          dy && scroll.scrollHeight > scroll.clientHeight)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {\n        if (cur.lineObj) {\n          cm.display.currentWheelTarget = cur;\n          break;\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {\n      if (dy)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplay(cm, [], {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\n    var doc = cm.doc, prevShift = doc.sel.shift, done = false;\n    try {\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n      if (dropShift) doc.sel.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      doc.sel.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function allKeyMaps(cm) {\n    var maps = cm.state.keyMaps.slice(0);\n    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);\n    maps.push(cm.options.keyMap);\n    return maps;\n  }\n\n  var maybeTransition;\n  function handleKeyBinding(cm, e) {\n    // Handle auto keymap transitions\n    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;\n    clearTimeout(maybeTransition);\n    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n      if (getKeyMap(cm.options.keyMap) == startMap) {\n        cm.options.keyMap = (next.call ? next.call(null, cm) : next);\n        keyMapChanged(cm);\n      }\n    }, 50);\n\n    var name = keyName(e, true), handled = false;\n    if (!name) return false;\n    var keymaps = allKeyMaps(cm);\n\n    if (e.shiftKey) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      handled = lookupKey(\"Shift-\" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})\n             || lookupKey(name, keymaps, function(b) {\n                  if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                    return doHandleBinding(cm, b);\n                });\n    } else {\n      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });\n    }\n\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }\n      signalLater(cm, \"keyHandled\", cm, name, e);\n    }\n    return handled;\n  }\n\n  function handleCharBinding(cm, e, ch) {\n    var handled = lookupKey(\"'\" + ch + \"'\", allKeyMaps(cm),\n                            function(b) { return doHandleBinding(cm, b, true); });\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      signalLater(cm, \"keyHandled\", cm, \"'\" + ch + \"'\", e);\n    }\n    return handled;\n  }\n\n  function onKeyUp(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    if (e.keyCode == 16) cm.doc.sel.shift = false;\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    ensureFocus(cm);\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    if (old_ie && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    // IE does strange things with escape.\n    cm.doc.sel.shift = code == 16 || e.shiftKey;\n    // First give onKeyEvent option a chance to handle this.\n    var handled = handleKeyBinding(cm, e);\n    if (opera) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection(\"\");\n    }\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    fastPoll(cm);\n  }\n\n  function onFocus(cm) {\n    if (cm.options.readOnly == \"nocursor\") return;\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm);\n      cm.state.focused = true;\n      if (cm.display.wrapper.className.search(/\\bCodeMirror-focused\\b/) == -1)\n        cm.display.wrapper.className += \" CodeMirror-focused\";\n      if (!cm.curOp) {\n        resetInput(cm, true);\n        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730\n      }\n    }\n    slowPoll(cm);\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm);\n      cm.state.focused = false;\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(\" CodeMirror-focused\", \"\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.doc.sel.shift = false;}, 150);\n  }\n\n  var detectingSelectAll;\n  function onContextMenu(cm, e) {\n    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n    var display = cm.display, sel = cm.doc.sel;\n    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;\n\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || opera) return; // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to)))\n      operation(cm, setSelection)(cm.doc, pos, pos);\n\n    var oldCSS = display.input.style.cssText;\n    display.inputDiv.style.position = \"absolute\";\n    display.input.style.cssText = \"position: fixed; width: 30px; height: 30px; top: \" + (e.clientY - 5) +\n      \"px; left: \" + (e.clientX - 5) + \"px; z-index: 1000; background: transparent; outline: none;\" +\n      \"border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);\";\n    focusInput(cm);\n    resetInput(cm, true);\n    // Adds \"Select all\" to context menu in FF\n    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = \" \";\n\n    function prepareSelectAllHack() {\n      if (display.input.selectionStart != null) {\n        var extval = display.input.value = \"\\u200b\" + (posEq(sel.from, sel.to) ? \"\" : display.input.value);\n        display.prevInput = \"\\u200b\";\n        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;\n      }\n    }\n    function rehide() {\n      display.inputDiv.style.position = \"relative\";\n      display.input.style.cssText = oldCSS;\n      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\n      slowPoll(cm);\n\n      // Try to detect the user choosing select-all\n      if (display.input.selectionStart != null) {\n        if (!ie || ie_lt9) prepareSelectAllHack();\n        clearTimeout(detectingSelectAll);\n        var i = 0, poll = function(){\n          if (display.prevInput == \"\\u200b\" && display.input.selectionStart == 0)\n            operation(cm, commands.selectAll)(cm);\n          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);\n          else resetInput(cm);\n        };\n        detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && !ie_lt9) prepareSelectAllHack();\n    if (captureMiddleClick) {\n      e_stop(e);\n      var mouseup = function() {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  }\n\n  // UPDATING\n\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Make sure a position will be valid after the given change.\n  function clipPostChange(doc, change, pos) {\n    if (!posLess(change.from, pos)) return clipPos(doc, pos);\n    var diff = (change.text.length - 1) - (change.to.line - change.from.line);\n    if (pos.line > change.to.line + diff) {\n      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;\n      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);\n      return clipToLen(pos, getLine(doc, preLine).text.length);\n    }\n    if (pos.line == change.to.line + diff)\n      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) +\n                       getLine(doc, change.to.line).text.length - change.to.ch);\n    var inside = pos.line - change.from.line;\n    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));\n  }\n\n  // Hint can be null|\"end\"|\"start\"|\"around\"|{anchor,head}\n  function computeSelAfterChange(doc, change, hint) {\n    if (hint && typeof hint == \"object\") // Assumed to be {anchor, head} object\n      return {anchor: clipPostChange(doc, change, hint.anchor),\n              head: clipPostChange(doc, change, hint.head)};\n\n    if (hint == \"start\") return {anchor: change.from, head: change.from};\n\n    var end = changeEnd(change);\n    if (hint == \"around\") return {anchor: change.from, head: end};\n    if (hint == \"end\") return {anchor: end, head: end};\n\n    // hint is null, leave the selection alone as much as possible\n    var adjustPos = function(pos) {\n      if (posLess(pos, change.from)) return pos;\n      if (!posLess(change.to, pos)) return end;\n\n      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n      if (pos.line == change.to.line) ch += end.ch - change.to.ch;\n      return Pos(line, ch);\n    };\n    return {anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head)};\n  }\n\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Replace the range from from to to by the strings in replacement.\n  // change is a {from, to, text [, origin]} object\n  function makeChange(doc, change, selUpdate, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 1; --i)\n        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [\"\"]});\n      if (split.length)\n        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);\n    } else {\n      makeChangeNoReadonly(doc, change, selUpdate);\n    }\n  }\n\n  function makeChangeNoReadonly(doc, change, selUpdate) {\n    if (change.text.length == 1 && change.text[0] == \"\" && posEq(change.from, change.to)) return;\n    var selAfter = computeSelAfterChange(doc, change, selUpdate);\n    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  function makeChangeFromHistory(doc, type) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n\n    var hist = doc.history;\n    var event = (type == \"undo\" ? hist.done : hist.undone).pop();\n    if (!event) return;\n\n    var anti = {changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,\n                anchorAfter: event.anchorBefore, headAfter: event.headBefore,\n                generation: hist.generation};\n    (type == \"undo\" ? hist.undone : hist.done).push(anti);\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        (type == \"undo\" ? hist.done : hist.undone).length = 0;\n        return;\n      }\n\n      anti.changes.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change, null)\n                    : {anchor: event.anchorBefore, head: event.headBefore};\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      var rebased = [];\n\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  function shiftDoc(doc, distance) {\n    function shiftPos(pos) {return Pos(pos.line + distance, pos.ch);}\n    doc.first += distance;\n    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);\n    doc.sel.head = shiftPos(doc.sel.head); doc.sel.anchor = shiftPos(doc.sel.anchor);\n    doc.sel.from = shiftPos(doc.sel.from); doc.sel.to = shiftPos(doc.sel.to);\n  }\n\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);\n    else updateDoc(doc, change, spans, selAfter);\n  }\n\n  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))\n      cm.curOp.cursorActivity = true;\n\n    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(doc, line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    regChange(cm, from.line, to.line + 1, lendiff);\n\n    if (hasHandler(cm, \"change\")) {\n      var changeObj = {from: from, to: to,\n                       text: change.text,\n                       removed: change.removed,\n                       origin: change.origin};\n      if (cm.curOp.textChanged) {\n        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}\n        cur.next = changeObj;\n      } else cm.curOp.textChanged = changeObj;\n    }\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == \"string\") code = splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin}, null);\n  }\n\n  // POSITION OBJECT\n\n  function Pos(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  }\n  CodeMirror.Pos = Pos;\n\n  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n  function cmp(a, b) {return a.line - b.line || a.ch - b.ch;}\n  function copyPos(x) {return Pos(x.line, x.ch);}\n\n  // SELECTION\n\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\n  // If shift is held, this will move the selection anchor. Otherwise,\n  // it'll set the whole selection.\n  function extendSelection(doc, pos, other, bias) {\n    if (doc.sel.shift || doc.sel.extend) {\n      var anchor = doc.sel.anchor;\n      if (other) {\n        var posBefore = posLess(pos, anchor);\n        if (posBefore != posLess(other, anchor)) {\n          anchor = pos;\n          pos = other;\n        } else if (posBefore != posLess(pos, other)) {\n          pos = other;\n        }\n      }\n      setSelection(doc, anchor, pos, bias);\n    } else {\n      setSelection(doc, pos, other || pos, bias);\n    }\n    if (doc.cm) doc.cm.curOp.userSelChange = true;\n  }\n\n  function filterSelectionChange(doc, anchor, head) {\n    var obj = {anchor: anchor, head: head};\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    obj.anchor = clipPos(doc, obj.anchor); obj.head = clipPos(doc, obj.head);\n    return obj;\n  }\n\n  // Update the selection. Last two args are only used by\n  // updateDoc, since they have to be expressed in the line\n  // numbers before the update.\n  function setSelection(doc, anchor, head, bias, checkAtomic) {\n    if (!checkAtomic && hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\")) {\n      var filtered = filterSelectionChange(doc, anchor, head);\n      head = filtered.head;\n      anchor = filtered.anchor;\n    }\n\n    var sel = doc.sel;\n    sel.goalColumn = null;\n    if (bias == null) bias = posLess(head, sel.head) ? -1 : 1;\n    // Skip over atomic spans.\n    if (checkAtomic || !posEq(anchor, sel.anchor))\n      anchor = skipAtomic(doc, anchor, bias, checkAtomic != \"push\");\n    if (checkAtomic || !posEq(head, sel.head))\n      head = skipAtomic(doc, head, bias, checkAtomic != \"push\");\n\n    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;\n\n    sel.anchor = anchor; sel.head = head;\n    var inv = posLess(head, anchor);\n    sel.from = inv ? head : anchor;\n    sel.to = inv ? anchor : head;\n\n    if (doc.cm)\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged =\n        doc.cm.curOp.cursorActivity = true;\n\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  function reCheckSelection(cm) {\n    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, \"push\");\n  }\n\n  function skipAtomic(doc, pos, bias, mayClear) {\n    var flipped = false, curPos = pos;\n    var dir = bias || 1;\n    doc.cantEdit = false;\n    search: for (;;) {\n      var line = getLine(doc, curPos.line);\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i], m = sp.marker;\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear) {\n              signal(m, \"beforeCursorEnter\");\n              if (m.explicitlyCleared) {\n                if (!line.markedSpans) break;\n                else {--i; continue;}\n              }\n            }\n            if (!m.atomic) continue;\n            var newPos = m.find()[dir < 0 ? \"from\" : \"to\"];\n            if (posEq(newPos, curPos)) {\n              newPos.ch += dir;\n              if (newPos.ch < 0) {\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n                else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n                else newPos = null;\n              }\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\n                  doc.cantEdit = true;\n                  return Pos(doc.first, 0);\n                }\n                flipped = true; newPos = pos; dir = -dir;\n              }\n            }\n            curPos = newPos;\n            continue search;\n          }\n        }\n      }\n      return curPos;\n    }\n  }\n\n  // SCROLLING\n\n  function scrollCursorIntoView(cm) {\n    var coords = scrollPosIntoView(cm, cm.doc.sel.head, null, cm.options.cursorScrollMargin);\n    if (!cm.state.focused) return;\n    var display = cm.display, box = getRect(display.sizer), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n                           (coords.top - display.viewOffset) + \"px; height: \" +\n                           (coords.bottom - coords.top + scrollerCutOff) + \"px; left: \" +\n                           coords.left + \"px; width: 2px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (;;) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) return coords;\n    }\n  }\n\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;\n    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;\n    var gutterw = display.gutters.offsetWidth;\n    var atLeft = x1 < gutterw + 10;\n    if (x1 < screenleft + gutterw || atLeft) {\n      if (atLeft) x1 = 0;\n      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n    } else if (x2 > screenw + screenleft - 3) {\n      result.scrollLeft = x2 + 10 - screenw;\n    }\n    return result;\n  }\n\n  function updateScrollPos(cm, left, top) {\n    cm.curOp.updateScrollPos = {scrollLeft: left == null ? cm.doc.scrollLeft : left,\n                                scrollTop: top == null ? cm.doc.scrollTop : top};\n  }\n\n  function addToScrollPos(cm, left, top) {\n    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop});\n    var scroll = cm.display.scroller;\n    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));\n    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));\n  }\n\n  // API UTILITIES\n\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) how = \"add\";\n    if (how == \"smart\") {\n      if (!cm.doc.mode.indent) how = \"prev\";\n      else state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) line.stateAfter = null;\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString)\n      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n    else if (doc.sel.head.line == n && doc.sel.head.ch < curSpaceString.length)\n      setSelection(doc, Pos(n, curSpaceString.length), Pos(n, curSpaceString.length), 1);\n    line.stateAfter = null;\n  }\n\n  function changeLine(cm, handle, op) {\n    var no = handle, line = handle, doc = cm.doc;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no)) regChange(cm, no, no + 1);\n    else return null;\n    return line;\n  }\n\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    var possible = true;\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return (possible = false);\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == \"char\") moveOnce();\n    else if (unit == \"column\") moveOnce(true);\n    else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || \"\\n\";\n        var type = isWordChar(cur) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) type = \"s\";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n    if (!possible) result.hitSide = true;\n    return result;\n  }\n\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  function findWordAt(line, pos) {\n    var start = pos.ch, end = pos.ch;\n    if (line) {\n      if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n      var startChar = line.charAt(start);\n      var check = isWordChar(startChar) ? isWordChar\n        : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n        : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n      while (start > 0 && check(line.charAt(start - 1))) --start;\n      while (end < line.length && check(line.charAt(end))) ++end;\n    }\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end)};\n  }\n\n  function selectLine(cm, line) {\n    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));\n  }\n\n  // PROTOTYPE\n\n  // The publicly visible API. Note that operation(null, f) means\n  // 'wrap f in an operation, performed on its `this` parameter'\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); focusInput(this); fastPoll(this);},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](map);\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || (typeof maps[i] != \"string\" && maps[i].name == map)) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: operation(null, function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: operation(null, function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: operation(null, function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n        else dir = dir ? \"add\" : \"subtract\";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: operation(null, function(how) {\n      var sel = this.doc.sel;\n      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how, true);\n      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      var doc = this.doc;\n      pos = clipPos(doc, pos);\n      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;\n      var line = getLine(doc, pos.line);\n      var stream = new StringStream(line.text, this.options.tabSize);\n      while (stream.pos < pos.ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = mode.token(stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              className: style || null, // Deprecated, use 'type' instead\n              type: style || null,\n              state: state};\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      if (ch == 0) return styles[2];\n      for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else return styles[mid * 2 + 2];\n      }\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return helpers;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, sel = this.doc.sel;\n      if (start == null) pos = sel.head;\n      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n      else pos = start ? sel.from : sel.to;\n      return cursorCoords(this, pos, mode || \"page\");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, last = this.doc.first + this.doc.size - 1;\n      if (line < this.doc.first) line = this.doc.first;\n      else if (line > last) { line = last; end = true; }\n      var lineObj = getLine(this.doc, line);\n      return intoCoordSystem(this, getLine(this.doc, line), {top: 0, left: 0}, mode || \"page\").top +\n        (end ? lineObj.height : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: operation(null, function(line, gutterID, value) {\n      return changeLine(this, line, function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: operation(null, function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regChange(cm, i, i + 1);\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    addLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;\n        else if (new RegExp(\"(?:^|\\\\s)\" + cls + \"(?:$|\\\\s)\").test(line[prop])) return false;\n        else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n\n    removeLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(new RegExp(\"(?:^|\\\\s+)\" + cls + \"(?:$|\\\\s+)\"));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: operation(null, function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    lineInfo: function(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: operation(null, onKeyDown),\n    triggerOnKeyPress: operation(null, onKeyPress),\n    triggerOnKeyUp: operation(null, onKeyUp),\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd](this);\n    },\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel, pos;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to))\n        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);\n      else\n        pos = dir < 0 ? sel.from : sel.to;\n      extendSelection(this.doc, pos, pos, dir);\n    }),\n\n    deleteH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel;\n      if (!posEq(sel.from, sel.to)) replaceRange(this.doc, \"\", sel.from, sel.to, \"+delete\");\n      else replaceRange(this.doc, \"\", sel.from, findPosH(this.doc, sel.head, dir, unit, false), \"+delete\");\n      this.curOp.userSelChange = true;\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, \"div\");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: operation(null, function(dir, unit) {\n      var sel = this.doc.sel, target, goal;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to)) {\n        var pos = cursorCoords(this, sel.head, \"div\");\n        if (sel.goalColumn != null) pos.left = sel.goalColumn;\n        target = findPosV(this, pos, dir, unit);\n        if (unit == \"page\") addToScrollPos(this, 0, charCoords(this, target, \"div\").top - pos.top);\n        goal = pos.left;\n      } else {\n        target = dir < 0 ? sel.from : sel.to;\n      }\n      extendSelection(this.doc, target, target, dir);\n      if (goal != null) sel.goalColumn = goal;\n    }),\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        this.display.cursor.className += \" CodeMirror-overwrite\";\n      else\n        this.display.cursor.className = this.display.cursor.className.replace(\" CodeMirror-overwrite\", \"\");\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return document.activeElement == this.display.input; },\n\n    scrollTo: operation(null, function(x, y) {\n      updateScrollPos(this, x, y);\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller, co = scrollerCutOff;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,\n              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};\n    },\n\n    scrollIntoView: operation(null, function(range, margin) {\n      if (range == null) range = {from: this.doc.sel.head, to: null};\n      else if (typeof range == \"number\") range = {from: Pos(range, 0), to: null};\n      else if (range.from == null) range = {from: range, to: null};\n      if (!range.to) range.to = range.from;\n      if (!margin) margin = 0;\n\n      var coords = range;\n      if (range.from.line != null) {\n        this.curOp.scrollToPos = {from: range.from, to: range.to, margin: margin};\n        coords = {from: cursorCoords(this, range.from),\n                  to: cursorCoords(this, range.to)};\n      }\n      var sPos = calculateScrollPos(this, Math.min(coords.from.left, coords.to.left),\n                                    Math.min(coords.from.top, coords.to.top) - margin,\n                                    Math.max(coords.from.right, coords.to.right),\n                                    Math.max(coords.from.bottom, coords.to.bottom) + margin);\n      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);\n    }),\n\n    setSize: operation(null, function(width, height) {\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n      if (width != null) this.display.wrapper.style.width = interpret(width);\n      if (height != null) this.display.wrapper.style.height = interpret(height);\n      if (this.options.lineWrapping)\n        this.display.measureLineCache.length = this.display.measureLineCachePos = 0;\n      this.curOp.forceUpdate = true;\n      signal(this, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: operation(null, function() {\n      var oldHeight = this.display.cachedTextHeight;\n      clearCaches(this);\n      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);\n      regChange(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        estimateLineHeights(this);\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: operation(null, function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      resetInput(this, true);\n      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);\n      signalLater(this, \"swapDoc\", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input;},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option(\"mode\", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"specialChars\", /[\\t\\u0000-\\u0019\\u00ad\\u200b\\u2028\\u2029\\ufeff]/g, function(cm, val) {\n    cm.options.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    cm.refresh();\n  }, true);\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option(\"electricChars\", true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", keyMapChanged);\n  option(\"extraKeys\", null);\n\n  option(\"onKeyEvent\", null);\n  option(\"onDragEvent\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, updateScrollbars, true);\n  option(\"lineNumbers\", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n\n  option(\"readOnly\", false, function(cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n      if (!val) resetInput(cm, true);\n    }\n  });\n  option(\"disableInput\", false, function(cm, val) {if (!val) resetInput(cm, true);}, true);\n  option(\"dragDrop\", true);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 40, function(cm, val){cm.doc.history.undoDepth = val;});\n  option(\"historyEventDelay\", 500);\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"crudeMeasuringFrom\", 10000);\n  option(\"moveInputWithCursor\", true, function(cm, val) {\n    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;\n  });\n\n  option(\"tabindex\", null, function(cm, val) {\n    cm.display.input.tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2) {\n      mode.dependencies = [];\n      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);\n    }\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") found = {name: found};\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode(\"application/xml\");\n    }\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // UTILITIES\n\n  CodeMirror.isWordChar = isWordChar;\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because modes\n  // sometimes need to do this.\n  function copyState(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  }\n  CodeMirror.copyState = copyState;\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n  CodeMirror.startState = startState;\n\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));},\n    killLine: function(cm) {\n      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);\n      if (!sel && cm.getLine(from.line).length == from.ch)\n        cm.replaceRange(\"\", from, Pos(from.line + 1, 0), \"+delete\");\n      else cm.replaceRange(\"\", from, sel ? to : Pos(from.line), \"+delete\");\n    },\n    deleteLine: function(cm) {\n      var l = cm.getCursor().line;\n      cm.replaceRange(\"\", Pos(l, 0), Pos(l + 1, 0), \"+delete\");\n    },\n    delLineLeft: function(cm) {\n      var cur = cm.getCursor();\n      cm.replaceRange(\"\", Pos(cur.line, 0), cur, \"+delete\");\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelection(lineStart(cm, cm.getCursor().line));\n    },\n    goLineStartSmart: function(cm) {\n      var cur = cm.getCursor(), start = lineStart(cm, cur.line);\n      var line = cm.getLineHandle(start.line);\n      var order = getOrder(line);\n      if (!order || order[0].level == 0) {\n        var firstNonWS = Math.max(0, line.text.search(/\\S/));\n        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;\n        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));\n      } else cm.extendSelection(start);\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelection(lineEnd(cm, cm.getCursor().line));\n    },\n    goLineRight: function(cm) {\n      var top = cm.charCoords(cm.getCursor(), \"div\").top + 5;\n      cm.extendSelection(cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\"));\n    },\n    goLineLeft: function(cm) {\n      var top = cm.charCoords(cm.getCursor(), \"div\").top + 5;\n      cm.extendSelection(cm.coordsChar({left: 0, top: top}, \"div\"));\n    },\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {\n      cm.replaceSelection(\"\\t\", \"end\", \"+input\");\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.replaceSelection(\"\\t\", \"end\", \"+input\");\n    },\n    transposeChars: function(cm) {\n      var cur = cm.getCursor(), line = cm.getLine(cur.line);\n      if (cur.ch > 0 && cur.ch < line.length - 1)\n        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),\n                        Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));\n    },\n    newlineAndIndent: function(cm) {\n      operation(cm, function() {\n        cm.replaceSelection(\"\\n\", \"end\", \"+input\");\n        cm.indentLine(cm.getCursor().line, null, true);\n      })();\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. Unknown commands are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Down\": \"goDocEnd\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    fallthrough: \"basic\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineStart\", \"Cmd-Right\": \"goLineEnd\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delLineLeft\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\"\n  };\n\n  // KEYMAP DISPATCH\n\n  function getKeyMap(val) {\n    if (typeof val == \"string\") return keyMap[val];\n    else return val;\n  }\n\n  function lookupKey(name, maps, handle) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found === false) return \"stop\";\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) return \"stop\";\n\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != \"[object Array]\")\n        return lookup(fallthrough);\n      for (var i = 0, e = fallthrough.length; i < e; ++i) {\n        var done = lookup(fallthrough[i]);\n        if (done) return done;\n      }\n      return false;\n    }\n\n    for (var i = 0; i < maps.length; ++i) {\n      var done = lookup(maps[i]);\n      if (done) return done != \"stop\";\n    }\n  }\n  function isModifierKey(event) {\n    var name = keyNames[event.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  }\n  function keyName(event, noShift) {\n    if (opera && event.keyCode == 34 && event[\"char\"]) return false;\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey) name = \"Alt-\" + name;\n    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = \"Ctrl-\" + name;\n    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = \"Cmd-\" + name;\n    if (!noShift && event.shiftKey) name = \"Shift-\" + name;\n    return name;\n  }\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.keyName = keyName;\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = document.body;\n      // doc.activeElement occasionally throws on IE\n      try { hasFocus = document.activeElement; } catch(e) {}\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    cm.save = save;\n    cm.getTextArea = function() { return textarea; };\n    cm.toTextArea = function() {\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = \"\";\n      if (textarea.form) {\n        off(textarea.form, \"submit\", save);\n        if (typeof textarea.form.submit == \"function\")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  // The character stream used by a mode's parser.\n  function StringStream(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  }\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n  CodeMirror.StringStream = StringStream;\n\n  // TEXTMARKERS\n\n  function TextMarker(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n  }\n  CodeMirror.TextMarker = TextMarker;\n  eventMixin(TextMarker);\n\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) signalLater(this, \"clear\", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.to != null) max = lineNo(line);\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from != null)\n        min = lineNo(line);\n      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm);\n    }\n    if (withOp) endOperation(cm);\n  };\n\n  TextMarker.prototype.find = function(bothSides) {\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null || span.to != null) {\n        var found = lineNo(line);\n        if (span.from != null) from = Pos(found, span.from);\n        if (span.to != null) to = Pos(found, span.to);\n      }\n    }\n    if (this.type == \"bookmark\" && !bothSides) return from;\n    return from && {from: from, to: to};\n  };\n\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(), cm = this.doc.cm;\n    if (!pos || !cm) return;\n    if (this.type != \"bookmark\") pos = pos.from;\n    var line = getLine(this.doc, pos.line);\n    clearCachedMeasurement(cm, line);\n    if (pos.line >= cm.display.showingFrom && pos.line < cm.display.showingTo) {\n      for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) if (node.lineObj == line) {\n        if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);\n        break;\n      }\n      runInOp(cm, function() {\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = true;\n      });\n    }\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  var nextMarkerId = 0;\n\n  function markText(doc, from, to, options, type) {\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type);\n    if (options) copyObj(options, marker);\n    if (posLess(to, from) || posEq(from, to) && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      marker.collapsed = true;\n      marker.replacedWith = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addToHistory(doc, {from: from, to: to, origin: \"markText\"},\n                   {head: doc.sel.head, anchor: doc.sel.anchor}, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)\n        updateMaxLine = true;\n      var span = {from: null, to: null, marker: marker};\n      if (curLine == from.line) span.from = from.ch;\n      if (curLine == to.line) span.to = to.ch;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, span);\n      ++curLine;\n    });\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      if (marker.atomic) reCheckSelection(cm);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  function SharedTextMarker(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0, me = this; i < markers.length; ++i) {\n      markers[i].parent = this;\n      on(markers[i], \"clear\", function(){me.clear();});\n    }\n  }\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, \"clear\");\n  };\n  SharedTextMarker.prototype.find = function() {\n    return this.primary.find();\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.replacedWith;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.replacedWith = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  // TEXTMARKER SPANS\n\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push({from: span.from,\n                                to: endsAfter ? null : span.to,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,\n                                to: span.to == null ? null : span.to - endCh,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function stretchSpansOverChange(doc, change) {\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find();\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;\n        var newParts = [j, 1];\n        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))\n          newParts.push({from: p.from, to: m.from});\n        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(true);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (cmp(found.to, from) || extraRight(sp.marker) - extraLeft(marker)) > 0 ||\n          fromCmp >= 0 && (cmp(found.from, to) || extraLeft(sp.marker) - extraRight(marker)) < 0)\n        return true;\n    }\n  }\n\n  function visualLine(doc, line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(doc, merged.find().from.line);\n    return line;\n  }\n\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.replacedWith) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find().to, endLine = getLine(doc, end.line);\n      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // LINE WIDGETS\n\n  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.cm = cm;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n  function widgetOperation(f) {\n    return function() {\n      var withOp = !this.cm.curOp;\n      if (withOp) startOperation(this.cm);\n      try {var result = f.apply(this, arguments);}\n      finally {if (withOp) endOperation(this.cm);}\n      return result;\n    };\n  }\n  LineWidget.prototype.clear = widgetOperation(function() {\n    var ws = this.line.widgets, no = lineNo(this.line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) this.line.widgets = null;\n    var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;\n    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));\n    if (aboveVisible) addToScrollPos(this.cm, 0, -this.height);\n    regChange(this.cm, no, no + 1);\n  });\n  LineWidget.prototype.changed = widgetOperation(function() {\n    var oldH = this.height;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(this.line, this.line.height + diff);\n    var no = lineNo(this.line);\n    regChange(this.cm, no, no + 1);\n  });\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)\n      removeChildrenAndAdd(widget.cm.display.measure, elt(\"div\", [widget.node], null, \"position: relative\"));\n    return widget.height = widget.node.offsetHeight;\n  }\n\n  function addLineWidget(cm, handle, node, options) {\n    var widget = new LineWidget(cm, node, options);\n    if (widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(cm, handle, function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {\n        var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, 0, widget.height);\n        cm.curOp.forceUpdate = true;\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Run the given mode's parser over a line, update the styles\n  // array, which contains alternating fragments of text and CSS\n  // classes.\n  function runMode(cm, text, mode, state, f, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    if (text == \"\" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = mode.token(stream, state);\n      }\n      if (cm.options.addModeClass) {\n        var mName = CodeMirror.innerMode(mode, state).mode.name;\n        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        if (curStart < stream.start) f(stream.start, curStyle);\n        curStart = stream.start; curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen];\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = cur ? cur + \" \" + style : style;\n          }\n        }\n      });\n    }\n\n    return st;\n  }\n\n  function getLineStyles(cm, line) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen)\n      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {\n      mode.token(stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, builder) {\n    if (!style) return null;\n    for (;;) {\n      var lineClass = style.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      style = style.slice(0, lineClass.index) + style.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (builder[prop] == null)\n        builder[prop] = lineClass[2];\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(builder[prop]))\n        builder[prop] += \" \" + lineClass[2];\n    }\n    if (/^\\s*$/.test(style)) return null;\n    var cache = builder.cm.options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  }\n\n  function buildLineContent(cm, realLine, measure, copyWidgets) {\n    var merged, line = realLine, empty = true;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(cm.doc, merged.find().from.line);\n\n    var builder = {pre: elt(\"pre\"), col: 0, pos: 0,\n                   measure: null, measuredSomething: false, cm: cm,\n                   copyWidgets: copyWidgets};\n\n    do {\n      if (line.text) empty = false;\n      builder.measure = line == realLine && measure;\n      builder.pos = 0;\n      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;\n      if ((ie || webkit) && cm.getOption(\"lineWrapping\"))\n        builder.addToken = buildTokenSplitSpaces(builder.addToken);\n      var next = insertLineContent(line, builder, getLineStyles(cm, line));\n      if (measure && line == realLine && !builder.measuredSomething) {\n        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));\n        builder.measuredSomething = true;\n      }\n      if (next) line = getLine(cm.doc, next.to.line);\n    } while (next);\n\n    if (measure && !builder.measuredSomething && !measure[0])\n      measure[0] = builder.pre.appendChild(empty ? elt(\"span\", \"\\u00a0\") : zeroWidthElement(cm.display.measure));\n    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))\n      builder.pre.appendChild(document.createTextNode(\"\\u00a0\"));\n\n    var order;\n    // Work around problem with the reported dimensions of single-char\n    // direction spans on IE (issue #1129). See also the comment in\n    // cursorCoords.\n    if (measure && ie && (order = getOrder(line))) {\n      var l = order.length - 1;\n      if (order[l].from == order[l].to) --l;\n      var last = order[l], prev = order[l - 1];\n      if (last.from + 1 == last.to && prev && last.level < prev.level) {\n        var span = measure[builder.pos - 1];\n        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure),\n                                               span.nextSibling);\n      }\n    }\n\n    var textClass = builder.textClass ? builder.textClass + \" \" + (realLine.textClass || \"\") : realLine.textClass;\n    if (textClass) builder.pre.className = textClass;\n\n    signal(cm, \"renderLine\", cm, realLine, builder.pre);\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    return token;\n  }\n\n  function buildToken(builder, text, style, startStyle, endStyle, title) {\n    if (!text) return;\n    var special = builder.cm.options.specialChars;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(text);\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));\n          builder.col += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          builder.col += tabWidth;\n        } else {\n          var token = builder.cm.options.specialCharPlaceholder(m[0]);\n          content.appendChild(token);\n          builder.col += 1;\n        }\n      }\n    }\n    if (style || startStyle || endStyle || builder.measure) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt(\"span\", [content], fullStyle);\n      if (title) token.title = title;\n      return builder.pre.appendChild(token);\n    }\n    builder.pre.appendChild(content);\n  }\n\n  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {\n    var wrapping = builder.cm.options.lineWrapping;\n    for (var i = 0; i < text.length; ++i) {\n      var start = i == 0, to = i + 1;\n      while (to < text.length && isExtendingChar(text.charAt(to))) ++to;\n      var ch = text.slice(i, to);\n      i = to - 1;\n      if (i && wrapping && spanAffectsWrapping(text, i))\n        builder.pre.appendChild(elt(\"wbr\"));\n      var old = builder.measure[builder.pos];\n      var span = builder.measure[builder.pos] =\n        buildToken(builder, ch, style,\n                   start && startStyle, i == text.length - 1 && endStyle);\n      if (old) span.leftSide = old.leftSide || old;\n      // In IE single-space nodes wrap differently than spaces\n      // embedded in larger text nodes, except when set to\n      // white-space: normal (issue #1268).\n      if (old_ie && wrapping && ch == \" \" && i && !/\\s/.test(text.charAt(i - 1)) &&\n          i < text.length - 1 && !/\\s/.test(text.charAt(i + 1)))\n        span.style.whiteSpace = \"normal\";\n      builder.pos += ch.length;\n    }\n    if (text.length) builder.measuredSomething = true;\n  }\n\n  function buildTokenSplitSpaces(inner) {\n    function split(old) {\n      var out = \" \";\n      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? \" \" : \"\\u00a0\";\n      out += \" \";\n      return out;\n    }\n    return function(builder, text, style, startStyle, endStyle, title) {\n      return inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.replacedWith;\n    if (widget) {\n      if (builder.copyWidgets) widget = widget.cloneNode(true);\n      builder.pre.appendChild(widget);\n      if (builder.measure) {\n        if (size) {\n          builder.measure[builder.pos] = widget;\n        } else {\n          var elt = zeroWidthElement(builder.cm.display.measure);\n          if (marker.type == \"bookmark\" && !marker.insertLeft)\n            builder.measure[builder.pos] = builder.pre.appendChild(elt);\n          else if (builder.measure[builder.pos])\n            return;\n          else\n            builder.measure[builder.pos] = builder.pre.insertBefore(elt, widget);\n        }\n        builder.measuredSomething = true;\n      }\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = \"\";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [];\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\n            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = \"\"; }\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += \" \" + m.endStyle;\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n          if (m.type == \"bookmark\" && sp.from == pos && m.replacedWith) foundBookmarks.push(m);\n        }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return collapsed.marker.find();\n        }\n        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // First adjust the line structure\n    if (from.ch == 0 && to.ch == 0 && lastText == \"\" &&\n        (!doc.cm || doc.cm.options.wholeLineUpdateBefore)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)\n          added.push(new Line(text[i], spansFor(i), estimateHeight));\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n    setSelection(doc, selAfter.anchor, selAfter.head, null, true);\n  }\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n    collapse: function(lines) {\n      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n    },\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;\n    },\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0, e = children.length; i < e; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      if (this.size - n < 25) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.history = makeHistory();\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = {from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null};\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n\n    if (typeof text == \"string\") text = splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text}, null, {head: start, anchor: start});\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || \"\\n\");\n    },\n    setValue: function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: splitLines(code), origin: \"setValue\"},\n                 {head: top, anchor: top}, true);\n    },\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || \"\\n\");\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n    setLine: function(line, text) {\n      if (isLine(this, line))\n        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));\n    },\n    removeLine: function(line) {\n      if (line) replaceRange(this, \"\", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));\n      else replaceRange(this, \"\", Pos(0, 0), clipPos(this, Pos(1, 0)));\n    },\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") line = getLine(this, line);\n      return visualLine(this, line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var sel = this.sel, pos;\n      if (start == null || start == \"head\") pos = sel.head;\n      else if (start == \"anchor\") pos = sel.anchor;\n      else if (start == \"end\" || start === false) pos = sel.to;\n      else pos = sel.from;\n      return copyPos(pos);\n    },\n    somethingSelected: function() {return !posEq(this.sel.head, this.sel.anchor);},\n\n    setCursor: docOperation(function(line, ch, extend) {\n      var pos = clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line);\n      if (extend) extendSelection(this, pos);\n      else setSelection(this, pos, pos);\n    }),\n    setSelection: docOperation(function(anchor, head, bias) {\n      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), bias);\n    }),\n    extendSelection: docOperation(function(from, to, bias) {\n      extendSelection(this, clipPos(this, from), to && clipPos(this, to), bias);\n    }),\n\n    getSelection: function(lineSep) {return this.getRange(this.sel.from, this.sel.to, lineSep);},\n    replaceSelection: function(code, collapse, origin) {\n      makeChange(this, {from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin}, collapse || \"around\");\n    },\n    undo: docOperation(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docOperation(function() {makeChangeFromHistory(this, \"redo\");}),\n\n    setExtending: function(val) {this.sel.extend = val;},\n\n    historySize: function() {\n      var hist = this.history;\n      return {undo: hist.done.length, redo: hist.undone.length};\n    },\n    clearHistory: function() {this.history = makeHistory(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = makeHistory(this.history.maxGeneration);\n      hist.done = histData.done.slice(0);\n      hist.undone = histData.undone.slice(0);\n    },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, \"range\");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    findMarks: function(from, to) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function(line) {\n        var spans = line.markedSpans;\n        if (spans) for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(lineNo == from.line && from.ch > span.to ||\n                span.from == null && lineNo != from.line||\n                lineNo == to.line && span.from > to.ch))\n            found.push(span.marker.parent || span.marker);\n        }\n        ++lineNo;\n      });\n      return found;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = {from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,\n                 shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn};\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = makeHistory();\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;}\n  });\n\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // The Doc methods that should be available on CodeMirror instances\n  var dontDelegate = \"iter insert remove copy getEditor\".split(\" \");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error(\"This document is already in use.\");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) computeMaxLength(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  function getLine(chunk, n) {\n    n -= chunk.first;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n  function heightAtLine(cm, lineObj) {\n    lineObj = visualLine(cm.doc, lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function makeHistory(startGen) {\n    return {\n      // Arrays of history events. Doing something adds an event to\n      // done and clears undo. Undoing moves events from done to\n      // undone, redoing moves them in the other direction.\n      done: [], undone: [], undoDepth: Infinity,\n      // Used to track when changes can be merged into a single undo\n      // event\n      lastTime: 0, lastOp: null, lastOrigin: null,\n      // Used by the isClean() method\n      generation: startGen || 1, maxGeneration: startGen || 1\n    };\n  }\n\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  function historyChangeFromChange(doc, change) {\n    var from = { line: change.from.line, ch: change.from.ch };\n    var histChange = {from: from, to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  function addToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur = lst(hist.done);\n\n    if (cur &&\n        (hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == \"*\"))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n      cur.anchorAfter = selAfter.anchor; cur.headAfter = selAfter.head;\n    } else {\n      // Can not be merged, start a new event.\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation,\n             anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,\n             anchorAfter: selAfter.anchor, headAfter: selAfter.head};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth)\n        hist.done.shift();\n    }\n    hist.generation = ++hist.maxGeneration;\n    hist.lastTime = time;\n    hist.lastOp = opId;\n    hist.lastOrigin = change.origin;\n\n    if (!last) signal(doc, \"historyAdded\");\n  }\n\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i], changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,\n                 anchorAfter: event.anchorAfter, headAfter: event.headAfter});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSel(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (!sub.copied) { cur.from = copyPos(cur.from); cur.to = copyPos(cur.to); }\n        if (to < cur.from.line) {\n          cur.from.line += diff;\n          cur.to.line += diff;\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!sub.copied) {\n        sub.anchorBefore = copyPos(sub.anchorBefore); sub.headBefore = copyPos(sub.headBefore);\n        sub.anchorAfter = copyPos(sub.anchorAfter); sub.readAfter = copyPos(sub.headAfter);\n        sub.copied = true;\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      } else {\n        rebaseHistSel(sub.anchorBefore); rebaseHistSel(sub.headBefore);\n        rebaseHistSel(sub.anchorAfter); rebaseHistSel(sub.headAfter);\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT OPERATORS\n\n  function stopMethod() {e_stop(this);}\n  // Ensure an event has a stop method.\n  function addStop(event) {\n    if (!event.stop) event.stop = stopMethod;\n    return event;\n  }\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  function on(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent(\"on\" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent(\"on\" + type, f);\n    else {\n      var arr = emitter._handlers && emitter._handlers[type];\n      if (!arr) return;\n      for (var i = 0; i < arr.length; ++i)\n        if (arr[i] == f) { arr.splice(i, 1); break; }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\n  }\n\n  var delayedCallbacks, delayedCallbackDepth = 0;\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    if (!delayedCallbacks) {\n      ++delayedCallbackDepth;\n      delayedCallbacks = [];\n      setTimeout(fireDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      delayedCallbacks.push(bnd(arr[i]));\n  }\n\n  function signalDOMEvent(cm, e, override) {\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function fireDelayed() {\n    --delayedCallbackDepth;\n    var delayed = delayedCallbacks;\n    delayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  function hasHandler(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length > 0;\n  }\n\n  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;\n\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerCutOff = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {\n      if (string.charAt(i) == \"\\t\") n += tabSize - (n % tabSize);\n      else ++n;\n    }\n    return n;\n  }\n  CodeMirror.countColumn = countColumn;\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  function selectInput(node) {\n    if (ios) { // Mobile Safari apparently has a bug where select() is broken.\n      node.selectionStart = 0;\n      node.selectionEnd = node.value.length;\n    } else {\n      // Suppress mysterious IE10 errors\n      try { node.select(); }\n      catch(_e) {}\n    }\n  }\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  function createObj(base, props) {\n    function Obj() {}\n    Obj.prototype = base;\n    var inst = new Obj();\n    if (props) copyObj(props, inst);\n    return inst;\n  }\n\n  function copyObj(obj, target) {\n    if (!target) target = {};\n    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];\n    return target;\n  }\n\n  function emptyArray(size) {\n    for (var a = [], i = 0; i < size; ++i) a.push(undefined);\n    return a;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordChar(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") setTextContent(e, content);\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function setTextContent(e, str) {\n    if (ie_lt9) {\n      e.innerHTML = \"\";\n      e.appendChild(document.createTextNode(str));\n    } else e.textContent = str;\n  }\n\n  function getRect(node) {\n    return node.getBoundingClientRect();\n  }\n  CodeMirror.replaceGetRect = function(f) { getRect = f; };\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie_lt9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  // For a reason I have yet to figure out, some browsers disallow\n  // word wrapping between certain characters *only* if a new inline\n  // element is started between them. This makes it hard to reliably\n  // measure the position of things, since that requires inserting an\n  // extra span. This terribly fragile set of tests matches the\n  // character combinations that suffer from this phenomenon on the\n  // various browsers.\n  function spanAffectsWrapping() { return false; }\n  if (gecko) // Only for \"$'\"\n    spanAffectsWrapping = function(str, i) {\n      return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;\n    };\n  else if (safari && !/Version\\/([6-9]|\\d\\d)\\b/.test(navigator.userAgent))\n    spanAffectsWrapping = function(str, i) {\n      return /\\-[^ \\-?]|\\?[^ !\\'\\\"\\),.\\-\\/:;\\?\\]\\}]/.test(str.slice(i - 1, i + 1));\n    };\n  else if (webkit && /Chrome\\/(?:29|[3-9]\\d|\\d\\d\\d)\\./.test(navigator.userAgent))\n    spanAffectsWrapping = function(str, i) {\n      var code = str.charCodeAt(i - 1);\n      return code >= 8208 && code <= 8212;\n    };\n  else if (webkit)\n    spanAffectsWrapping = function(str, i) {\n      if (i > 1 && str.charCodeAt(i - 1) == 45) {\n        if (/\\w/.test(str.charAt(i - 2)) && /[^\\-?\\.]/.test(str.charAt(i))) return true;\n        if (i > 2 && /[\\d\\.,]/.test(str.charAt(i - 2)) && /[\\d\\.,]/.test(str.charAt(i))) return false;\n      }\n      return /[~!#%&*)=+}\\]\\\\|\\\"\\.>,:;][({[<]|-[^\\-?\\.\\u2010-\\u201f\\u2026]|\\?[\\w~`@#$%\\^&*(_=+{[|><]|\\u2026[\\w~`@#$%\\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));\n    };\n\n  var knownScrollbarWidth;\n  function scrollbarWidth(measure) {\n    if (knownScrollbarWidth != null) return knownScrollbarWidth;\n    var test = elt(\"div\", null, null, \"width: 50px; height: 50px; overflow-x: scroll\");\n    removeChildrenAndAdd(measure, test);\n    if (test.offsetWidth)\n      knownScrollbarWidth = test.offsetHeight - test.clientHeight;\n    return knownScrollbarWidth || 0;\n  }\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;\n    }\n    if (zwspSupported) return elt(\"span\", \"\\u200b\");\n    else return elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n  CodeMirror.splitLines = splitLines;\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == 'function';\n  })();\n\n  // KEY NAMING\n\n  var keyNames = {3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n                  19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n                  36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n                  46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\", 107: \"=\", 109: \"-\", 127: \"Delete\",\n                  173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n                  221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n                  63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, \"ltr\");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(cm.doc, line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line;\n    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))\n      lineN = merged.find().to.line;\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN, ch);\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is somewhat involved. It is needed in order to move\n  // 'visually' through bi-directional text -- i.e., pressing left\n  // should make the cursor go left, even when in RTL text. The\n  // tricky part is the 'jumps', where RTL and LTR text touch each\n  // other. This often requires the cursor offset to move more than\n  // one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL\";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr\";\n    function charType(code) {\n      if (code <= 0xff) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);\n      else if (0x700 <= code && code <= 0x8ac) return \"r\";\n      else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = \"L\";\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n        else if (type == \",\" && prev == types[i+1] &&\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";\n        else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == \"L\";\n          var after = (end < len ? types[end] : outerType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push({from: start, to: i, level: 0});\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, {from: nstart, to: j, level: 2});\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift({from: 0, to: m[0].length, level: 0});\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push({from: len - m[0].length, to: len, level: 0});\n      }\n      if (order[0].level != lst(order).level)\n        order.push({from: len, to: len, level: order[0].level});\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = \"3.22.0\";\n\n  return CodeMirror;\n})();\n","// TODO actually recognize syntax of TypeScript constructs\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    var jsKeywords = {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"delete\": C, \"throw\": C, \"debugger\": C,\n      \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"module\": kw(\"module\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: \"variable\", style: \"variable-3\"};\n      var tsKeywords = {\n        // object-like things\n        \"interface\": kw(\"interface\"),\n        \"extends\": kw(\"extends\"),\n        \"constructor\": kw(\"constructor\"),\n\n        // scope modifiers\n        \"public\": kw(\"public\"),\n        \"private\": kw(\"private\"),\n        \"protected\": kw(\"protected\"),\n        \"static\": kw(\"static\"),\n\n        // types\n        \"string\": type, \"number\": type, \"bool\": type, \"any\": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (state.lastType == \"operator\" || state.lastType == \"keyword c\" ||\n               state.lastType == \"sof\" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n        readRegexp(stream);\n        stream.eatWhile(/[gimy]/); // 'y' is \"sticky\" option in Mozilla\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", \"operator\", stream.current());\n    } else {\n      stream.eatWhile(/[\\w\\$_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != \".\") ? ret(known.type, known.style, word) :\n                     ret(\"variable\", \"variable\", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) break;\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (/[$\\w]/.test(ch)) {\n        sawSomething = true;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: {name: \"arguments\"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    return function(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(arguments.callee);\n    };\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value.length), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), block, poplex);\n    if (type == \";\") return cont();\n    if (type == \"if\") return cont(pushlex(\"form\"), expression, statement, poplex, maybeelse);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"module\") return cont(pushlex(\"form\"), pushcontext, afterModule, popcontext, poplex);\n    if (type == \"class\") return cont(pushlex(\"form\"), className, objlit, poplex);\n    if (type == \"export\") return cont(pushlex(\"form\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"form\"), afterImport, poplex);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(pattern, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"keyword c\") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, comprehension, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (value == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { cx.cc.push(me); return quasi(value); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n  }\n  function quasi(value) {\n    if (value.slice(value.length - 2) != \"${\") return cont();\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont();\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    if (type == \"{\") return pass(statement);\n    return pass(expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    if (type == \"{\") return pass(statement);\n    return pass(expressionNoComma);\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"variable\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (type + \" property\");\n    } else if (type == \"[\") {\n      return cont(expression, expect(\"]\"), afterprop);\n    }\n    if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(what, proceed);\n      }\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (isTS && type == \":\") return cont(typedef);\n  }\n  function typedef(type) {\n    if (type == \"variable\"){cx.marked = \"variable-3\"; return cont();}\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"[\") return contCommasep(pattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, expect(\")\"), poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, expect(\";\"), forspec2);\n    if (type == \";\") return cont(forspec2);\n    if (type == \"variable\") return cont(formaybeinof);\n    return pass(expression, expect(\";\"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == \";\") return cont(forspec3);\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression); }\n    return pass(expression, expect(\";\"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != \")\") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, statement, popcontext);\n  }\n  function funarg(type) {\n    if (type == \"spread\") return cont(funarg);\n    return pass(pattern, maybetype);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(_type, value) {\n    if (value == \"extends\") return cont(expression);\n  }\n  function objlit(type) {\n    if (type == \"{\") return contCommasep(objprop, \"}\");\n  }\n  function afterModule(type, value) {\n    if (type == \"string\") return cont(statement);\n    if (type == \"variable\") { register(value); return cont(maybeFrom); }\n  }\n  function afterExport(_type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    return pass(statement);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    return pass(importSpec, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    return cont();\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(expressionNoComma, maybeArrayComprehension);\n  }\n  function maybeArrayComprehension(type) {\n    if (type == \"for\") return pass(comprehension, expect(\"]\"));\n    if (type == \",\") return cont(commasep(expressionNoComma, \"]\"));\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function comprehension(type) {\n    if (type == \"for\") return cont(forspec, comprehension);\n    if (type == \"if\") return cont(expression, comprehension);\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars) state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: \":{}\",\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode\n  };\n});\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n",".CodeMirror-hints {\n  position: absolute;\n  z-index: 10;\n  overflow: hidden;\n  list-style: none;\n\n  margin: 0;\n  padding: 2px;\n\n  -webkit-box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n  -moz-box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n  box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n  border-radius: 3px;\n  border: 1px solid silver;\n\n  background: white;\n  font-size: 90%;\n  font-family: monospace;\n\n  max-height: 20em;\n  overflow-y: auto;\n}\n\n.CodeMirror-hint {\n  margin: 0;\n  padding: 0 4px;\n  border-radius: 2px;\n  max-width: 19em;\n  overflow: hidden;\n  white-space: pre;\n  color: black;\n  cursor: pointer;\n}\n\n.CodeMirror-hint-active {\n  background: #08f;\n  color: white;\n}\n","/* The lint marker gutter */\n.CodeMirror-lint-markers {\n  width: 16px;\n}\n\n.CodeMirror-lint-tooltip {\n  background-color: infobackground;\n  border: 1px solid black;\n  border-radius: 4px 4px 4px 4px;\n  color: infotext;\n  font-family: monospace;\n  font-size: 10pt;\n  overflow: hidden;\n  padding: 2px 5px;\n  position: fixed;\n  white-space: pre;\n  white-space: pre-wrap;\n  z-index: 100;\n  max-width: 600px;\n  opacity: 0;\n  transition: opacity .4s;\n  -moz-transition: opacity .4s;\n  -webkit-transition: opacity .4s;\n  -o-transition: opacity .4s;\n  -ms-transition: opacity .4s;\n}\n\n.CodeMirror-lint-mark-error, .CodeMirror-lint-mark-warning {\n  background-position: left bottom;\n  background-repeat: repeat-x;\n}\n\n.CodeMirror-lint-mark-error {\n  background-image:\n  url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==\")\n  ;\n}\n\n.CodeMirror-lint-mark-warning {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=\");\n}\n\n.CodeMirror-lint-marker-error, .CodeMirror-lint-marker-warning {\n  background-position: center center;\n  background-repeat: no-repeat;\n  cursor: pointer;\n  display: inline-block;\n  height: 16px;\n  width: 16px;\n  vertical-align: middle;\n  position: relative;\n}\n\n.CodeMirror-lint-message-error, .CodeMirror-lint-message-warning {\n  padding-left: 18px;\n  background-position: top left;\n  background-repeat: no-repeat;\n}\n\n.CodeMirror-lint-marker-error, .CodeMirror-lint-message-error {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=\");\n}\n\n.CodeMirror-lint-marker-warning, .CodeMirror-lint-message-warning {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=\");\n}\n\n.CodeMirror-lint-marker-multiple {\n  background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC\");\n  background-repeat: no-repeat;\n  background-position: right bottom;\n  width: 100%; height: 100%;\n}\n","/* BASICS */\n\n.CodeMirror {\n  /* Set height, width, borders, and global font properties here */\n  font-family: monospace;\n  height: 300px;\n}\n.CodeMirror-scroll {\n  /* Set scrolling behaviour here */\n  overflow: auto;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n  padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre {\n  padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n  border-right: 1px solid #ddd;\n  background-color: #f7f7f7;\n  white-space: nowrap;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n  padding: 0 3px 0 5px;\n  min-width: 20px;\n  text-align: right;\n  color: #999;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n/* CURSOR */\n\n.CodeMirror div.CodeMirror-cursor {\n  border-left: 1px solid black;\n  z-index: 3;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n  border-left: 1px solid silver;\n}\n.CodeMirror.cm-keymap-fat-cursor div.CodeMirror-cursor {\n  width: auto;\n  border: 0;\n  background: #7e7;\n  z-index: 1;\n}\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror div.CodeMirror-cursor.CodeMirror-overwrite {}\n\n.cm-tab { display: inline-block; }\n\n.CodeMirror-ruler {\n  border-left: 1px solid #ccc;\n  position: absolute;\n}\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable {color: black;}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3 {color: #085;}\n.cm-s-default .cm-property {color: black;}\n.cm-s-default .cm-operator {color: black;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n\n.cm-s-default .cm-error {color: #f00;}\n.cm-invalidchar {color: #f00;}\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}\n.CodeMirror-activeline-background {background: #e8f2ff;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\n   the editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n  line-height: 1;\n  position: relative;\n  overflow: hidden;\n  background: white;\n  color: black;\n}\n\n.CodeMirror-scroll {\n  /* 30px is the magic margin used to hide the element's real scrollbars */\n  /* See overflow: hidden in .CodeMirror */\n  margin-bottom: -30px; margin-right: -30px;\n  padding-bottom: 30px;\n  height: 100%;\n  outline: none; /* Prevent dragging from highlighting the element */\n  position: relative;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n.CodeMirror-sizer {\n  position: relative;\n  border-right: 30px solid transparent;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\n   before actuall scrolling happens, thus preventing shaking and\n   flickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\n  position: absolute;\n  z-index: 6;\n  display: none;\n}\n.CodeMirror-vscrollbar {\n  right: 0; top: 0;\n  overflow-x: hidden;\n  overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n  bottom: 0; left: 0;\n  overflow-y: hidden;\n  overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n  right: 0; bottom: 0;\n}\n.CodeMirror-gutter-filler {\n  left: 0; bottom: 0;\n}\n\n.CodeMirror-gutters {\n  position: absolute; left: 0; top: 0;\n  padding-bottom: 30px;\n  z-index: 3;\n}\n.CodeMirror-gutter {\n  white-space: normal;\n  height: 100%;\n  -moz-box-sizing: content-box;\n  box-sizing: content-box;\n  padding-bottom: 30px;\n  margin-bottom: -32px;\n  display: inline-block;\n  /* Hack to make IE7 behave */\n  *zoom:1;\n  *display:inline;\n}\n.CodeMirror-gutter-elt {\n  position: absolute;\n  cursor: default;\n  z-index: 4;\n}\n\n.CodeMirror-lines {\n  cursor: text;\n}\n.CodeMirror pre {\n  /* Reset some styles that the rest of the page might have set */\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n  border-width: 0;\n  background: transparent;\n  font-family: inherit;\n  font-size: inherit;\n  margin: 0;\n  white-space: pre;\n  word-wrap: normal;\n  line-height: inherit;\n  color: inherit;\n  z-index: 2;\n  position: relative;\n  overflow: visible;\n}\n.CodeMirror-wrap pre {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  word-break: normal;\n}\n\n.CodeMirror-linebackground {\n  position: absolute;\n  left: 0; right: 0; top: 0; bottom: 0;\n  z-index: 0;\n}\n\n.CodeMirror-linewidget {\n  position: relative;\n  z-index: 2;\n  overflow: auto;\n}\n\n.CodeMirror-widget {}\n\n.CodeMirror-wrap .CodeMirror-scroll {\n  overflow-x: hidden;\n}\n\n.CodeMirror-measure {\n  position: absolute;\n  width: 100%;\n  height: 0;\n  overflow: hidden;\n  visibility: hidden;\n}\n.CodeMirror-measure pre { position: static; }\n\n.CodeMirror div.CodeMirror-cursor {\n  position: absolute;\n  visibility: hidden;\n  border-right: none;\n  width: 0;\n}\n.CodeMirror-focused div.CodeMirror-cursor {\n  visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n\n.cm-searching {\n  background: #ffa;\n  background: rgba(255, 255, 0, .4);\n}\n\n/* IE7 hack to prevent it from returning funny offsetTops on the spans */\n.CodeMirror span { *vertical-align: text-bottom; }\n\n@media print {\n  /* Hide the cursor when printing */\n  .CodeMirror div.CodeMirror-cursor {\n    visibility: hidden;\n  }\n}\n","/*\nCopyright (C) 2011 by MarkLogic Corporation\nAuthor: Mike Brevoort <mike@brevoort.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n.cm-s-xq-light span.cm-keyword {line-height: 1em; font-weight: bold; color: #5A5CAD; }\n.cm-s-xq-light span.cm-atom {color: #6C8CD5;}\n.cm-s-xq-light span.cm-number {color: #164;}\n.cm-s-xq-light span.cm-def {text-decoration:underline;}\n.cm-s-xq-light span.cm-variable {color: black; }\n.cm-s-xq-light span.cm-variable-2 {color:black;}\n.cm-s-xq-light span.cm-variable-3 {color: black; }\n.cm-s-xq-light span.cm-property {}\n.cm-s-xq-light span.cm-operator {}\n.cm-s-xq-light span.cm-comment {color: #0080FF; font-style: italic;}\n.cm-s-xq-light span.cm-string {color: red;}\n.cm-s-xq-light span.cm-meta {color: yellow;}\n.cm-s-xq-light span.cm-qualifier {color: grey}\n.cm-s-xq-light span.cm-builtin {color: #7EA656;}\n.cm-s-xq-light span.cm-bracket {color: #cc7;}\n.cm-s-xq-light span.cm-tag {color: #3F7F7F;}\n.cm-s-xq-light span.cm-attribute {color: #7F007F;}\n.cm-s-xq-light span.cm-error {color: #f00;}\n\n.cm-s-xq-light .CodeMirror-activeline-background {background: #e8f2ff !important;}\n.cm-s-xq-light .CodeMirror-matchingbracket {outline:1px solid grey;color:black !important;background:yellow;}","@import \"fonts/Helvetica/helvetica.css\";@import \"fonts/Inconsolata/inconsolata.css\";html,body{border:0;font-family:\"Helvetica-Neue\",\"Helvetica\",Arial,sans-serif;line-height:1.5;margin:0;padding:0}div,span,object,iframe,img,table,caption,thead,tbody,tfoot,tr,tr,td,article,aside,canvas,details,figure,hgroup,menu,nav,footer,header,section,summary,mark,audio,video{border:0;margin:0;padding:0}h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,address,cit,code,del,dfn,em,ins,q,samp,small,strong,sub,sup,b,i,hr,dl,dt,dd,ol,ul,li,fieldset,legend,label{border:0;font-size:100%;vertical-align:baseline;margin:0;padding:0}article,aside,canvas,figure,figure img,figcaption,hgroup,footer,header,nav,section,audio,video{display:block}table{border-collapse:separate;border-spacing:0}table caption,table th,table td{text-align:left;vertical-align:middle}a img{border:0}:focus{outline:0}*,*:before,*:after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}body{color:#222;margin:0;padding:0;border:0;font-family:\"Helvetica Neue LT Std\";font-size:48pt;line-height:1.2em;visibility:visible}p,a,li,li:before,h1,h2,h3,h4,h5,h6{text-shadow:0 0 .1em rgba(0,0,0,0.5)}h1,h2,h3,h4,h5,h6{text-align:center;font-weight:bold;background-color:rgba(0,0,0,0.1);margin:.4em -100%}h1{font-size:1.6em;padding-top:.25em}h2{font-size:1.4em;padding-top:.3em}h3{font-size:1.2em;padding-top:.3em}h4,h5,h6{font-size:1.1em;padding-top:.3em}ul li,ol li{list-style:none;position:relative}ul li:before,ol li:before{color:#888;text-align:right;position:absolute;left:0}ul li:before{content:' ';width:1em;height:1em;margin-left:-1em;background:url(../../m/doge.svg);background-size:contain}strong{letter-spacing:.05em}#slides{z-index:1;position:fixed;background:#ccc}#slides,#slides .background{background-size:cover;width:100%;height:100%;margin:0;padding:0;border:0}#slides .background{z-index:2;position:absolute;opacity:0;-webkit-transition:opacity .3s ease;-moz-transition:opacity .3s ease;transition:opacity .3s ease}#slides .background.active{opacity:1}#slides section{z-index:10;background:rgba(255,255,255,0.8);background-size:cover;visibility:hidden;position:absolute;width:80%;height:80%;left:10%;top:10%;margin:0;padding:0 10%;border:0;border-radius:.2em;display:-webkit-box;display:-moz-box;display:box;-webkit-box-pack:center;-webkit-box-align:center;-moz-box-pack:center;-moz-box-align:center;box-pack:center;box-align:center;opacity:0;-webkit-transform:scale(1.25);-webkit-filter:grayscale(100%);-webkit-transition:-webkit-filter .3s ease,-webkit-transform .3s ease,opacity .3s ease;-moz-transform:scale(1.25);-moz-filter:grayscale(100%);-moz-transition:-moz-filter .3s ease,-moz-transform .3s ease,opacity .3s ease;transform:scale(1.25);filter:grayscale(100%);transition:filter .3s ease,transform .3s ease,opacity .3s ease}#slides section .slideContainer{width:100%}#slides section.current,#slides section.out{visibility:visible}#slides section.current{opacity:1;-webkit-filter:grayscale(0);-webkit-transform:scale(1);-moz-filter:grayscale(0);-moz-transform:scale(1);filter:grayscale(0);transform:scale(1)}#slides section.out{-webkit-transform:scale(.75);-moz-transform:scale(.75);transform:scale(.75)}#slides section.editor{left:0;top:0;width:100%;height:100%;border-radius:0;background:none}#slides section.editor .editorFrame,#slides section.editor .targetFrame{position:absolute;width:50%;height:100%;top:0;padding:.5em}#slides section.editor .editorFrame{left:0;padding-right:0}#slides section.editor .targetFrame{left:50%}#slides section.editor .targetFrame iframe{z-index:14;background:#444;width:100%;height:100%;margin:0;padding:0}#slides section.editor .loaderFrame{z-index:15;background:#444;width:100%;height:100%;margin:0;padding:0}#slides section.editor .CodeMirror{font-family:\"Inconsolata\";line-height:1.2em;font-size:.5em}#slides section.editor .CodeMirror,#slides section.editor .loaderFrame,#slides section.editor .targetFrame iframe{box-shadow:0 .1em .2em rgba(0,0,0,0.6);border-radius:.1em}.CodeMirror-hints,.CodeMirror-hints li{font-family:\"Inconsolata\";line-height:1.2em;font-size:.5em;text-shadow:none}","@font-face {\n  font-family: 'Helvetica Neue LT Std';\n  font-style: normal;\n  font-weight: 400;\n  src: local('Helvetica Neue LT Std Regular'), url(HelveticaNeueLTStd-Md.otf) format('opentype');\n}\n@font-face {\n  font-family: 'Helvetica Neue LT Std';\n  font-style: normal;\n  font-weight: 700;\n  src: local('Helvetica Neue LT Std Bold'), url(HelveticaNeueLTStd-Bd.otf) format('opentype');\n}\n@font-face {\n  font-family: 'Helvetica Neue LT Std';\n  font-style: italic;\n  font-weight: 400;\n  src: local('Helvetica Neue LT Std Regular Italic'), url(HelveticaNeueLTStd-MdIt.otf) format('opentype');\n}\n@font-face {\n  font-family: 'Helvetica Neue LT Std';\n  font-style: italic;\n  font-weight: 700;\n  src: local('Helvetica Neue LT Std Bold Italic'), url(HelveticaNeueLTStd-BdIt.otf) format('opentype');\n}\n","@font-face {\n  font-family: 'Inconsolata';\n  font-style: normal;\n  font-weight: 400;\n  src: local('Inconsolata'), url(Inconsolata-Regular.ttf) format('truetype');\n}\n@font-face {\n  font-family: 'Inconsolata';\n  font-style: normal;\n  font-weight: 700;\n  src: local('Inconsolata Bold'), local('Inconsolata-Bold'), url(Inconsolata-Bold.ttf) format('truetype');\n}\n","//fgnass.github.com/spin.js#v1.3.2\n\n/**\n * Copyright (c) 2011-2013 Felix Gnass\n * Licensed under the MIT license\n */\n(function(root, factory) {\n\n  /* CommonJS */\n  if (typeof exports == 'object')  module.exports = factory()\n\n  /* AMD module */\n  else if (typeof define == 'function' && define.amd) define(factory)\n\n  /* Browser global */\n  else root.Spinner = factory()\n}\n(this, function() {\n  \"use strict\";\n\n  var prefixes = ['webkit', 'Moz', 'ms', 'O'] /* Vendor prefixes */\n    , animations = {} /* Animation rules keyed by their name */\n    , useCssAnimations /* Whether to use CSS animations or setTimeout */\n\n  /**\n   * Utility function to create elements. If no tag name is given,\n   * a DIV is created. Optionally properties can be passed.\n   */\n  function createEl(tag, prop) {\n    var el = document.createElement(tag || 'div')\n      , n\n\n    for(n in prop) el[n] = prop[n]\n    return el\n  }\n\n  /**\n   * Appends children and returns the parent.\n   */\n  function ins(parent /* child1, child2, ...*/) {\n    for (var i=1, n=arguments.length; i<n; i++)\n      parent.appendChild(arguments[i])\n\n    return parent\n  }\n\n  /**\n   * Insert a new stylesheet to hold the @keyframe or VML rules.\n   */\n  var sheet = (function() {\n    var el = createEl('style', {type : 'text/css'})\n    ins(document.getElementsByTagName('head')[0], el)\n    return el.sheet || el.styleSheet\n  }())\n\n  /**\n   * Creates an opacity keyframe animation rule and returns its name.\n   * Since most mobile Webkits have timing issues with animation-delay,\n   * we create separate rules for each line/segment.\n   */\n  function addAnimation(alpha, trail, i, lines) {\n    var name = ['opacity', trail, ~~(alpha*100), i, lines].join('-')\n      , start = 0.01 + i/lines * 100\n      , z = Math.max(1 - (1-alpha) / trail * (100-start), alpha)\n      , prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase()\n      , pre = prefix && '-' + prefix + '-' || ''\n\n    if (!animations[name]) {\n      sheet.insertRule(\n        '@' + pre + 'keyframes ' + name + '{' +\n        '0%{opacity:' + z + '}' +\n        start + '%{opacity:' + alpha + '}' +\n        (start+0.01) + '%{opacity:1}' +\n        (start+trail) % 100 + '%{opacity:' + alpha + '}' +\n        '100%{opacity:' + z + '}' +\n        '}', sheet.cssRules.length)\n\n      animations[name] = 1\n    }\n\n    return name\n  }\n\n  /**\n   * Tries various vendor prefixes and returns the first supported property.\n   */\n  function vendor(el, prop) {\n    var s = el.style\n      , pp\n      , i\n\n    prop = prop.charAt(0).toUpperCase() + prop.slice(1)\n    for(i=0; i<prefixes.length; i++) {\n      pp = prefixes[i]+prop\n      if(s[pp] !== undefined) return pp\n    }\n    if(s[prop] !== undefined) return prop\n  }\n\n  /**\n   * Sets multiple style properties at once.\n   */\n  function css(el, prop) {\n    for (var n in prop)\n      el.style[vendor(el, n)||n] = prop[n]\n\n    return el\n  }\n\n  /**\n   * Fills in default values.\n   */\n  function merge(obj) {\n    for (var i=1; i < arguments.length; i++) {\n      var def = arguments[i]\n      for (var n in def)\n        if (obj[n] === undefined) obj[n] = def[n]\n    }\n    return obj\n  }\n\n  /**\n   * Returns the absolute page-offset of the given element.\n   */\n  function pos(el) {\n    var o = { x:el.offsetLeft, y:el.offsetTop }\n    while((el = el.offsetParent))\n      o.x+=el.offsetLeft, o.y+=el.offsetTop\n\n    return o\n  }\n\n  /**\n   * Returns the line color from the given string or array.\n   */\n  function getColor(color, idx) {\n    return typeof color == 'string' ? color : color[idx % color.length]\n  }\n\n  // Built-in defaults\n\n  var defaults = {\n    lines: 12,            // The number of lines to draw\n    length: 7,            // The length of each line\n    width: 5,             // The line thickness\n    radius: 10,           // The radius of the inner circle\n    rotate: 0,            // Rotation offset\n    corners: 1,           // Roundness (0..1)\n    color: '#000',        // #rgb or #rrggbb\n    direction: 1,         // 1: clockwise, -1: counterclockwise\n    speed: 1,             // Rounds per second\n    trail: 100,           // Afterglow percentage\n    opacity: 1/4,         // Opacity of the lines\n    fps: 20,              // Frames per second when using setTimeout()\n    zIndex: 2e9,          // Use a high z-index by default\n    className: 'spinner', // CSS class to assign to the element\n    top: 'auto',          // center vertically\n    left: 'auto',         // center horizontally\n    position: 'relative'  // element position\n  }\n\n  /** The constructor */\n  function Spinner(o) {\n    if (typeof this == 'undefined') return new Spinner(o)\n    this.opts = merge(o || {}, Spinner.defaults, defaults)\n  }\n\n  // Global defaults that override the built-ins:\n  Spinner.defaults = {}\n\n  merge(Spinner.prototype, {\n\n    /**\n     * Adds the spinner to the given target element. If this instance is already\n     * spinning, it is automatically removed from its previous target b calling\n     * stop() internally.\n     */\n    spin: function(target) {\n      this.stop()\n\n      var self = this\n        , o = self.opts\n        , el = self.el = css(createEl(0, {className: o.className}), {position: o.position, width: 0, zIndex: o.zIndex})\n        , mid = o.radius+o.length+o.width\n        , ep // element position\n        , tp // target position\n\n      if (target) {\n        target.insertBefore(el, target.firstChild||null)\n        tp = pos(target)\n        ep = pos(el)\n        css(el, {\n          left: (o.left == 'auto' ? tp.x-ep.x + (target.offsetWidth >> 1) : parseInt(o.left, 10) + mid) + 'px',\n          top: (o.top == 'auto' ? tp.y-ep.y + (target.offsetHeight >> 1) : parseInt(o.top, 10) + mid)  + 'px'\n        })\n      }\n\n      el.setAttribute('role', 'progressbar')\n      self.lines(el, self.opts)\n\n      if (!useCssAnimations) {\n        // No CSS animation support, use setTimeout() instead\n        var i = 0\n          , start = (o.lines - 1) * (1 - o.direction) / 2\n          , alpha\n          , fps = o.fps\n          , f = fps/o.speed\n          , ostep = (1-o.opacity) / (f*o.trail / 100)\n          , astep = f/o.lines\n\n        ;(function anim() {\n          i++;\n          for (var j = 0; j < o.lines; j++) {\n            alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity)\n\n            self.opacity(el, j * o.direction + start, alpha, o)\n          }\n          self.timeout = self.el && setTimeout(anim, ~~(1000/fps))\n        })()\n      }\n      return self\n    },\n\n    /**\n     * Stops and removes the Spinner.\n     */\n    stop: function() {\n      var el = this.el\n      if (el) {\n        clearTimeout(this.timeout)\n        if (el.parentNode) el.parentNode.removeChild(el)\n        this.el = undefined\n      }\n      return this\n    },\n\n    /**\n     * Internal method that draws the individual lines. Will be overwritten\n     * in VML fallback mode below.\n     */\n    lines: function(el, o) {\n      var i = 0\n        , start = (o.lines - 1) * (1 - o.direction) / 2\n        , seg\n\n      function fill(color, shadow) {\n        return css(createEl(), {\n          position: 'absolute',\n          width: (o.length+o.width) + 'px',\n          height: o.width + 'px',\n          background: color,\n          boxShadow: shadow,\n          transformOrigin: 'left',\n          transform: 'rotate(' + ~~(360/o.lines*i+o.rotate) + 'deg) translate(' + o.radius+'px' +',0)',\n          borderRadius: (o.corners * o.width>>1) + 'px'\n        })\n      }\n\n      for (; i < o.lines; i++) {\n        seg = css(createEl(), {\n          position: 'absolute',\n          top: 1+~(o.width/2) + 'px',\n          transform: o.hwaccel ? 'translate3d(0,0,0)' : '',\n          opacity: o.opacity,\n          animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1/o.speed + 's linear infinite'\n        })\n\n        if (o.shadow) ins(seg, css(fill('#000', '0 0 4px ' + '#000'), {top: 2+'px'}))\n        ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')))\n      }\n      return el\n    },\n\n    /**\n     * Internal method that adjusts the opacity of a single line.\n     * Will be overwritten in VML fallback mode below.\n     */\n    opacity: function(el, i, val) {\n      if (i < el.childNodes.length) el.childNodes[i].style.opacity = val\n    }\n\n  })\n\n\n  function initVML() {\n\n    /* Utility function to create a VML tag */\n    function vml(tag, attr) {\n      return createEl('<' + tag + ' xmlns=\"urn:schemas-microsoft.com:vml\" class=\"spin-vml\">', attr)\n    }\n\n    // No CSS transforms but VML support, add a CSS rule for VML elements:\n    sheet.addRule('.spin-vml', 'behavior:url(#default#VML)')\n\n    Spinner.prototype.lines = function(el, o) {\n      var r = o.length+o.width\n        , s = 2*r\n\n      function grp() {\n        return css(\n          vml('group', {\n            coordsize: s + ' ' + s,\n            coordorigin: -r + ' ' + -r\n          }),\n          { width: s, height: s }\n        )\n      }\n\n      var margin = -(o.width+o.length)*2 + 'px'\n        , g = css(grp(), {position: 'absolute', top: margin, left: margin})\n        , i\n\n      function seg(i, dx, filter) {\n        ins(g,\n          ins(css(grp(), {rotation: 360 / o.lines * i + 'deg', left: ~~dx}),\n            ins(css(vml('roundrect', {arcsize: o.corners}), {\n                width: r,\n                height: o.width,\n                left: o.radius,\n                top: -o.width>>1,\n                filter: filter\n              }),\n              vml('fill', {color: getColor(o.color, i), opacity: o.opacity}),\n              vml('stroke', {opacity: 0}) // transparent stroke to fix color bleeding upon opacity change\n            )\n          )\n        )\n      }\n\n      if (o.shadow)\n        for (i = 1; i <= o.lines; i++)\n          seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)')\n\n      for (i = 1; i <= o.lines; i++) seg(i)\n      return ins(el, g)\n    }\n\n    Spinner.prototype.opacity = function(el, i, val, o) {\n      var c = el.firstChild\n      o = o.shadow && o.lines || 0\n      if (c && i+o < c.childNodes.length) {\n        c = c.childNodes[i+o]; c = c && c.firstChild; c = c && c.firstChild\n        if (c) c.opacity = val\n      }\n    }\n  }\n\n  var probe = css(createEl('group'), {behavior: 'url(#default#VML)'})\n\n  if (!vendor(probe, 'transform') && probe.adj) initVML()\n  else useCssAnimations = vendor(probe, 'animation')\n\n  return Spinner\n\n}));\n","// style-loader: Adds some css to the DOM by adding a <style> tag\nvar dispose = require(\"!/home/bodil/workspace/boogaloo/node_modules/style-loader/addStyle.js\")\n\t// The css code:\n\t(require(\"!!/home/bodil/workspace/boogaloo/node_modules/css-loader/index.js!/home/bodil/workspace/boogaloo/node_modules/codemirror/addon/hint/show-hint.css\"))\nif(module.hot) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(dispose);\n}","// style-loader: Adds some css to the DOM by adding a <style> tag\nvar dispose = require(\"!/home/bodil/workspace/boogaloo/node_modules/style-loader/addStyle.js\")\n\t// The css code:\n\t(require(\"!!/home/bodil/workspace/boogaloo/node_modules/css-loader/index.js!/home/bodil/workspace/boogaloo/node_modules/codemirror/addon/lint/lint.css\"))\nif(module.hot) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(dispose);\n}","// style-loader: Adds some css to the DOM by adding a <style> tag\nvar dispose = require(\"!/home/bodil/workspace/boogaloo/node_modules/style-loader/addStyle.js\")\n\t// The css code:\n\t(require(\"!!/home/bodil/workspace/boogaloo/node_modules/css-loader/index.js!/home/bodil/workspace/boogaloo/node_modules/codemirror/lib/codemirror.css\"))\nif(module.hot) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(dispose);\n}","// style-loader: Adds some css to the DOM by adding a <style> tag\nvar dispose = require(\"!/home/bodil/workspace/boogaloo/node_modules/style-loader/addStyle.js\")\n\t// The css code:\n\t(require(\"!!/home/bodil/workspace/boogaloo/node_modules/css-loader/index.js!/home/bodil/workspace/boogaloo/node_modules/codemirror/theme/xq-light.css\"))\nif(module.hot) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(dispose);\n}","// style-loader: Adds some css to the DOM by adding a <style> tag\nvar dispose = require(\"!/home/bodil/workspace/boogaloo/node_modules/style-loader/addStyle.js\")\n\t// The css code:\n\t(require(\"!!/home/bodil/workspace/boogaloo/node_modules/css-loader/index.js!/home/bodil/workspace/boogaloo/node_modules/less-loader/index.js!/home/bodil/workspace/boogaloo/src/css/screen.less\"))\nif(module.hot) {\n\tmodule.hot.accept();\n\tmodule.hot.dispose(dispose);\n}","(function(global) {\n  'use strict';\n  if (global.$traceurRuntime) {\n    return;\n  }\n  var $Object = Object;\n  var $TypeError = TypeError;\n  var $create = $Object.create;\n  var $defineProperties = $Object.defineProperties;\n  var $defineProperty = $Object.defineProperty;\n  var $freeze = $Object.freeze;\n  var $getOwnPropertyDescriptor = $Object.getOwnPropertyDescriptor;\n  var $getOwnPropertyNames = $Object.getOwnPropertyNames;\n  var $getPrototypeOf = $Object.getPrototypeOf;\n  var $hasOwnProperty = $Object.prototype.hasOwnProperty;\n  var $toString = $Object.prototype.toString;\n  function nonEnum(value) {\n    return {\n      configurable: true,\n      enumerable: false,\n      value: value,\n      writable: true\n    };\n  }\n  var method = nonEnum;\n  var counter = 0;\n  function newUniqueString() {\n    return '__$' + Math.floor(Math.random() * 1e9) + '$' + ++counter + '$__';\n  }\n  var symbolInternalProperty = newUniqueString();\n  var symbolDescriptionProperty = newUniqueString();\n  var symbolDataProperty = newUniqueString();\n  var symbolValues = $create(null);\n  function isSymbol(symbol) {\n    return typeof symbol === 'object' && symbol instanceof SymbolValue;\n  }\n  function typeOf(v) {\n    if (isSymbol(v))\n      return 'symbol';\n    return typeof v;\n  }\n  function Symbol(description) {\n    var value = new SymbolValue(description);\n    if (!(this instanceof Symbol))\n      return value;\n    throw new TypeError('Symbol cannot be new\\'ed');\n  }\n  $defineProperty(Symbol.prototype, 'constructor', nonEnum(Symbol));\n  $defineProperty(Symbol.prototype, 'toString', method(function() {\n    var symbolValue = this[symbolDataProperty];\n    if (!getOption('symbols'))\n      return symbolValue[symbolInternalProperty];\n    if (!symbolValue)\n      throw TypeError('Conversion from symbol to string');\n    var desc = symbolValue[symbolDescriptionProperty];\n    if (desc === undefined)\n      desc = '';\n    return 'Symbol(' + desc + ')';\n  }));\n  $defineProperty(Symbol.prototype, 'valueOf', method(function() {\n    var symbolValue = this[symbolDataProperty];\n    if (!symbolValue)\n      throw TypeError('Conversion from symbol to string');\n    if (!getOption('symbols'))\n      return symbolValue[symbolInternalProperty];\n    return symbolValue;\n  }));\n  function SymbolValue(description) {\n    var key = newUniqueString();\n    $defineProperty(this, symbolDataProperty, {value: this});\n    $defineProperty(this, symbolInternalProperty, {value: key});\n    $defineProperty(this, symbolDescriptionProperty, {value: description});\n    $freeze(this);\n    symbolValues[key] = this;\n  }\n  $defineProperty(SymbolValue.prototype, 'constructor', nonEnum(Symbol));\n  $defineProperty(SymbolValue.prototype, 'toString', {\n    value: Symbol.prototype.toString,\n    enumerable: false\n  });\n  $defineProperty(SymbolValue.prototype, 'valueOf', {\n    value: Symbol.prototype.valueOf,\n    enumerable: false\n  });\n  $freeze(SymbolValue.prototype);\n  Symbol.iterator = Symbol();\n  function toProperty(name) {\n    if (isSymbol(name))\n      return name[symbolInternalProperty];\n    return name;\n  }\n  function getOwnPropertyNames(object) {\n    var rv = [];\n    var names = $getOwnPropertyNames(object);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      if (!symbolValues[name])\n        rv.push(name);\n    }\n    return rv;\n  }\n  function getOwnPropertyDescriptor(object, name) {\n    return $getOwnPropertyDescriptor(object, toProperty(name));\n  }\n  function getOwnPropertySymbols(object) {\n    var rv = [];\n    var names = $getOwnPropertyNames(object);\n    for (var i = 0; i < names.length; i++) {\n      var symbol = symbolValues[names[i]];\n      if (symbol)\n        rv.push(symbol);\n    }\n    return rv;\n  }\n  function hasOwnProperty(name) {\n    return $hasOwnProperty.call(this, toProperty(name));\n  }\n  function getOption(name) {\n    return global.traceur && global.traceur.options[name];\n  }\n  function setProperty(object, name, value) {\n    var sym,\n        desc;\n    if (isSymbol(name)) {\n      sym = name;\n      name = name[symbolInternalProperty];\n    }\n    object[name] = value;\n    if (sym && (desc = $getOwnPropertyDescriptor(object, name)))\n      $defineProperty(object, name, {enumerable: false});\n    return value;\n  }\n  function defineProperty(object, name, descriptor) {\n    if (isSymbol(name)) {\n      if (descriptor.enumerable) {\n        descriptor = $create(descriptor, {enumerable: {value: false}});\n      }\n      name = name[symbolInternalProperty];\n    }\n    $defineProperty(object, name, descriptor);\n    return object;\n  }\n  function polyfillObject(Object) {\n    $defineProperty(Object, 'defineProperty', {value: defineProperty});\n    $defineProperty(Object, 'getOwnPropertyNames', {value: getOwnPropertyNames});\n    $defineProperty(Object, 'getOwnPropertyDescriptor', {value: getOwnPropertyDescriptor});\n    $defineProperty(Object.prototype, 'hasOwnProperty', {value: hasOwnProperty});\n    Object.getOwnPropertySymbols = getOwnPropertySymbols;\n    function is(left, right) {\n      if (left === right)\n        return left !== 0 || 1 / left === 1 / right;\n      return left !== left && right !== right;\n    }\n    $defineProperty(Object, 'is', method(is));\n    function assign(target, source) {\n      var props = $getOwnPropertyNames(source);\n      var p,\n          length = props.length;\n      for (p = 0; p < length; p++) {\n        target[props[p]] = source[props[p]];\n      }\n      return target;\n    }\n    $defineProperty(Object, 'assign', method(assign));\n    function mixin(target, source) {\n      var props = $getOwnPropertyNames(source);\n      var p,\n          descriptor,\n          length = props.length;\n      for (p = 0; p < length; p++) {\n        descriptor = $getOwnPropertyDescriptor(source, props[p]);\n        $defineProperty(target, props[p], descriptor);\n      }\n      return target;\n    }\n    $defineProperty(Object, 'mixin', method(mixin));\n  }\n  function exportStar(object) {\n    for (var i = 1; i < arguments.length; i++) {\n      var names = $getOwnPropertyNames(arguments[i]);\n      for (var j = 0; j < names.length; j++) {\n        (function(mod, name) {\n          $defineProperty(object, name, {\n            get: function() {\n              return mod[name];\n            },\n            enumerable: true\n          });\n        })(arguments[i], names[j]);\n      }\n    }\n    return object;\n  }\n  function toObject(value) {\n    if (value == null)\n      throw $TypeError();\n    return $Object(value);\n  }\n  function spread() {\n    var rv = [],\n        k = 0;\n    for (var i = 0; i < arguments.length; i++) {\n      var valueToSpread = toObject(arguments[i]);\n      for (var j = 0; j < valueToSpread.length; j++) {\n        rv[k++] = valueToSpread[j];\n      }\n    }\n    return rv;\n  }\n  function getPropertyDescriptor(object, name) {\n    while (object !== null) {\n      var result = $getOwnPropertyDescriptor(object, name);\n      if (result)\n        return result;\n      object = $getPrototypeOf(object);\n    }\n    return undefined;\n  }\n  function superDescriptor(homeObject, name) {\n    var proto = $getPrototypeOf(homeObject);\n    if (!proto)\n      throw $TypeError('super is null');\n    return getPropertyDescriptor(proto, name);\n  }\n  function superCall(self, homeObject, name, args) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor) {\n      if ('value' in descriptor)\n        return descriptor.value.apply(self, args);\n      if (descriptor.get)\n        return descriptor.get.call(self).apply(self, args);\n    }\n    throw $TypeError(\"super has no method '\" + name + \"'.\");\n  }\n  function superGet(self, homeObject, name) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor) {\n      if (descriptor.get)\n        return descriptor.get.call(self);\n      else if ('value' in descriptor)\n        return descriptor.value;\n    }\n    return undefined;\n  }\n  function superSet(self, homeObject, name, value) {\n    var descriptor = superDescriptor(homeObject, name);\n    if (descriptor && descriptor.set) {\n      descriptor.set.call(self, value);\n      return;\n    }\n    throw $TypeError(\"super has no setter '\" + name + \"'.\");\n  }\n  function getDescriptors(object) {\n    var descriptors = {},\n        name,\n        names = $getOwnPropertyNames(object);\n    for (var i = 0; i < names.length; i++) {\n      var name = names[i];\n      descriptors[name] = $getOwnPropertyDescriptor(object, name);\n    }\n    return descriptors;\n  }\n  function createClass(ctor, object, staticObject, superClass) {\n    $defineProperty(object, 'constructor', {\n      value: ctor,\n      configurable: true,\n      enumerable: false,\n      writable: true\n    });\n    if (arguments.length > 3) {\n      if (typeof superClass === 'function')\n        ctor.__proto__ = superClass;\n      ctor.prototype = $create(getProtoParent(superClass), getDescriptors(object));\n    } else {\n      ctor.prototype = object;\n    }\n    $defineProperty(ctor, 'prototype', {\n      configurable: false,\n      writable: false\n    });\n    return $defineProperties(ctor, getDescriptors(staticObject));\n  }\n  function getProtoParent(superClass) {\n    if (typeof superClass === 'function') {\n      var prototype = superClass.prototype;\n      if ($Object(prototype) === prototype || prototype === null)\n        return superClass.prototype;\n    }\n    if (superClass === null)\n      return null;\n    throw new TypeError();\n  }\n  function defaultSuperCall(self, homeObject, args) {\n    if ($getPrototypeOf(homeObject) !== null)\n      superCall(self, homeObject, 'constructor', args);\n  }\n  var ST_NEWBORN = 0;\n  var ST_EXECUTING = 1;\n  var ST_SUSPENDED = 2;\n  var ST_CLOSED = 3;\n  var END_STATE = -3;\n  function addIterator(object) {\n    return defineProperty(object, Symbol.iterator, nonEnum(function() {\n      return this;\n    }));\n  }\n  function GeneratorContext() {\n    this.state = 0;\n    this.GState = ST_NEWBORN;\n    this.storedException = undefined;\n    this.finallyFallThrough = undefined;\n    this.sent = undefined;\n    this.returnValue = undefined;\n    this.tryStack_ = [];\n  }\n  GeneratorContext.prototype = {\n    pushTry: function(catchState, finallyState) {\n      if (finallyState !== null) {\n        var finallyFallThrough = null;\n        for (var i = this.tryStack_.length - 1; i >= 0; i--) {\n          if (this.tryStack_[i].catch !== undefined) {\n            finallyFallThrough = this.tryStack_[i].catch;\n            break;\n          }\n        }\n        if (finallyFallThrough === null)\n          finallyFallThrough = -3;\n        this.tryStack_.push({\n          finally: finallyState,\n          finallyFallThrough: finallyFallThrough\n        });\n      }\n      if (catchState !== null) {\n        this.tryStack_.push({catch: catchState});\n      }\n    },\n    popTry: function() {\n      this.tryStack_.pop();\n    }\n  };\n  function getNextOrThrow(ctx, moveNext, action) {\n    return function(x) {\n      switch (ctx.GState) {\n        case ST_EXECUTING:\n          throw new Error((\"\\\"\" + action + \"\\\" on executing generator\"));\n        case ST_CLOSED:\n          throw new Error((\"\\\"\" + action + \"\\\" on closed generator\"));\n        case ST_NEWBORN:\n          if (action === 'throw') {\n            ctx.GState = ST_CLOSED;\n            throw x;\n          }\n          if (x !== undefined)\n            throw $TypeError('Sent value to newborn generator');\n        case ST_SUSPENDED:\n          ctx.GState = ST_EXECUTING;\n          ctx.action = action;\n          ctx.sent = x;\n          var value = moveNext(ctx);\n          var done = value === ctx;\n          if (done)\n            value = ctx.returnValue;\n          ctx.GState = done ? ST_CLOSED : ST_SUSPENDED;\n          return {\n            value: value,\n            done: done\n          };\n      }\n    };\n  }\n  function generatorWrap(innerFunction, self) {\n    var moveNext = getMoveNext(innerFunction, self);\n    var ctx = new GeneratorContext();\n    return addIterator({\n      next: getNextOrThrow(ctx, moveNext, 'next'),\n      throw: getNextOrThrow(ctx, moveNext, 'throw')\n    });\n  }\n  function AsyncFunctionContext() {\n    GeneratorContext.call(this);\n    this.err = undefined;\n    var ctx = this;\n    ctx.result = new Promise(function(resolve, reject) {\n      ctx.resolve = resolve;\n      ctx.reject = reject;\n    });\n  }\n  AsyncFunctionContext.prototype = Object.create(GeneratorContext.prototype);\n  function asyncWrap(innerFunction, self) {\n    var moveNext = getMoveNext(innerFunction, self);\n    var ctx = new AsyncFunctionContext();\n    ctx.createCallback = function(newState) {\n      return function(value) {\n        ctx.state = newState;\n        ctx.value = value;\n        moveNext(ctx);\n      };\n    };\n    ctx.createErrback = function(newState) {\n      return function(err) {\n        ctx.state = newState;\n        ctx.err = err;\n        moveNext(ctx);\n      };\n    };\n    moveNext(ctx);\n    return ctx.result;\n  }\n  function getMoveNext(innerFunction, self) {\n    return function(ctx) {\n      while (true) {\n        try {\n          return innerFunction.call(self, ctx);\n        } catch (ex) {\n          ctx.storedException = ex;\n          var last = ctx.tryStack_[ctx.tryStack_.length - 1];\n          if (!last) {\n            ctx.GState = ST_CLOSED;\n            ctx.state = END_STATE;\n            throw ex;\n          }\n          ctx.state = last.catch !== undefined ? last.catch : last.finally;\n          if (last.finallyFallThrough !== undefined)\n            ctx.finallyFallThrough = last.finallyFallThrough;\n        }\n      }\n    };\n  }\n  function setupGlobals(global) {\n    global.Symbol = Symbol;\n    polyfillObject(global.Object);\n  }\n  setupGlobals(global);\n  global.$traceurRuntime = {\n    asyncWrap: asyncWrap,\n    createClass: createClass,\n    defaultSuperCall: defaultSuperCall,\n    exportStar: exportStar,\n    generatorWrap: generatorWrap,\n    setProperty: setProperty,\n    setupGlobals: setupGlobals,\n    spread: spread,\n    superCall: superCall,\n    superGet: superGet,\n    superSet: superSet,\n    toObject: toObject,\n    toProperty: toProperty,\n    typeof: typeOf\n  };\n})(typeof global !== 'undefined' ? global : this);\n(function() {\n  function buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n    var out = [];\n    if (opt_scheme) {\n      out.push(opt_scheme, ':');\n    }\n    if (opt_domain) {\n      out.push('//');\n      if (opt_userInfo) {\n        out.push(opt_userInfo, '@');\n      }\n      out.push(opt_domain);\n      if (opt_port) {\n        out.push(':', opt_port);\n      }\n    }\n    if (opt_path) {\n      out.push(opt_path);\n    }\n    if (opt_queryData) {\n      out.push('?', opt_queryData);\n    }\n    if (opt_fragment) {\n      out.push('#', opt_fragment);\n    }\n    return out.join('');\n  }\n  ;\n  var splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + ':)?' + '(?://' + '(?:([^/?#]*)@)?' + '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' + '(?::([0-9]+))?' + ')?' + '([^?#]+)?' + '(?:\\\\?([^#]*))?' + '(?:#(.*))?' + '$');\n  var ComponentIndex = {\n    SCHEME: 1,\n    USER_INFO: 2,\n    DOMAIN: 3,\n    PORT: 4,\n    PATH: 5,\n    QUERY_DATA: 6,\n    FRAGMENT: 7\n  };\n  function split(uri) {\n    return (uri.match(splitRe));\n  }\n  function removeDotSegments(path) {\n    if (path === '/')\n      return '/';\n    var leadingSlash = path[0] === '/' ? '/' : '';\n    var trailingSlash = path.slice(-1) === '/' ? '/' : '';\n    var segments = path.split('/');\n    var out = [];\n    var up = 0;\n    for (var pos = 0; pos < segments.length; pos++) {\n      var segment = segments[pos];\n      switch (segment) {\n        case '':\n        case '.':\n          break;\n        case '..':\n          if (out.length)\n            out.pop();\n          else\n            up++;\n          break;\n        default:\n          out.push(segment);\n      }\n    }\n    if (!leadingSlash) {\n      while (up-- > 0) {\n        out.unshift('..');\n      }\n      if (out.length === 0)\n        out.push('.');\n    }\n    return leadingSlash + out.join('/') + trailingSlash;\n  }\n  function joinAndCanonicalizePath(parts) {\n    var path = parts[ComponentIndex.PATH] || '';\n    path = removeDotSegments(path.replace(/\\/\\//.g, '/'));\n    parts[ComponentIndex.PATH] = path;\n    return buildFromEncodedParts(parts[ComponentIndex.SCHEME], parts[ComponentIndex.USER_INFO], parts[ComponentIndex.DOMAIN], parts[ComponentIndex.PORT], parts[ComponentIndex.PATH], parts[ComponentIndex.QUERY_DATA], parts[ComponentIndex.FRAGMENT]);\n  }\n  function canonicalizeUrl(url) {\n    var parts = split(url);\n    return joinAndCanonicalizePath(parts);\n  }\n  function resolveUrl(base, url) {\n    var parts = split(url);\n    var baseParts = split(base);\n    if (parts[ComponentIndex.SCHEME]) {\n      return joinAndCanonicalizePath(parts);\n    } else {\n      parts[ComponentIndex.SCHEME] = baseParts[ComponentIndex.SCHEME];\n    }\n    for (var i = ComponentIndex.SCHEME; i <= ComponentIndex.PORT; i++) {\n      if (!parts[i]) {\n        parts[i] = baseParts[i];\n      }\n    }\n    if (parts[ComponentIndex.PATH][0] == '/') {\n      return joinAndCanonicalizePath(parts);\n    }\n    var path = baseParts[ComponentIndex.PATH];\n    var index = path.lastIndexOf('/');\n    path = path.slice(0, index + 1) + parts[ComponentIndex.PATH];\n    parts[ComponentIndex.PATH] = path;\n    return joinAndCanonicalizePath(parts);\n  }\n  function isAbsolute(name) {\n    if (!name)\n      return false;\n    if (name[0] === '/')\n      return true;\n    var parts = split(name);\n    if (parts[ComponentIndex.SCHEME])\n      return true;\n    return false;\n  }\n  $traceurRuntime.canonicalizeUrl = canonicalizeUrl;\n  $traceurRuntime.isAbsolute = isAbsolute;\n  $traceurRuntime.removeDotSegments = removeDotSegments;\n  $traceurRuntime.resolveUrl = resolveUrl;\n})();\n(function(global) {\n  'use strict';\n  var $__2 = $traceurRuntime,\n      canonicalizeUrl = $__2.canonicalizeUrl,\n      resolveUrl = $__2.resolveUrl,\n      isAbsolute = $__2.isAbsolute;\n  var moduleInstantiators = Object.create(null);\n  var baseURL;\n  if (global.location && global.location.href)\n    baseURL = resolveUrl(global.location.href, './');\n  else\n    baseURL = '';\n  var UncoatedModuleEntry = function UncoatedModuleEntry(url, uncoatedModule) {\n    this.url = url;\n    this.value_ = uncoatedModule;\n  };\n  ($traceurRuntime.createClass)(UncoatedModuleEntry, {}, {});\n  var UncoatedModuleInstantiator = function UncoatedModuleInstantiator(url, func) {\n    $traceurRuntime.superCall(this, $UncoatedModuleInstantiator.prototype, \"constructor\", [url, null]);\n    this.func = func;\n  };\n  var $UncoatedModuleInstantiator = UncoatedModuleInstantiator;\n  ($traceurRuntime.createClass)(UncoatedModuleInstantiator, {getUncoatedModule: function() {\n      if (this.value_)\n        return this.value_;\n      return this.value_ = this.func.call(global);\n    }}, {}, UncoatedModuleEntry);\n  function getUncoatedModuleInstantiator(name) {\n    if (!name)\n      return;\n    var url = ModuleStore.normalize(name);\n    return moduleInstantiators[url];\n  }\n  ;\n  var moduleInstances = Object.create(null);\n  var liveModuleSentinel = {};\n  function Module(uncoatedModule) {\n    var isLive = arguments[1];\n    var coatedModule = Object.create(null);\n    Object.getOwnPropertyNames(uncoatedModule).forEach((function(name) {\n      var getter,\n          value;\n      if (isLive === liveModuleSentinel) {\n        var descr = Object.getOwnPropertyDescriptor(uncoatedModule, name);\n        if (descr.get)\n          getter = descr.get;\n      }\n      if (!getter) {\n        value = uncoatedModule[name];\n        getter = function() {\n          return value;\n        };\n      }\n      Object.defineProperty(coatedModule, name, {\n        get: getter,\n        enumerable: true\n      });\n    }));\n    Object.preventExtensions(coatedModule);\n    return coatedModule;\n  }\n  var ModuleStore = {\n    normalize: function(name, refererName, refererAddress) {\n      if (typeof name !== \"string\")\n        throw new TypeError(\"module name must be a string, not \" + typeof name);\n      if (isAbsolute(name))\n        return canonicalizeUrl(name);\n      if (/[^\\.]\\/\\.\\.\\//.test(name)) {\n        throw new Error('module name embeds /../: ' + name);\n      }\n      if (name[0] === '.' && refererName)\n        return resolveUrl(refererName, name);\n      return canonicalizeUrl(name);\n    },\n    get: function(normalizedName) {\n      var m = getUncoatedModuleInstantiator(normalizedName);\n      if (!m)\n        return undefined;\n      var moduleInstance = moduleInstances[m.url];\n      if (moduleInstance)\n        return moduleInstance;\n      moduleInstance = Module(m.getUncoatedModule(), liveModuleSentinel);\n      return moduleInstances[m.url] = moduleInstance;\n    },\n    set: function(normalizedName, module) {\n      normalizedName = String(normalizedName);\n      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, (function() {\n        return module;\n      }));\n      moduleInstances[normalizedName] = module;\n    },\n    get baseURL() {\n      return baseURL;\n    },\n    set baseURL(v) {\n      baseURL = String(v);\n    },\n    registerModule: function(name, func) {\n      var normalizedName = ModuleStore.normalize(name);\n      if (moduleInstantiators[normalizedName])\n        throw new Error('duplicate module named ' + normalizedName);\n      moduleInstantiators[normalizedName] = new UncoatedModuleInstantiator(normalizedName, func);\n    },\n    bundleStore: Object.create(null),\n    register: function(name, deps, func) {\n      if (!deps || !deps.length) {\n        this.registerModule(name, func);\n      } else {\n        this.bundleStore[name] = {\n          deps: deps,\n          execute: func\n        };\n      }\n    },\n    getAnonymousModule: function(func) {\n      return new Module(func.call(global), liveModuleSentinel);\n    },\n    getForTesting: function(name) {\n      var $__0 = this;\n      if (!this.testingPrefix_) {\n        Object.keys(moduleInstances).some((function(key) {\n          var m = /(traceur@[^\\/]*\\/)/.exec(key);\n          if (m) {\n            $__0.testingPrefix_ = m[1];\n            return true;\n          }\n        }));\n      }\n      return this.get(this.testingPrefix_ + name);\n    }\n  };\n  ModuleStore.set('@traceur/src/runtime/ModuleStore', new Module({ModuleStore: ModuleStore}));\n  var setupGlobals = $traceurRuntime.setupGlobals;\n  $traceurRuntime.setupGlobals = function(global) {\n    setupGlobals(global);\n  };\n  $traceurRuntime.ModuleStore = ModuleStore;\n  global.System = {\n    register: ModuleStore.register.bind(ModuleStore),\n    get: ModuleStore.get,\n    set: ModuleStore.set,\n    normalize: ModuleStore.normalize\n  };\n  $traceurRuntime.getModuleImpl = function(name) {\n    var instantiator = getUncoatedModuleInstantiator(name);\n    return instantiator && instantiator.getUncoatedModule();\n  };\n})(typeof global !== 'undefined' ? global : this);\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/utils\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/utils\";\n  var toObject = $traceurRuntime.toObject;\n  function toUint32(x) {\n    return x | 0;\n  }\n  return {\n    get toObject() {\n      return toObject;\n    },\n    get toUint32() {\n      return toUint32;\n    }\n  };\n});\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\", [], function() {\n  \"use strict\";\n  var $__4;\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\";\n  var $__5 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/utils\"),\n      toObject = $__5.toObject,\n      toUint32 = $__5.toUint32;\n  var ARRAY_ITERATOR_KIND_KEYS = 1;\n  var ARRAY_ITERATOR_KIND_VALUES = 2;\n  var ARRAY_ITERATOR_KIND_ENTRIES = 3;\n  var ArrayIterator = function ArrayIterator() {};\n  ($traceurRuntime.createClass)(ArrayIterator, ($__4 = {}, Object.defineProperty($__4, \"next\", {\n    value: function() {\n      var iterator = toObject(this);\n      var array = iterator.iteratorObject_;\n      if (!array) {\n        throw new TypeError('Object is not an ArrayIterator');\n      }\n      var index = iterator.arrayIteratorNextIndex_;\n      var itemKind = iterator.arrayIterationKind_;\n      var length = toUint32(array.length);\n      if (index >= length) {\n        iterator.arrayIteratorNextIndex_ = Infinity;\n        return createIteratorResultObject(undefined, true);\n      }\n      iterator.arrayIteratorNextIndex_ = index + 1;\n      if (itemKind == ARRAY_ITERATOR_KIND_VALUES)\n        return createIteratorResultObject(array[index], false);\n      if (itemKind == ARRAY_ITERATOR_KIND_ENTRIES)\n        return createIteratorResultObject([index, array[index]], false);\n      return createIteratorResultObject(index, false);\n    },\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }), Object.defineProperty($__4, Symbol.iterator, {\n    value: function() {\n      return this;\n    },\n    configurable: true,\n    enumerable: true,\n    writable: true\n  }), $__4), {});\n  function createArrayIterator(array, kind) {\n    var object = toObject(array);\n    var iterator = new ArrayIterator;\n    iterator.iteratorObject_ = object;\n    iterator.arrayIteratorNextIndex_ = 0;\n    iterator.arrayIterationKind_ = kind;\n    return iterator;\n  }\n  function createIteratorResultObject(value, done) {\n    return {\n      value: value,\n      done: done\n    };\n  }\n  function entries() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_ENTRIES);\n  }\n  function keys() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_KEYS);\n  }\n  function values() {\n    return createArrayIterator(this, ARRAY_ITERATOR_KIND_VALUES);\n  }\n  return {\n    get entries() {\n      return entries;\n    },\n    get keys() {\n      return keys;\n    },\n    get values() {\n      return values;\n    }\n  };\n});\nSystem.register(\"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\";\n  var $__default = function asap(callback, arg) {\n    var length = queue.push([callback, arg]);\n    if (length === 1) {\n      scheduleFlush();\n    }\n  };\n  var browserGlobal = (typeof window !== 'undefined') ? window : {};\n  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n  function useNextTick() {\n    return function() {\n      process.nextTick(flush);\n    };\n  }\n  function useMutationObserver() {\n    var iterations = 0;\n    var observer = new BrowserMutationObserver(flush);\n    var node = document.createTextNode('');\n    observer.observe(node, {characterData: true});\n    return function() {\n      node.data = (iterations = ++iterations % 2);\n    };\n  }\n  function useSetTimeout() {\n    return function() {\n      setTimeout(flush, 1);\n    };\n  }\n  var queue = [];\n  function flush() {\n    for (var i = 0; i < queue.length; i++) {\n      var tuple = queue[i];\n      var callback = tuple[0],\n          arg = tuple[1];\n      callback(arg);\n    }\n    queue = [];\n  }\n  var scheduleFlush;\n  if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {\n    scheduleFlush = useNextTick();\n  } else if (BrowserMutationObserver) {\n    scheduleFlush = useMutationObserver();\n  } else {\n    scheduleFlush = useSetTimeout();\n  }\n  return {get default() {\n      return $__default;\n    }};\n});\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\";\n  var async = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/node_modules/rsvp/lib/rsvp/asap\").default;\n  function isPromise(x) {\n    return x && typeof x === 'object' && x.status_ !== undefined;\n  }\n  function chain(promise) {\n    var onResolve = arguments[1] !== (void 0) ? arguments[1] : (function(x) {\n      return x;\n    });\n    var onReject = arguments[2] !== (void 0) ? arguments[2] : (function(e) {\n      throw e;\n    });\n    var deferred = getDeferred(promise.constructor);\n    switch (promise.status_) {\n      case undefined:\n        throw TypeError;\n      case 'pending':\n        promise.onResolve_.push([deferred, onResolve]);\n        promise.onReject_.push([deferred, onReject]);\n        break;\n      case 'resolved':\n        promiseReact(deferred, onResolve, promise.value_);\n        break;\n      case 'rejected':\n        promiseReact(deferred, onReject, promise.value_);\n        break;\n    }\n    return deferred.promise;\n  }\n  function getDeferred(C) {\n    var result = {};\n    result.promise = new C((function(resolve, reject) {\n      result.resolve = resolve;\n      result.reject = reject;\n    }));\n    return result;\n  }\n  var Promise = function Promise(resolver) {\n    var $__6 = this;\n    this.status_ = 'pending';\n    this.onResolve_ = [];\n    this.onReject_ = [];\n    resolver((function(x) {\n      promiseResolve($__6, x);\n    }), (function(r) {\n      promiseReject($__6, r);\n    }));\n  };\n  ($traceurRuntime.createClass)(Promise, {\n    catch: function(onReject) {\n      return this.then(undefined, onReject);\n    },\n    then: function() {\n      var onResolve = arguments[0] !== (void 0) ? arguments[0] : (function(x) {\n        return x;\n      });\n      var onReject = arguments[1];\n      var $__6 = this;\n      var constructor = this.constructor;\n      return chain(this, (function(x) {\n        x = promiseCoerce(constructor, x);\n        return x === $__6 ? onReject(new TypeError) : isPromise(x) ? x.then(onResolve, onReject) : onResolve(x);\n      }), onReject);\n    }\n  }, {\n    resolve: function(x) {\n      return new this((function(resolve, reject) {\n        resolve(x);\n      }));\n    },\n    reject: function(r) {\n      return new this((function(resolve, reject) {\n        reject(r);\n      }));\n    },\n    cast: function(x) {\n      if (x instanceof this)\n        return x;\n      if (isPromise(x)) {\n        var result = getDeferred(this);\n        chain(x, result.resolve, result.reject);\n        return result.promise;\n      }\n      return this.resolve(x);\n    },\n    all: function(values) {\n      var deferred = getDeferred(this);\n      var count = 0;\n      var resolutions = [];\n      try {\n        for (var i = 0; i < values.length; i++) {\n          ++count;\n          this.cast(values[i]).then(function(i, x) {\n            resolutions[i] = x;\n            if (--count === 0)\n              deferred.resolve(resolutions);\n          }.bind(undefined, i), (function(r) {\n            if (count > 0)\n              count = 0;\n            deferred.reject(r);\n          }));\n        }\n        if (count === 0)\n          deferred.resolve(resolutions);\n      } catch (e) {\n        deferred.reject(e);\n      }\n      return deferred.promise;\n    },\n    race: function(values) {\n      var deferred = getDeferred(this);\n      try {\n        for (var i = 0; i < values.length; i++) {\n          this.cast(values[i]).then((function(x) {\n            deferred.resolve(x);\n          }), (function(r) {\n            deferred.reject(r);\n          }));\n        }\n      } catch (e) {\n        deferred.reject(e);\n      }\n      return deferred.promise;\n    }\n  });\n  function promiseResolve(promise, x) {\n    promiseDone(promise, 'resolved', x, promise.onResolve_);\n  }\n  function promiseReject(promise, r) {\n    promiseDone(promise, 'rejected', r, promise.onReject_);\n  }\n  function promiseDone(promise, status, value, reactions) {\n    if (promise.status_ !== 'pending')\n      return;\n    for (var i = 0; i < reactions.length; i++) {\n      promiseReact(reactions[i][0], reactions[i][1], value);\n    }\n    promise.status_ = status;\n    promise.value_ = value;\n    promise.onResolve_ = promise.onReject_ = undefined;\n  }\n  function promiseReact(deferred, handler, x) {\n    async((function() {\n      try {\n        var y = handler(x);\n        if (y === deferred.promise)\n          throw new TypeError;\n        else if (isPromise(y))\n          chain(y, deferred.resolve, deferred.reject);\n        else\n          deferred.resolve(y);\n      } catch (e) {\n        deferred.reject(e);\n      }\n    }));\n  }\n  var thenableSymbol = '@@thenable';\n  function promiseCoerce(constructor, x) {\n    if (isPromise(x)) {\n      return x;\n    } else if (x && typeof x.then === 'function') {\n      var p = x[thenableSymbol];\n      if (p) {\n        return p;\n      } else {\n        var deferred = getDeferred(constructor);\n        x[thenableSymbol] = deferred.promise;\n        try {\n          x.then(deferred.resolve, deferred.reject);\n        } catch (e) {\n          deferred.reject(e);\n        }\n        return deferred.promise;\n      }\n    } else {\n      return x;\n    }\n  }\n  return {get Promise() {\n      return Promise;\n    }};\n});\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/String\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/String\";\n  var $toString = Object.prototype.toString;\n  var $indexOf = String.prototype.indexOf;\n  var $lastIndexOf = String.prototype.lastIndexOf;\n  function startsWith(search) {\n    var string = String(this);\n    if (this == null || $toString.call(search) == '[object RegExp]') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var position = arguments.length > 1 ? arguments[1] : undefined;\n    var pos = position ? Number(position) : 0;\n    if (isNaN(pos)) {\n      pos = 0;\n    }\n    var start = Math.min(Math.max(pos, 0), stringLength);\n    return $indexOf.call(string, searchString, pos) == start;\n  }\n  function endsWith(search) {\n    var string = String(this);\n    if (this == null || $toString.call(search) == '[object RegExp]') {\n      throw TypeError();\n    }\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var pos = stringLength;\n    if (arguments.length > 1) {\n      var position = arguments[1];\n      if (position !== undefined) {\n        pos = position ? Number(position) : 0;\n        if (isNaN(pos)) {\n          pos = 0;\n        }\n      }\n    }\n    var end = Math.min(Math.max(pos, 0), stringLength);\n    var start = end - searchLength;\n    if (start < 0) {\n      return false;\n    }\n    return $lastIndexOf.call(string, searchString, start) == start;\n  }\n  function contains(search) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var stringLength = string.length;\n    var searchString = String(search);\n    var searchLength = searchString.length;\n    var position = arguments.length > 1 ? arguments[1] : undefined;\n    var pos = position ? Number(position) : 0;\n    if (isNaN(pos)) {\n      pos = 0;\n    }\n    var start = Math.min(Math.max(pos, 0), stringLength);\n    return $indexOf.call(string, searchString, pos) != -1;\n  }\n  function repeat(count) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var n = count ? Number(count) : 0;\n    if (isNaN(n)) {\n      n = 0;\n    }\n    if (n < 0 || n == Infinity) {\n      throw RangeError();\n    }\n    if (n == 0) {\n      return '';\n    }\n    var result = '';\n    while (n--) {\n      result += string;\n    }\n    return result;\n  }\n  function codePointAt(position) {\n    if (this == null) {\n      throw TypeError();\n    }\n    var string = String(this);\n    var size = string.length;\n    var index = position ? Number(position) : 0;\n    if (isNaN(index)) {\n      index = 0;\n    }\n    if (index < 0 || index >= size) {\n      return undefined;\n    }\n    var first = string.charCodeAt(index);\n    var second;\n    if (first >= 0xD800 && first <= 0xDBFF && size > index + 1) {\n      second = string.charCodeAt(index + 1);\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n    return first;\n  }\n  function raw(callsite) {\n    var raw = callsite.raw;\n    var len = raw.length >>> 0;\n    if (len === 0)\n      return '';\n    var s = '';\n    var i = 0;\n    while (true) {\n      s += raw[i];\n      if (i + 1 === len)\n        return s;\n      s += arguments[++i];\n    }\n  }\n  function fromCodePoint() {\n    var codeUnits = [];\n    var floor = Math.floor;\n    var highSurrogate;\n    var lowSurrogate;\n    var index = -1;\n    var length = arguments.length;\n    if (!length) {\n      return '';\n    }\n    while (++index < length) {\n      var codePoint = Number(arguments[index]);\n      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {\n        throw RangeError('Invalid code point: ' + codePoint);\n      }\n      if (codePoint <= 0xFFFF) {\n        codeUnits.push(codePoint);\n      } else {\n        codePoint -= 0x10000;\n        highSurrogate = (codePoint >> 10) + 0xD800;\n        lowSurrogate = (codePoint % 0x400) + 0xDC00;\n        codeUnits.push(highSurrogate, lowSurrogate);\n      }\n    }\n    return String.fromCharCode.apply(null, codeUnits);\n  }\n  return {\n    get startsWith() {\n      return startsWith;\n    },\n    get endsWith() {\n      return endsWith;\n    },\n    get contains() {\n      return contains;\n    },\n    get repeat() {\n      return repeat;\n    },\n    get codePointAt() {\n      return codePointAt;\n    },\n    get raw() {\n      return raw;\n    },\n    get fromCodePoint() {\n      return fromCodePoint;\n    }\n  };\n});\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\";\n  var Promise = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/Promise\").Promise;\n  var $__9 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/String\"),\n      codePointAt = $__9.codePointAt,\n      contains = $__9.contains,\n      endsWith = $__9.endsWith,\n      fromCodePoint = $__9.fromCodePoint,\n      repeat = $__9.repeat,\n      raw = $__9.raw,\n      startsWith = $__9.startsWith;\n  var $__9 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/ArrayIterator\"),\n      entries = $__9.entries,\n      keys = $__9.keys,\n      values = $__9.values;\n  function maybeDefineMethod(object, name, value) {\n    if (!(name in object)) {\n      Object.defineProperty(object, name, {\n        value: value,\n        configurable: true,\n        enumerable: false,\n        writable: true\n      });\n    }\n  }\n  function maybeAddFunctions(object, functions) {\n    for (var i = 0; i < functions.length; i += 2) {\n      var name = functions[i];\n      var value = functions[i + 1];\n      maybeDefineMethod(object, name, value);\n    }\n  }\n  function polyfillPromise(global) {\n    if (!global.Promise)\n      global.Promise = Promise;\n  }\n  function polyfillString(String) {\n    maybeAddFunctions(String.prototype, ['codePointAt', codePointAt, 'contains', contains, 'endsWith', endsWith, 'startsWith', startsWith, 'repeat', repeat]);\n    maybeAddFunctions(String, ['fromCodePoint', fromCodePoint, 'raw', raw]);\n  }\n  function polyfillArray(Array, Symbol) {\n    maybeAddFunctions(Array.prototype, ['entries', entries, 'keys', keys, 'values', values]);\n    if (Symbol && Symbol.iterator) {\n      Object.defineProperty(Array.prototype, Symbol.iterator, {\n        value: values,\n        configurable: true,\n        enumerable: false,\n        writable: true\n      });\n    }\n  }\n  function polyfill(global) {\n    polyfillPromise(global);\n    polyfillString(global.String);\n    polyfillArray(global.Array, global.Symbol);\n  }\n  polyfill(this);\n  var setupGlobals = $traceurRuntime.setupGlobals;\n  $traceurRuntime.setupGlobals = function(global) {\n    setupGlobals(global);\n    polyfill(global);\n  };\n  return {};\n});\nSystem.register(\"traceur-runtime@0.0.25/src/runtime/polyfill-import\", [], function() {\n  \"use strict\";\n  var __moduleName = \"traceur-runtime@0.0.25/src/runtime/polyfill-import\";\n  var $__11 = $traceurRuntime.getModuleImpl(\"traceur-runtime@0.0.25/src/runtime/polyfills/polyfills\");\n  return {};\n});\nSystem.get(\"traceur-runtime@0.0.25/src/runtime/polyfill-import\" + '');\n","module.exports = __webpack_public_path__ + \"9ac7e2ff6b9792291e65269b982efa35.otf\"","module.exports = __webpack_public_path__ + \"09ad3649cefc511e2e20b98991116a59.otf\"","module.exports = __webpack_public_path__ + \"f0d7d673ef06ec9cf090dc00572d63e4.otf\"","module.exports = __webpack_public_path__ + \"f02f3b1af0eda2c88d9a7ae67234c564.otf\"","module.exports = __webpack_public_path__ + \"819f56653a4197a7959c41ddfc8ff69b.ttf\"","module.exports = __webpack_public_path__ + \"9ac6e3d2a7fb76468bd417ea40b6f8c4.ttf\"","module.exports = __webpack_public_path__ + \"3bb8cd188e88dfe3b75c26c86dae0d79.svg\"","var EventEmitter = exports.EventEmitter = function EventEmitter() {};\nvar isArray = require(\"../util/isArray\");\nvar indexOf = require(\"../util/indexOf\");\n\n\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  // Check for listener leak\n  if (isArray(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (this._maxListeners !== undefined) {\n      m = this._maxListeners;\n    } else {\n      m = defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(events) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      console.trace();\n    }\n  }\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('.once only takes instances of Function');\n  }\n\n  var self = this;\n  function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  }\n\n  g.listener = listener;\n  self.on(type, g);\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var position = -1;\n    for (var i = 0, length = list.length; i < length; i++) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener))\n      {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0) return this;\n    list.splice(position, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (list === listener ||\n             (list.listener && list.listener === listener)) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  if (arguments.length === 0) {\n    this._events = {};\n    return this;\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n","var filter = require(\"../util/filter\");\n\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe =\n\t/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var match = splitPathRe.exec(path);\n  var root = match[1] || '';\n  var dir = root + (match[2] || '');\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[3] || '';\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[4] || '';\n};\n\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';","var Object_keys = function (obj) {\n    if (Object.keys) return Object.keys(obj)\n    else {\n        var res = [];\n        for (var key in obj) res.push(key)\n        return res;\n    }\n};\n\nvar forEach = function (xs, fn) {\n    if (xs.forEach) return xs.forEach(fn)\n    else for (var i = 0; i < xs.length; i++) {\n        fn(xs[i], i, xs);\n    }\n};\n\nvar Script = exports.Script = function NodeScript (code) {\n    if (!(this instanceof Script)) return new Script(code);\n    this.code = code;\n};\n\nScript.prototype.runInNewContext = function (context) {\n    if (!context) context = {};\n    \n    var iframe = document.createElement('iframe');\n    if (!iframe.style) iframe.style = {};\n    iframe.style.display = 'none';\n    \n    document.body.appendChild(iframe);\n    \n    var win = iframe.contentWindow;\n    \n    forEach(Object_keys(context), function (key) {\n        win[key] = context[key];\n    });\n     \n    if (!win.eval && win.execScript) {\n        // win.eval() magically appears when this is called in IE:\n        win.execScript('null');\n    }\n    \n    var res = win.eval(this.code);\n    \n    forEach(Object_keys(win), function (key) {\n        context[key] = win[key];\n    });\n    \n    document.body.removeChild(iframe);\n    \n    return res;\n};\n\nScript.prototype.runInThisContext = function () {\n    return eval(this.code); // maybe...\n};\n\nScript.prototype.runInContext = function (context) {\n    // seems to be just runInNewContext on magical context objects which are\n    // otherwise indistinguishable from objects except plain old objects\n    // for the parameter segfaults node\n    return this.runInNewContext(context);\n};\n\nforEach(Object_keys(Script.prototype), function (name) {\n    exports[name] = Script[name] = function (code) {\n        var s = Script(code);\n        return s[name].apply(s, [].slice.call(arguments, 1));\n    };\n});\n\nexports.createScript = function (code) {\n    return exports.Script(code);\n};\n\nexports.createContext = Script.createContext = function (context) {\n    // not really sure what this one does\n    // seems to just make a shallow copy\n    var copy = {};\n    if(typeof context === 'object') {\n        forEach(Object_keys(context), function (key) {\n            copy[key] = context[key];\n        });\n    }\n    return copy;\n};\n","module.exports = function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}","module.exports = function indexOf (xs, x) {\n    if (xs.indexOf) return xs.indexOf(x);\n    for (var i = 0; i < xs.length; i++) {\n        if (x === xs[i]) return i;\n    }\n    return -1;\n}\n","module.exports = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\n\n/*\n\nalternative\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n*/","/*global define:false */\n/**\n * Copyright 2013 Craig Campbell\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * Mousetrap is a simple keyboard shortcut library for Javascript with\n * no external dependencies\n *\n * @version 1.4.6\n * @url craig.is/killing/mice\n */\n/**\n * mapping of special keycodes to their corresponding keys\n *\n * everything in this dictionary cannot use keypress events\n * so it has to be here to map to the correct keycodes for\n * keyup/keydown events\n *\n * @type {Object}\n */\nvar _MAP = {\n  8: 'backspace',\n  9: 'tab',\n  13: 'enter',\n  16: 'shift',\n  17: 'ctrl',\n  18: 'alt',\n  20: 'capslock',\n  27: 'esc',\n  32: 'space',\n  33: 'pageup',\n  34: 'pagedown',\n  35: 'end',\n  36: 'home',\n  37: 'left',\n  38: 'up',\n  39: 'right',\n  40: 'down',\n  45: 'ins',\n  46: 'del',\n  91: 'meta',\n  93: 'meta',\n  224: 'meta'\n},\n\n    /**\n     * mapping for special characters so they can support\n     *\n     * this dictionary is only used incase you want to bind a\n     * keyup or keydown event to one of these keys\n     *\n     * @type {Object}\n     */\n    _KEYCODE_MAP = {\n      106: '*',\n      107: '+',\n      109: '-',\n      110: '.',\n      111 : '/',\n      186: ';',\n      187: '=',\n      188: ',',\n      189: '-',\n      190: '.',\n      191: '/',\n      192: '`',\n      219: '[',\n      220: '\\\\',\n      221: ']',\n      222: '\\''\n    },\n\n    /**\n     * this is a mapping of keys that require shift on a US keypad\n     * back to the non shift equivelents\n     *\n     * this is so you can use keyup events with these keys\n     *\n     * note that this will only work reliably on US keyboards\n     *\n     * @type {Object}\n     */\n    _SHIFT_MAP = {\n      '~': '`',\n      '!': '1',\n      '@': '2',\n      '#': '3',\n      '$': '4',\n      '%': '5',\n      '^': '6',\n      '&': '7',\n      '*': '8',\n      '(': '9',\n      ')': '0',\n      '_': '-',\n      '+': '=',\n      ':': ';',\n      '\\\"': '\\'',\n      '<': ',',\n      '>': '.',\n      '?': '/',\n      '|': '\\\\'\n    },\n\n    /**\n     * this is a list of special strings you can use to map\n     * to modifier keys when you specify your keyboard shortcuts\n     *\n     * @type {Object}\n     */\n    _SPECIAL_ALIASES = {\n      'option': 'alt',\n      'command': 'meta',\n      'return': 'enter',\n      'escape': 'esc',\n      'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'\n    },\n\n    /**\n     * variable to store the flipped version of _MAP from above\n     * needed to check if we should use keypress or not when no action\n     * is specified\n     *\n     * @type {Object|undefined}\n     */\n    _REVERSE_MAP,\n\n    /**\n     * a list of all the callbacks setup via Mousetrap.bind()\n     *\n     * @type {Object}\n     */\n    _callbacks = {},\n\n    /**\n     * direct map of string combinations to callbacks used for trigger()\n     *\n     * @type {Object}\n     */\n    _directMap = {},\n\n    /**\n     * keeps track of what level each sequence is at since multiple\n     * sequences can start out with the same sequence\n     *\n     * @type {Object}\n     */\n    _sequenceLevels = {},\n\n    /**\n     * variable to store the setTimeout call\n     *\n     * @type {null|number}\n     */\n    _resetTimer,\n\n    /**\n     * temporary state where we will ignore the next keyup\n     *\n     * @type {boolean|string}\n     */\n    _ignoreNextKeyup = false,\n\n    /**\n     * temporary state where we will ignore the next keypress\n     *\n     * @type {boolean}\n     */\n    _ignoreNextKeypress = false,\n\n    /**\n     * are we currently inside of a sequence?\n     * type of action (\"keyup\" or \"keydown\" or \"keypress\") or false\n     *\n     * @type {boolean|string}\n     */\n    _nextExpectedAction = false;\n\n/**\n * loop through the f keys, f1 to f19 and add them to the map\n * programatically\n */\nfor (var i = 1; i < 20; ++i) {\n  _MAP[111 + i] = 'f' + i;\n}\n\n/**\n * loop through to map numbers on the numeric keypad\n */\nfor (i = 0; i <= 9; ++i) {\n  _MAP[i + 96] = i;\n}\n\n/**\n * cross browser add event method\n *\n * @param {Element|HTMLDocument} object\n * @param {string} type\n * @param {Function} callback\n * @returns void\n */\nfunction _addEvent(object, type, callback) {\n  if (object.addEventListener) {\n    object.addEventListener(type, callback, false);\n    return;\n  }\n\n  object.attachEvent('on' + type, callback);\n}\n\n/**\n * takes the event and returns the key character\n *\n * @param {Event} e\n * @return {string}\n */\nfunction _characterFromEvent(e) {\n\n  // for keypress events we should return the character as is\n  if (e.type == 'keypress') {\n    var character = String.fromCharCode(e.which);\n\n    // if the shift key is not pressed then it is safe to assume\n    // that we want the character to be lowercase.  this means if\n    // you accidentally have caps lock on then your key bindings\n    // will continue to work\n    //\n    // the only side effect that might not be desired is if you\n    // bind something like 'A' cause you want to trigger an\n    // event when capital A is pressed caps lock will no longer\n    // trigger the event.  shift+a will though.\n    if (!e.shiftKey) {\n      character = character.toLowerCase();\n    }\n\n    return character;\n  }\n\n  // for non keypress events the special maps are needed\n  if (_MAP[e.which]) {\n    return _MAP[e.which];\n  }\n\n  if (_KEYCODE_MAP[e.which]) {\n    return _KEYCODE_MAP[e.which];\n  }\n\n  // if it is not in the special map\n\n  // with keydown and keyup events the character seems to always\n  // come in as an uppercase character whether you are pressing shift\n  // or not.  we should make sure it is always lowercase for comparisons\n  return String.fromCharCode(e.which).toLowerCase();\n}\n\n/**\n * checks if two arrays are equal\n *\n * @param {Array} modifiers1\n * @param {Array} modifiers2\n * @returns {boolean}\n */\nfunction _modifiersMatch(modifiers1, modifiers2) {\n  return modifiers1.sort().join(',') === modifiers2.sort().join(',');\n}\n\n/**\n * resets all sequence counters except for the ones passed in\n *\n * @param {Object} doNotReset\n * @returns void\n */\nfunction _resetSequences(doNotReset) {\n  doNotReset = doNotReset || {};\n\n  var activeSequences = false,\n      key;\n\n  for (key in _sequenceLevels) {\n    if (doNotReset[key]) {\n      activeSequences = true;\n      continue;\n    }\n    _sequenceLevels[key] = 0;\n  }\n\n  if (!activeSequences) {\n    _nextExpectedAction = false;\n  }\n}\n\n/**\n * finds all callbacks that match based on the keycode, modifiers,\n * and action\n *\n * @param {string} character\n * @param {Array} modifiers\n * @param {Event|Object} e\n * @param {string=} sequenceName - name of the sequence we are looking for\n * @param {string=} combination\n * @param {number=} level\n * @returns {Array}\n */\nfunction _getMatches(character, modifiers, e, sequenceName, combination, level) {\n  var i,\n      callback,\n      matches = [],\n      action = e.type;\n\n  // if there are no events related to this keycode\n  if (!_callbacks[character]) {\n    return [];\n  }\n\n  // if a modifier key is coming up on its own we should allow it\n  if (action == 'keyup' && _isModifier(character)) {\n    modifiers = [character];\n  }\n\n  // loop through all callbacks for the key that was pressed\n  // and see if any of them match\n  for (i = 0; i < _callbacks[character].length; ++i) {\n    callback = _callbacks[character][i];\n\n    // if a sequence name is not specified, but this is a sequence at\n    // the wrong level then move onto the next match\n    if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {\n      continue;\n    }\n\n    // if the action we are looking for doesn't match the action we got\n    // then we should keep going\n    if (action != callback.action) {\n      continue;\n    }\n\n    // if this is a keypress event and the meta key and control key\n    // are not pressed that means that we need to only look at the\n    // character, otherwise check the modifiers as well\n    //\n    // chrome will not fire a keypress if meta or control is down\n    // safari will fire a keypress if meta or meta+shift is down\n    // firefox will fire a keypress if meta or control is down\n    if ((action == 'keypress' && !e.metaKey && !e.ctrlKey) || _modifiersMatch(modifiers, callback.modifiers)) {\n\n      // when you bind a combination or sequence a second time it\n      // should overwrite the first one.  if a sequenceName or\n      // combination is specified in this call it does just that\n      //\n      // @todo make deleting its own method?\n      var deleteCombo = !sequenceName && callback.combo == combination;\n      var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;\n      if (deleteCombo || deleteSequence) {\n        _callbacks[character].splice(i, 1);\n      }\n\n      matches.push(callback);\n    }\n  }\n\n  return matches;\n}\n\n/**\n * takes a key event and figures out what the modifiers are\n *\n * @param {Event} e\n * @returns {Array}\n */\nfunction _eventModifiers(e) {\n  var modifiers = [];\n\n  if (e.shiftKey) {\n    modifiers.push('shift');\n  }\n\n  if (e.altKey) {\n    modifiers.push('alt');\n  }\n\n  if (e.ctrlKey) {\n    modifiers.push('ctrl');\n  }\n\n  if (e.metaKey) {\n    modifiers.push('meta');\n  }\n\n  return modifiers;\n}\n\n/**\n * prevents default for this event\n *\n * @param {Event} e\n * @returns void\n */\nfunction _preventDefault(e) {\n  if (e.preventDefault) {\n    e.preventDefault();\n    return;\n  }\n\n  e.returnValue = false;\n}\n\n/**\n * stops propogation for this event\n *\n * @param {Event} e\n * @returns void\n */\nfunction _stopPropagation(e) {\n  if (e.stopPropagation) {\n    e.stopPropagation();\n    return;\n  }\n\n  e.cancelBubble = true;\n}\n\n/**\n * actually calls the callback function\n *\n * if your callback function returns false this will use the jquery\n * convention - prevent default and stop propogation on the event\n *\n * @param {Function} callback\n * @param {Event} e\n * @returns void\n */\nfunction _fireCallback(callback, e, combo, sequence) {\n\n  // if this event should not happen stop here\n  if (Mousetrap.stopCallback(e, e.target || e.srcElement, combo, sequence)) {\n    return;\n  }\n\n  if (callback(e, combo) === false) {\n    _preventDefault(e);\n    _stopPropagation(e);\n  }\n}\n\n/**\n * handles a character key event\n *\n * @param {string} character\n * @param {Array} modifiers\n * @param {Event} e\n * @returns void\n */\nfunction _handleKey(character, modifiers, e) {\n  var callbacks = _getMatches(character, modifiers, e),\n      i,\n      doNotReset = {},\n      maxLevel = 0,\n      processedSequenceCallback = false;\n\n  // Calculate the maxLevel for sequences so we can only execute the longest callback sequence\n  for (i = 0; i < callbacks.length; ++i) {\n    if (callbacks[i].seq) {\n      maxLevel = Math.max(maxLevel, callbacks[i].level);\n    }\n  }\n\n  // loop through matching callbacks for this key event\n  for (i = 0; i < callbacks.length; ++i) {\n\n    // fire for all sequence callbacks\n    // this is because if for example you have multiple sequences\n    // bound such as \"g i\" and \"g t\" they both need to fire the\n    // callback for matching g cause otherwise you can only ever\n    // match the first one\n    if (callbacks[i].seq) {\n\n      // only fire callbacks for the maxLevel to prevent\n      // subsequences from also firing\n      //\n      // for example 'a option b' should not cause 'option b' to fire\n      // even though 'option b' is part of the other sequence\n      //\n      // any sequences that do not match here will be discarded\n      // below by the _resetSequences call\n      if (callbacks[i].level != maxLevel) {\n        continue;\n      }\n\n      processedSequenceCallback = true;\n\n      // keep a list of which sequences were matches for later\n      doNotReset[callbacks[i].seq] = 1;\n      _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);\n      continue;\n    }\n\n    // if there were no sequence matches but we are still here\n    // that means this is a regular match so we should fire that\n    if (!processedSequenceCallback) {\n      _fireCallback(callbacks[i].callback, e, callbacks[i].combo);\n    }\n  }\n\n  // if the key you pressed matches the type of sequence without\n  // being a modifier (ie \"keyup\" or \"keypress\") then we should\n  // reset all sequences that were not matched by this event\n  //\n  // this is so, for example, if you have the sequence \"h a t\" and you\n  // type \"h e a r t\" it does not match.  in this case the \"e\" will\n  // cause the sequence to reset\n  //\n  // modifier keys are ignored because you can have a sequence\n  // that contains modifiers such as \"enter ctrl+space\" and in most\n  // cases the modifier key will be pressed before the next key\n  //\n  // also if you have a sequence such as \"ctrl+b a\" then pressing the\n  // \"b\" key will trigger a \"keypress\" and a \"keydown\"\n  //\n  // the \"keydown\" is expected when there is a modifier, but the\n  // \"keypress\" ends up matching the _nextExpectedAction since it occurs\n  // after and that causes the sequence to reset\n  //\n  // we ignore keypresses in a sequence that directly follow a keydown\n  // for the same character\n  var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;\n  if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {\n    _resetSequences(doNotReset);\n  }\n\n  _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';\n}\n\n/**\n * handles a keydown event\n *\n * @param {Event} e\n * @returns void\n */\nfunction _handleKeyEvent(e) {\n\n  // normalize e.which for key events\n  // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion\n  if (typeof e.which !== 'number') {\n    e.which = e.keyCode;\n  }\n\n  var character = _characterFromEvent(e);\n\n  // no character found then stop\n  if (!character) {\n    return;\n  }\n\n  // need to use === for the character check because the character can be 0\n  if (e.type == 'keyup' && _ignoreNextKeyup === character) {\n    _ignoreNextKeyup = false;\n    return;\n  }\n\n  Mousetrap.handleKey(character, _eventModifiers(e), e);\n}\n\n/**\n * determines if the keycode specified is a modifier key or not\n *\n * @param {string} key\n * @returns {boolean}\n */\nfunction _isModifier(key) {\n  return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';\n}\n\n/**\n * called to set a 1 second timeout on the specified sequence\n *\n * this is so after each key press in the sequence you have 1 second\n * to press the next key before you have to start over\n *\n * @returns void\n */\nfunction _resetSequenceTimer() {\n  clearTimeout(_resetTimer);\n  _resetTimer = setTimeout(_resetSequences, 1000);\n}\n\n/**\n * reverses the map lookup so that we can look for specific keys\n * to see what can and can't use keypress\n *\n * @return {Object}\n */\nfunction _getReverseMap() {\n  if (!_REVERSE_MAP) {\n    _REVERSE_MAP = {};\n    for (var key in _MAP) {\n\n      // pull out the numeric keypad from here cause keypress should\n      // be able to detect the keys from the character\n      if (key > 95 && key < 112) {\n        continue;\n      }\n\n      if (_MAP.hasOwnProperty(key)) {\n        _REVERSE_MAP[_MAP[key]] = key;\n      }\n    }\n  }\n  return _REVERSE_MAP;\n}\n\n/**\n * picks the best action based on the key combination\n *\n * @param {string} key - character for key\n * @param {Array} modifiers\n * @param {string=} action passed in\n */\nfunction _pickBestAction(key, modifiers, action) {\n\n  // if no action was picked in we should try to pick the one\n  // that we think would work best for this key\n  if (!action) {\n    action = _getReverseMap()[key] ? 'keydown' : 'keypress';\n  }\n\n  // modifier keys don't work as expected with keypress,\n  // switch to keydown\n  if (action == 'keypress' && modifiers.length) {\n    action = 'keydown';\n  }\n\n  return action;\n}\n\n/**\n * binds a key sequence to an event\n *\n * @param {string} combo - combo specified in bind call\n * @param {Array} keys\n * @param {Function} callback\n * @param {string=} action\n * @returns void\n */\nfunction _bindSequence(combo, keys, callback, action) {\n\n  // start off by adding a sequence level record for this combination\n  // and setting the level to 0\n  _sequenceLevels[combo] = 0;\n\n  /**\n   * callback to increase the sequence level for this sequence and reset\n   * all other sequences that were active\n   *\n   * @param {string} nextAction\n   * @returns {Function}\n   */\n  function _increaseSequence(nextAction) {\n    return function() {\n      _nextExpectedAction = nextAction;\n      ++_sequenceLevels[combo];\n      _resetSequenceTimer();\n    };\n  }\n\n  /**\n   * wraps the specified callback inside of another function in order\n   * to reset all sequence counters as soon as this sequence is done\n   *\n   * @param {Event} e\n   * @returns void\n   */\n  function _callbackAndReset(e) {\n    _fireCallback(callback, e, combo);\n\n    // we should ignore the next key up if the action is key down\n    // or keypress.  this is so if you finish a sequence and\n    // release the key the final key will not trigger a keyup\n    if (action !== 'keyup') {\n      _ignoreNextKeyup = _characterFromEvent(e);\n    }\n\n    // weird race condition if a sequence ends with the key\n    // another sequence begins with\n    setTimeout(_resetSequences, 10);\n  }\n\n  // loop through keys one at a time and bind the appropriate callback\n  // function.  for any key leading up to the final one it should\n  // increase the sequence. after the final, it should reset all sequences\n  //\n  // if an action is specified in the original bind call then that will\n  // be used throughout.  otherwise we will pass the action that the\n  // next key in the sequence should match.  this allows a sequence\n  // to mix and match keypress and keydown events depending on which\n  // ones are better suited to the key provided\n  for (var i = 0; i < keys.length; ++i) {\n    var isFinal = i + 1 === keys.length;\n    var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);\n    _bindSingle(keys[i], wrappedCallback, action, combo, i);\n  }\n}\n\n/**\n * Converts from a string key combination to an array\n *\n * @param  {string} combination like \"command+shift+l\"\n * @return {Array}\n */\nfunction _keysFromString(combination) {\n  if (combination === '+') {\n    return ['+'];\n  }\n\n  return combination.split('+');\n}\n\n/**\n * Gets info for a specific key combination\n *\n * @param  {string} combination key combination (\"command+s\" or \"a\" or \"*\")\n * @param  {string=} action\n * @returns {Object}\n */\nfunction _getKeyInfo(combination, action) {\n  var keys,\n      key,\n      i,\n      modifiers = [];\n\n  // take the keys from this pattern and figure out what the actual\n  // pattern is all about\n  keys = _keysFromString(combination);\n\n  for (i = 0; i < keys.length; ++i) {\n    key = keys[i];\n\n    // normalize key names\n    if (_SPECIAL_ALIASES[key]) {\n      key = _SPECIAL_ALIASES[key];\n    }\n\n    // if this is not a keypress event then we should\n    // be smart about using shift keys\n    // this will only work for US keyboards however\n    if (action && action != 'keypress' && _SHIFT_MAP[key]) {\n      key = _SHIFT_MAP[key];\n      modifiers.push('shift');\n    }\n\n    // if this key is a modifier then add it to the list of modifiers\n    if (_isModifier(key)) {\n      modifiers.push(key);\n    }\n  }\n\n  // depending on what the key combination is\n  // we will try to pick the best event for it\n  action = _pickBestAction(key, modifiers, action);\n\n  return {\n    key: key,\n    modifiers: modifiers,\n    action: action\n  };\n}\n\n/**\n * binds a single keyboard combination\n *\n * @param {string} combination\n * @param {Function} callback\n * @param {string=} action\n * @param {string=} sequenceName - name of sequence if part of sequence\n * @param {number=} level - what part of the sequence the command is\n * @returns void\n */\nfunction _bindSingle(combination, callback, action, sequenceName, level) {\n\n  // store a direct mapped reference for use with Mousetrap.trigger\n  _directMap[combination + ':' + action] = callback;\n\n  // make sure multiple spaces in a row become a single space\n  combination = combination.replace(/\\s+/g, ' ');\n\n  var sequence = combination.split(' '),\n      info;\n\n  // if this pattern is a sequence of keys then run through this method\n  // to reprocess each pattern one key at a time\n  if (sequence.length > 1) {\n    _bindSequence(combination, sequence, callback, action);\n    return;\n  }\n\n  info = _getKeyInfo(combination, action);\n\n  // make sure to initialize array if this is the first time\n  // a callback is added for this key\n  _callbacks[info.key] = _callbacks[info.key] || [];\n\n  // remove an existing match if there is one\n  _getMatches(info.key, info.modifiers, {type: info.action}, sequenceName, combination, level);\n\n  // add this call back to the array\n  // if it is a sequence put it at the beginning\n  // if not put it at the end\n  //\n  // this is important because the way these are processed expects\n  // the sequence ones to come first\n  _callbacks[info.key][sequenceName ? 'unshift' : 'push']({\n    callback: callback,\n    modifiers: info.modifiers,\n    action: info.action,\n    seq: sequenceName,\n    level: level,\n    combo: combination\n  });\n}\n\n/**\n * binds multiple combinations to the same callback\n *\n * @param {Array} combinations\n * @param {Function} callback\n * @param {string|undefined} action\n * @returns void\n */\nfunction _bindMultiple(combinations, callback, action) {\n  for (var i = 0; i < combinations.length; ++i) {\n    _bindSingle(combinations[i], callback, action);\n  }\n}\n\n// start!\n_addEvent(document, 'keypress', _handleKeyEvent);\n_addEvent(document, 'keydown', _handleKeyEvent);\n_addEvent(document, 'keyup', _handleKeyEvent);\n\nvar Mousetrap = {\n\n  /**\n   * binds an event to mousetrap\n   *\n   * can be a single key, a combination of keys separated with +,\n   * an array of keys, or a sequence of keys separated by spaces\n   *\n   * be sure to list the modifier keys first to make sure that the\n   * correct key ends up getting bound (the last key in the pattern)\n   *\n   * @param {string|Array} keys\n   * @param {Function} callback\n   * @param {string=} action - 'keypress', 'keydown', or 'keyup'\n   * @returns void\n   */\n  bind: function(keys, callback, action) {\n    keys = keys instanceof Array ? keys : [keys];\n    _bindMultiple(keys, callback, action);\n    return this;\n  },\n\n  /**\n   * unbinds an event to mousetrap\n   *\n   * the unbinding sets the callback function of the specified key combo\n   * to an empty function and deletes the corresponding key in the\n   * _directMap dict.\n   *\n   * TODO: actually remove this from the _callbacks dictionary instead\n   * of binding an empty function\n   *\n   * the keycombo+action has to be exactly the same as\n   * it was defined in the bind method\n   *\n   * @param {string|Array} keys\n   * @param {string} action\n   * @returns void\n   */\n  unbind: function(keys, action) {\n    return Mousetrap.bind(keys, function() {}, action);\n  },\n\n  /**\n   * triggers an event that has already been bound\n   *\n   * @param {string} keys\n   * @param {string=} action\n   * @returns void\n   */\n  trigger: function(keys, action) {\n    if (_directMap[keys + ':' + action]) {\n      _directMap[keys + ':' + action]({}, keys);\n    }\n    return this;\n  },\n\n  /**\n   * resets the library back to its initial state.  this is useful\n   * if you want to clear out the current keyboard shortcuts and bind\n   * new ones - for example if you switch to another page\n   *\n   * @returns void\n   */\n  reset: function() {\n    _callbacks = {};\n    _directMap = {};\n    return this;\n  },\n\n  /**\n   * should we stop this event before firing off callbacks\n   *\n   * @param {Event} e\n   * @param {Element} element\n   * @return {boolean}\n   */\n  stopCallback: function(e, element) {\n\n    // if the element has the class \"mousetrap\" then no need to stop\n    if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {\n      return false;\n    }\n\n    // stop for input, select, and textarea\n    return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;\n  },\n\n  /**\n   * exposes _handleKey publicly so it can be overwritten by extensions\n   */\n  handleKey: _handleKey\n};\n\nmodule.exports = Mousetrap;\n"],"sourceRoot":"webpack-module://"}